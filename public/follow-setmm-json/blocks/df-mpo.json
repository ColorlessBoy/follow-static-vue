{"bIdx":7489,"bType":"axiom","type":"","name":"df-mpo","params":"setvar s0, setvar s1, setvar s2, class c0, class c1, class c2","body":["|- wceq(cmpo(s0, s1, c0, c1, c2), coprab(s0, s1, s2, wa(wa(wcel(cv(s0), c0), wcel(cv(s1), c1)), wceq(cv(s2), c2))))","-| diffss(s0, s2)","-| diffss(s1, s2)","-| diffsc(s2, c0)","-| diffsc(s2, c1)","-| diffsc(s2, c2)"],"bodyPretty":["⊢ (s0 ∈ c0, s1 ∈ c1 ↦ c2)= { < < s0, s1 >, s2 > |((s0 ∈ c0 ∧ s1 ∈ c1)∧ s2 = c2)}","⊣ d(s0, s2)","⊣ d(s1, s2)","⊣ d(s2, c0)","⊣ d(s2, c1)","⊣ d(s2, c2)"],"proof":[],"comment":"Define maps-to notation for defining an operation via a rule. Read as \"the operation defined by the map from ` x , y ` (in ` A X. B ` ) to ` C ( x , y ) ` \". An extension of ~ df-mpt for two arguments. (Contributed by NM, 17-Feb-2008.)","parent":[],"children":["mpoeq123","mpoeq123dva","mpt2eq3dva","nfmpt21","nfmpt22","nfmpt2","mpt20","cbvmpt2x","mpt2v","mpt2mptx","resmpt2","mpt2fun","mpt22eqb","rnmpt2","reldmmpt2","elrnmpt2res","ovmpt4g","mpt2ndm0","elmpt2cl","fmpt2x","bropopvvv","bropfvvvv","tposmpt2","erovlem","xpcomco","omxpenlem","cpnnen","mpt2mptxf","df1stres","df2ndres","f1od2","sxbrsigalem5","dmscut","bj-dfmpt2a","csbmpt22g","uncf","unccur","mpt2bi123f","cbvmpt22","cbvmpt21","mpt2mptx2","cbvmpt2x2"]}