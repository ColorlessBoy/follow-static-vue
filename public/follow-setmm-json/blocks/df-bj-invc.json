{"bIdx":37377,"bType":"axiom","type":"","name":"df-bj-invc","params":"setvar s0, setvar s1","body":["|- wceq(cinvc, cmpt(s0, cun(cccbar, ccchat), cif(cinfty, cif(crio(s1, cc, wceq(co(cv(s0), cmulc, cv(s1)), nat1)), nat0, wcel(cv(s0), cc)), wceq(cv(s0), nat0))))","-| diffss(s0, s1)"],"bodyPretty":["⊢ invc =(s0 ∈(CCbar ⋃ CChat)↦ if(s0 = 0, infty, if(s0 ∈ ℂ, iota(s1 ∈ ℂ,(s0[.cc]s1)= 1), 0)))","⊣ d(s0, s1)"],"proof":[],"comment":"Define inversion, which maps a nonzero extended complex number or element of the complex projective line (Riemann sphere) to its inverse. Beware of the overloading: the equality ` ( invc `` 0 ) = infty ` is to be understood in the complex projective line, but 0 as an extended complex number does not have an inverse, which we can state as ` ( invc `` 0 ) e/ CCbar ` . Note that this definition relies on ~ df-bj-mulc , which does not bypass ordinary complex multiplication, but defines extended complex multiplication on top of it. Therefore, we could have used directly ` / ` instead of ` ( iota_ ... .cc ... ) ` . (Contributed by BJ, 22-Jun-2019.)","parent":[],"children":[""]}