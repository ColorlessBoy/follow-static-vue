{"bIdx":39323,"bType":"axiom","type":"","name":"df-ldual","params":"setvar s0, setvar s1, setvar s2","body":["|- wceq(cld, cmpt(s0, universe, cun(ctp(cop(cfv(cbs, cnx), cfv(clfn, cv(s0))), cop(cfv(cplusg, cnx), cres(cof(cfv(cplusg, cfv(csca, cv(s0)))), cxp(cfv(clfn, cv(s0)), cfv(clfn, cv(s0))))), cop(cfv(csca, cnx), cfv(coppr, cfv(csca, cv(s0))))), csn(cop(cfv(cvsca, cnx), cmpo(s1, s2, cfv(cbs, cfv(csca, cv(s0))), cfv(clfn, cv(s0)), co(cv(s2), cof(cfv(cmulr, cfv(csca, cv(s0)))), cxp(cfv(cbs, cv(s0)), csn(cv(s1))))))))))","-| diffss(s1, s2)","-| diffss(s0, s2)","-| diffss(s0, s1)"],"bodyPretty":["‚ä¢ LDual =(s0 ‚àà ùïå ‚Ü¶({ <(Base ` ndx),(LFnl ` s0)>, <(+ ` ndx),(oF((+ `(Scalar ` s0)))|`((LFnl ` s0)√ó(LFnl ` s0)))>, <(Scalar ` ndx),(oppR `(Scalar ` s0))> } ‚ãÉ { <(√ó ` ndx),(s1 ‚àà(Base `(Scalar ` s0)), s2 ‚àà(LFnl ` s0)‚Ü¶(s2[oF((√ó `(Scalar ` s0)))]((Base ` s0)√ó { s1 })))> }))","‚ä£ d(s1, s2)","‚ä£ d(s0, s2)","‚ä£ d(s0, s1)"],"proof":[],"comment":"Define the (left) dual of a left vector space (or module) in which the vectors are functionals. In many texts, this is defined as a right vector space, but by reversing the multiplication we achieve a left vector space, as is done in definition of dual vector space in [Holland95] p. 218. This allows us to reuse our existing collection of left vector space theorems. The restriction on ` oF ( +g `` v ) ` allows it to be a set; see ~ ofmres . Note the operation reversal in the scalar product to allow us to use the original scalar ring instead of the ` oppR ` ring, for convenience. (Contributed by NM, 18-Oct-2014.)","parent":[],"children":["ldualset"]}