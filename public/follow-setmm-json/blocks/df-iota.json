{"bIdx":6624,"bType":"axiom","type":"","name":"df-iota","params":"setvar s0, setvar s1, wff w0","body":["|- wceq(cio(s0, w0), cuni(cab(s1, wceq(cab(s0, w0), csn(cv(s1))))))","-| diffss(s0, s1)","-| diffsw(s1, w0)"],"bodyPretty":["⊢ iota(s0, w0)= ⋃ { s1 | { s0 | w0 } = { s1 } }","⊣ d(s0, s1)","⊣ d(s1, w0)"],"proof":[],"comment":"Define Russell's definition description binder, which can be read as \"the unique ` x ` such that ` ph ` \", where ` ph ` ordinarily contains ` x ` as a free variable. Our definition is meaningful only when there is exactly one ` x ` such that ` ph ` is true (see ~ iotaval ); otherwise, it evaluates to the empty set (see ~ iotanul ). Russell used the inverted iota symbol ` iota ` to represent the binder. Sometimes proofs need to expand an iota-based definition. That is, given \"X = the x for which ... x ... x ...\" holds, the proof needs to get to \"... X ... X ...\". A general strategy to do this is to use ~ riotacl2 (or ~ iotacl for unbounded iota), as demonstrated in the proof of ~ supub . This can be easier than applying ~ riotasbc or a version that applies an explicit substitution, because substituting an iota into its own property always has a bound variable clash which must be first renamed or else guarded with NF. (Contributed by Andrew Salmon, 30-Jun-2011.)","parent":[],"children":["dfiota2","iotaeq","iotabi","dffv4","dfiota3","reuabaiotaiota"]}