{"bIdx":48185,"bType":"axiom","type":"","name":"df-setrecs","params":"setvar s0, setvar s1, setvar s2, class c0","body":["|- wceq(csetrecs(c0), cuni(cab(s0, wal(s1, wi(wal(s2, wi(wss(cv(s2), cv(s0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c0, cv(s2)), cv(s1))))), wss(cv(s0), cv(s1)))))))","-| diffss(s0, s2)","-| diffss(s1, s2)","-| diffss(s0, s1)","-| diffsc(s2, c0)","-| diffsc(s0, c0)","-| diffsc(s1, c0)"],"bodyPretty":["⊢ setrecs(c0)= ⋃ { s0 | ∀(s1,(∀(s2,(s2 ⊆ s0 →(s2 ⊆ s1 →(c0 ` s2)⊆ s1)))→ s0 ⊆ s1))}","⊣ d(s0, s2)","⊣ d(s1, s2)","⊣ d(s0, s1)","⊣ d(s2, c0)","⊣ d(s0, c0)","⊣ d(s1, c0)"],"proof":[],"comment":"Define a class ` setrecs ( F ) ` by transfinite recursion, where ` ( F `` x ) ` is the set of new elements to add to the class given the set ` x ` of elements in the class so far. We do not need a base case, because we can start with the empty set, which is vacuously a subset of ` setrecs ( F ) ` . The goal of this definition is to construct a class fulfilling theorems ~ setrec1 and ~ setrec2v , which give a more intuitive idea of the meaning of ` setrecs ` . Unlike ` wrecs ` , ` setrecs ` is well-defined for any ` F ` and meaningful for any function ` F ` . For example, see theorem ~ onsetrec for how the class ` On ` is defined recursively using the successor function. The definition works by building subsets of the desired class and taking the union of those subsets. To find such a collection of subsets, consider an arbitrary set ` z ` , and consider the result when applying ` F ` to any subset ` w C_ z ` . Remember that ` F ` can be any function, and in general we are interested in functions that give outputs that are larger than their inputs, so we have no reason to expect the outputs to be within ` z ` . However, if we restrict the domain of ` F ` to a given set ` y ` , the resulting range will be a set. Therefore, with this restricted ` F ` , it makes sense to consider sets ` z ` that are closed under ` F ` applied to its subsets. Now we can test whether a given set ` y ` is recursively generated by ` F ` . If every set ` z ` that is closed under ` F ` contains ` y ` , that means that every member of ` y ` must eventually be generated by ` F ` . On the other hand, if some such ` z ` does not contain a certain element of ` y ` , then that element can be avoided even if we apply ` F ` in every possible way to previously generated elements. Note that such an omitted element might be eventually recursively generated by ` F ` , but not through the elements of ` y ` . In this case, ` y ` would fail the condition in the definition, but the omitted element would still be included in some larger ` y ` . For example, if ` F ` is the successor function, the set ` { (/) , 2o } ` would fail the condition since ` 2o ` is not an element of the successor of ` (/) ` or ` { (/) } ` . Remember that we are applying ` F ` to subsets of ` y ` , not elements of ` y ` . In fact, even the set ` { 1o } ` fails the condition, since the only subset of previously generated elements is ` (/) ` , and ` suc (/) ` does not have ` 1o ` as an element. However, we can let ` y ` be any ordinal, since each of its elements is generated by starting with ` (/) ` and repeatedly applying the successor function. A similar definition I initially used for ` setrecs ( F ) ` was ` setrecs ( F ) = U. ran recs ( ( g e. _V |-> ( F `` U. ran g ) ) ) ` . I had initially tried and failed to find an elementary definition, and I had proven theorems analogous to ~ setrec1 and ~ setrec2v using the old definition before I found the new one. I decided to change definitions for two reasons. First, as John Horton Conway noted in the Appendix to Part Zero of On Numbers and Games, mathematicians should not be caught up in any particular formalization, such as ZF set theory. Instead, they should work under whatever framework best suits the problem, and the formal bases used for different problems can be shown to be equivalent. Thus, Conway preferred defining surreal numbers as equivalence classes of surreal number forms, rather than sign-expansions. Although sign-expansions are easier to implement in ZF set theory, Conway argued that \"formalisation within some particular axiomatic set theory is irrelevant\". Furthermore, one of the most remarkable properties of the theory of surreal numbers is that it generates so much from almost nothing. Using sign-expansions as the formal definition destroys the beauty of surreal numbers, because ordinals are already built in. For this reason, I replaced the old definition of ` setrecs ` , which also relied heavily on ordinal numbers. On the other hand, both surreal numbers and the elementary definition of ` setrecs ` immediately generate the ordinal numbers from a (relatively) very simple set-theoretical basis. Second, although it is still complicated to formalize the theory of recursively generated sets within ZF set theory, it is actually simpler and more natural to do so with set theory directly than with the theory of ordinal numbers. As Conway wrote, indexing the \"birthdays\" of sets is and should be unnecessary. Using an elementary definition for ` setrecs ` removes the reliance on the previously developed theory of ordinal numbers, allowing proofs to be simpler and more direct. Formalizing surreal numbers within Metamath is probably still not in the spirit of Conway. He said that \"attempts to force arbitrary theories into a single formal straitjacket... produce unnecessarily cumbrous and inelegant contortions.\" Nevertheless, Metamath has proven to be much more versatile than it seems at first, and I think the theory of surreal numbers can be natural while fitting well into the Metamath framework. The difficulty in writing a definition in Metamath for ` setrecs ( F ) ` is that the necessary properties to prove are self-referential (see ~ setrec1 and ~ setrec2v ), so we cannot simply write the properties we want inside a class abstraction as with most definitions. As noted in the comment of ~ df-rdg , this is not actually a requirement of the Metamath language, but we would like to be able to eliminate all definitions by direct mechanical substitution. We cannot define ` setrecs ` using a class abstraction directly, because nothing about its individual elements tells us whether they are in the set. We need to know about previous elements first. One way of getting around this problem without indexing is by defining ` setrecs ( F ) ` as a union or intersection of suitable sets. Thus, instead of using a class abstraction for the elements of ` setrecs ( F ) ` , which seems to be impossible, we can use a class abstraction for supersets or subsets of ` setrecs ( F ) ` , which \"know\" about multiple individual elements at a time. Note that we cannot define ` setrecs ( F ) ` as an intersection of sets, because in general it is a proper class, so any supersets would also be proper classes. However, a proper class can be a union of sets, as long as the collection of such sets is a proper class. Therefore, it is feasible to define ` setrecs ( F ) ` as a union of a class abstraction. If ` setrecs ( F ) = U. A ` , the elements of A must be subsets of ` setrecs ( F ) ` which together include everything recursively generated by ` F ` . We can do this by letting ` A ` be the class of sets ` x ` whose elements are all recursively generated by ` F ` . One necessary condition is that each element of a given ` x e. A ` must be generated by ` F ` when applied to a previous element ` y e. A ` . In symbols, ` A. x e. A E. y e. A ( y C_ x /\\ x C_ ( F `` y ) ) } ` . However, this is not sufficient. All fixed points ` x ` of ` F ` will satisfy this condition whether they should be in ` setrecs ( F ) ` or not. If we replace the subset relation with the proper subset relation, ` x ` cannot be the empty set, even though the empty set should be in ` A ` . Therefore this condition cannot be used in the definition, even if we can find a way to avoid making it circular. A better strategy is to find a necessary and sufficient condition for all the elements of a set ` y e. A ` to be generated by ` F ` when applied only to sets of previously generated elements within ` y ` . For example, taking ` F ` to be the successor function, we can let ` A = On ` rather than ` ~P On ` , and we will still have ` U. A = On ` as required. This gets rid of the circularity of the definition, since we should have a condition to test whether a given set ` y ` is in ` A ` without knowing about any of the other elements of ` A ` . The definition I ended up using accomplishes this using induction: ` A ` is defined as the class of sets ` y ` for which a sort of induction on the elements of ` y ` holds. However, when creating a definition for ` setrecs ` that did not rely on ordinal numbers, I tried at first to write a definition using the well-founded relation predicate, ` Fr ` . I thought that this would be simple to do once I found a suitable definition using induction, just as the least- element principle is equivalent to induction on the positive integers. If we let ` R = { <. a , b >. | ( F `` a ) C_ b } ` , then ` ( R Fr A <-> A. x ( ( x C_ A /\\ x =/= (/) ) ` ` -> E. y e. x A. z e. x -. ( F `` z ) C_ y ) ) ` . On 22-Jul-2020 I came up with the following definition (Version 1) phrased in terms of induction: ` U. { y | A. z ` ` ( A. w ( w C_ y -> ( w e. z -> ( F `` w ) e. z ) ) -> y e. z ) } ` In Aug-2020 I came up with an equivalent definition with the goal of phrasing it in terms of the relation ` Fr ` . It is the contrapositive of the previous one with ` z ` replaced by its complement. ` U. { y | A. z ` ` ( y e. z -> E. w ( w C_ y /\\ ( F `` w ) e. z /\\ -. w e. z ) ) } ` These definitions didn't work because the induction didn't \"get off the ground.\" If ` z ` does not contain the empty set, the condition ` ( A. w ... y e. z ` fails, so ` y = (/) ` doesn't get included in ` A ` even though it should. This could be fixed by adding the base case as a separate requirement, but the subtler problem would remain that rather than a set of \"acceptable\" sets, what we really need is a collection ` z ` of all individuals that have been generated so far. So one approach is to replace every occurence of ` e. z ` with ` C_ z ` , making ` z ` a set of individuals rather than a family of sets. That solves this problem, but it complicates the foundedness version of the definition, which looked cleaner in Version 1. There was another problem with Version 1. If we let ` F ` be the power set function, then the induction in the inductive version works for ` z ` being the class of transitive sets, restricted to subsets of ` y ` . Therefore, ` y ` must be transitive by definition of ` z ` . This doesn't affect the union of all such ` y ` , but it may or may not be desirable. The problem is that ` F ` is only applied to transitive sets, because of the strong requirement ` w e. z ` , so the definition requires the additional constraint ` ( a C_ b -> ( F ` a ) C_ ( F ` b ) ) ` in order to work. This issue can also be avoided by replacing ` e. z ` with ` C_ z ` . The induction version of the result is used in the final definition. Version 2: (18-Aug-2020) Induction: ` U. { y | A. z ` ` ( A. w ( w C_ y -> ( w C_ z -> ( F `` w ) C_ z ) ) -> y C_ z ) } ` Foundedness: ` U. { y | A. z ( y i^i z =/= (/) -> ` ` E. w ( w C_ y /\\ w i^i z = (/) /\\ ( F `` w ) i^i z =/= (/) ) ) } ` In the induction version, not only does ` z ` include all the elements of ` y ` , but it must include the elements of ` ( F `` w ) ` for ` w C_ ( y i^i z ) ` even if those elements of ` ( F `` w ) ` are not in ` y ` . We shouldn't care about any of the elements of ` z ` outside ` y ` , but this detail doesn't affect the correctness of the definition. If we replaced ` ( F `` w ) ` in the definition by ` ( ( F `` w ) i^i y ) ` , we would get the same class for ` setrecs ( F ) ` . Suppose we could find a ` z ` for which the condition fails for a given ` y ` under the changed definition. Then the antecedent would be true, but ` y C_ z ` would be false. We could then simply add all elements of ` ( F `` w ) ` outside of ` y ` for any ` w C_ y ` , which we can do because all the classes involved are sets. This is not trivial and requires the axioms of union, power set, and replacement. However, the expanded ` z ` fails the condition under the Metamath definition. The other direction is easier. If a certain ` z ` fails the Metamath definition, then all ` ( F `` w ) C_ z ` for ` w C_ ( y i^i z ) ` , and in particular ` ( ( F `` w ) i^i y ) C_ z ` . The foundedness version is starting to look more like ~ ax-reg ! We want to take advantage of the preexisting relation ` Fr ` , which seems closely related to our foundedness definition. Since we only care about the elements of ` z ` which are subsets of ` y ` , we can restrict ` z ` to ` y ` in the foundedness definition. Furthermore, instead of quantifying over ` w ` , quantify over the elements ` v e. z ` overlapping with ` w ` . Versions 3, 4, and 5 are all equivalent to Version 2. Version 3 - Foundedness (5-Sep-2020): ` U. { y | A. z ( ( z C_ y /\\ z =/= (/) ) ` ` -> E. v e. z E. w ( w C_ y /\\ w i^i z = (/) /\\ v e. ( F `` w ) ) ) } ` Now, if we replace ` ( F `` w ) ` by ` ( ( F `` w ) i^i y ) ` , we do not change the definition. We already know that ` v e. y ` since ` v e. z ` and ` z C_ y ` . All we need to show in order to prove that this change leads to an equivalent definition is to find To make our definition look exactly like ~ df-fr , we add another variable ` u ` representing the nonexistent element of ` w ` in ` z ` . Version 4 - Foundedness (6-Sep-2020): ` U. { y | A. z ( ( z C_ y /\\ z =/= (/) ) -> ` ` E. v e. z E. w A. u e. z ( w C_ y /\\ -. u e. w /\\ v e. ( F `` w ) ) ` This is so close to ~ df-fr ; the only change needed is to switch ` E. w ` with ` A. u e. z ` . Unfortunately, I couldn't find any way to switch the quantifiers without interfering with the definition. Maybe there is a definition equivalent to this one that uses ` Fr ` , but I couldn't find one. Yet, we can still find a remarkable similarity between Foundedness Version 2 and ~ ax-reg . Rather than a disjoint element of ` z ` , there's a disjoint coverer of an element of ` z ` . Finally, here's a different dead end I followed: To clean up our foundedness definition, we keep ` z ` as a family of sets ` y ` but allow ` w ` to be any subset of ` U. z ` in the induction. With this stronger induction, we can also allow for the stronger requirement ` ~P y C_ z ` rather than only ` y e. z ` . This will help improve the foundedness version. Version 1.1 (28-Aug-2020) Induction: ` U. { y | A. z ( A. w ` ` ( w C_ y -> ( w C_ U. z -> ( F `` w ) e. z ) ) -> ~P y C_ z ) } ` Foundedness: ` U. { y | A. z ( E. a ( a C_ y /\\ a e. z ) ` ` -> E. w ( w C_ y /\\ w i^i |^| z = (/) /\\ ( F `` w ) e. z ) ) } ` ( Edit (Aug 31) - this isn't true! Nothing forces the subset of an element of ` z ` to be in ` z ` . Version 2 does not have this issue. ) Similarly, we could allow ` w ` to be any subset of any element of ` z ` rather than any subset of ` U. z ` . I think this has the same problem. We want to take advantage of the preexisting relation ` Fr ` , which seems closely related to our foundedness definition. Since we only care about the elements of ` z ` which are subsets of ` y ` , we can restrict ` z ` to ` ~P y ` in the foundedness definition: Version 1.2 (31-Aug-2020) Foundedness: ` U. { y | A. z ( ( z C_ ~P y /\\ z =/= (/) ) ` ` -> E. w ( w e. ~P y /\\ w i^i |^| z = (/) /\\ ( F `` w ) e. z ) ) } ` Now this looks more like ~ df-fr ! The last step necessary to be able to use ` Fr ` directly in our definition is to replace ` ( F `` w ) ` with its own setvar variable, corresponding to ` y ` in ~ df-fr . This definition is incorrect, though, since there's nothing forcing the subset of an element of ` z ` to be in ` z ` . Version 1.3 (31-Aug-2020) Induction: ` U. { y | A. z ( A. w ( w C_ y ` ` -> ( w C_ U. z -> ( w e. z /\\ ( F `` w ) e. z ) ) ) -> ~P y C_ z ) } ` Foundedness: ` U. { y | A. z ( ( z C_ ~P y /\\ z =/= (/) ) -> E. w ( w e. ~P y ` ` /\\ w i^i |^| z = (/) /\\ ( w e. z \\/ ( F `` w ) e. z ) ) ) } ` ` z ` must contain the supersets of each of its elements in the foundedness version, and we can't make any restrictions on ` z ` or ` F ` , so this doesn't work. Let's try letting R be the covering relation ` R = { <. a , b >. | b e. ( F `` a ) } ` to solve the transitivity issue (i.e. that if ` F ` is the power set relation, ` A ` consists only of transitive sets). The set ` ( F `` w ) ` corresponds to the variable ` y ` in ~ df-fr . Thus, in our case, ~ df-fr is equivalent to ` ( R Fr A <-> A. z ( ( z C_ A /\\ z =/= (/) ) ` ` -> E. w ( ( F `` w ) e. z /\\ -. E. v e. z v R ( F `` w ) ) ) ` . Substituting our relation ` R ` gives ` ( R Fr A <-> A. z ( ( z C_ A /\\ z =/= (/) ) -> ` ` E. w ( ( F `` w ) e. z /\\ -. E. v e. z ( F `` w ) e. ( F `` v ) ) ) ` This doesn't work for non-injective ` F ` because we need all ` z ` to be straddlers, but we don't necessarily need all-straddlers; loops within z are fine for non-injective F. Consider the foundedness form of Version 1. We want to show ` -. w e. z <-> A. v e. z -. v R ( F `` w ) ` so we can replace one with the other. Negate both sides: ` w e. z <-> E. v e. z v R ( F `` w ) ` If ` F ` is injective, then we should be able to pick a suitable R, being careful about the above problem for some F (for example z = transitivity) when changing the antecedent y e. z' to z =/= (/). If we're clever, we can get rid of the injectivity requirement. The forward direction of the above equivalence always holds, but the key is that although the backwards direction doesn't hold in general, we can always find some z' where it doesn't work for ` w ` itself. If there exists a z' where the version with the w condition fails, then there exists a z' where the version with the v condition also fails. However, Version 1 is not a correct definition, so this doesn't work either. (Contributed by Emmett Weisz, 18-Aug-2020.) (New usage is discouraged.)","parent":[],"children":["setrecseq","nfsetrecs","setrec1","setrec2fun","setrec2"]}