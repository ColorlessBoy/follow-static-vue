{"bIdx":35095,"bType":"axiom","type":"","name":"df-goeq","params":"setvar s0, setvar s1, setvar s2","body":["|- wceq(cgoq, cmpo(s0, s1, com, com, csb(s2, csuc(cun(cv(s0), cv(s1))), cgol(cv(s2), co(co(cv(s2), cgoe, cv(s0)), cgob, co(cv(s2), cgoe, cv(s1)))))))","-| diffss(s0, s1)","-| diffss(s0, s2)","-| diffss(s1, s2)"],"bodyPretty":["⊢ =g =(s0 ∈ _om, s1 ∈ _om ↦[suc((s0 ⋃ s1))/ s2]∀(s2,((s2[e.g]s0)[↔g](s2[e.g]s1))))","⊣ d(s0, s1)","⊣ d(s0, s2)","⊣ d(s1, s2)"],"proof":[],"comment":"Define the Godel-set of equality. Here the arguments ` x = <. N , P >. ` correspond to v_N and v_P , so ` ( (/) =g 1o ) ` actually means v_0 ` = ` v_1 , not ` 0 = 1 ` . Here we use the trick mentioned in ~ ax-ext to introduce equality as a defined notion in terms of ` e.g ` . The expression ` suc ( u u. v ) = ` max ` ( u , v ) + 1 ` here is a convenient way of getting a dummy variable distinct from ` u ` and ` v ` . (Contributed by Mario Carneiro, 14-Jul-2013.)","parent":[],"children":[""]}