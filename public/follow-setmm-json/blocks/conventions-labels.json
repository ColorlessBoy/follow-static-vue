{"bIdx":30435,"bType":"thm","type":"","name":"conventions-labels","params":"wff w0","body":["|- w0","-| w0"],"bodyPretty":["⊢ w0","⊣ w0"],"proof":[{"stmt":{"origin":"idi(w0)","pretty":"idi(w0)"},"body":{"origin":"|- w0\n-| w0","pretty":"⊢ w0\n⊣ w0"},"cumulated":{"origin":"|- w0\n-| w0","pretty":"⊢ w0\n⊣ w0"}}],"comment":"<HTML> <p> The following gives conventions used in the Metamath Proof Explorer (MPE, set.mm) regarding labels. For other conventions, see ~ conventions and links therein. </p> <p> Every statement has a unique identifying label, which serves the same purpose as an equation number in a book. We use various label naming conventions to provide easy-to-remember hints about their contents. Labels are not a 1-to-1 mapping, because that would create long names that would be difficult to remember and tedious to type. Instead, label names are relatively short while suggesting their purpose. Names are occasionally changed to make them more consistent or as we find better ways to name them. Here are a few of the label naming conventions: </p> <ul> <li><b>Axioms, definitions, and wff syntax.</b> As noted earlier, axioms are named \"ax-NAME\", proofs of proven axioms are named \"axNAME\", and definitions are named \"df-NAME\". Wff syntax declarations have labels beginning with \"w\" followed by short fragment suggesting its purpose. </li> <li><b>Hypotheses.</b> Hypotheses have the name of the final axiom or theorem, followed by \".\", followed by a unique id (these ids are usually consecutive integers starting with 1, e.g. for ~ rgen \"rgen.1 $e |- ( x e. A -> ph ) $.\" or letters corresponding to the (main) class variable used in the hypothesis, e.g. for ~ mdet0 : \"mdet0.d $e |- D = ( N maDet R ) $.\"). </li> <li><b>Common names.</b> If a theorem has a well-known name, that name (or a short version of it) is sometimes used directly. Examples include ~ barbara and ~ stirling . </li> <li><b>Principia Mathematica.</b> Proofs of theorems from Principia Mathematica often use a special naming convention: \"pm\" followed by its identifier. For example, Theorem *2.27 of [WhiteheadRussell] p. 104 is named ~ pm2.27 . </li> <li><b>19.x series of theorems.</b> Similar to the conventions for the theorems from Principia Mathematica, theorems from Section 19 of [Margaris] p. 90 often use a special naming convention: \"19.\" resp. \"r19.\" (for corresponding restricted quantifier versions) followed by its identifier. For example, Theorem 38 from Section 19 of [Margaris] p. 90 is labeled ~ 19.38 , and the restricted quantifier version of Theorem 21 from Section 19 of [Margaris] p. 90 is labeled ~ r19.21 . </li> <li><b>Characters to be used for labels.</b> Although the specification of Metamath allows for dots/periods \".\" in any label, it is usually used only in labels for hypotheses (see above). Exceptions are the labels of theorems from Principia Mathematica and the 19.x series of theorems from Section 19 of [Margaris] p. 90 (see above) and ~ 0.999... . Furthermore, the underscore \"_\" should not be used. Finally, only lower case characters should be used (except the special suffixes OLD, ALT and ALTV mentioned in bullet point \"Suffixes\"), at least in main set.mm (exceptions are tolerated in mathboxes). </li> <li><b>Syntax label fragments.</b> Most theorems are named using a concatenation of syntax label fragments (omitting variables) that represent the important part of the theorem's main conclusion. Almost every syntactic construct has a definition labeled \"df-NAME\", and normally NAME is the syntax label fragment. For example, the class difference construct ` ( A \\ B ) ` is defined in ~ df-dif , and thus its syntax label fragment is \"dif\". Similarly, the subclass relation ` A C_ B ` has syntax label fragment \"ss\" because it is defined in ~ df-ss . Most theorem names follow from these fragments, for example, the theorem proving ` ( A \\ B ) C_ A ` involves a class difference (\"dif\") of a subset (\"ss\"), and thus is labeled ~ difss . There are many other syntax label fragments, e.g., singleton construct ` { A } ` has syntax label fragment \"sn\" (because it is defined in ~ df-sn ), and the pair construct ` { A , B } ` has fragment \"pr\" ( from ~ df-pr ). Digits are used to represent themselves. Suffixes (e.g., with numbers) are sometimes used to distinguish multiple theorems that would otherwise produce the same label. </li> <li><b>Phantom definitions.</b> In some cases there are common label fragments for something that could be in a definition, but for technical reasons is not. The is-element-of (is member of) construct ` A e. B ` does not have a df-NAME definition; in this case its syntax label fragment is \"el\". Thus, because the theorem beginning with ` ( A e. ( B \\ { C } ) ` uses is-element-of (\"el\") of a class difference (\"dif\") of a singleton (\"sn\"), it is labeled ~ eldifsn . An \"n\" is often used for negation ( ` -. ` ), e.g., ~ nan . </li> <li><b>Exceptions.</b> Sometimes there is a definition df-NAME but the label fragment is not the NAME part. The definition should note this exception as part of its definition. In addition, the table below attempts to list all such cases and marks them in bold. For example, the label fragment \"cn\" represents complex numbers ` CC ` (even though its definition is in ~ df-c ) and \"re\" represents real numbers ` RR ` ( definition ~ df-r ). The empty set ` (/) ` often uses fragment 0, even though it is defined in ~ df-nul . The syntax construct ` ( A + B ) ` usually uses the fragment \"add\" (which is consistent with ~ df-add ), but \"p\" is used as the fragment for constant theorems. Equality ` ( A = B ) ` often uses \"e\" as the fragment. As a result, \"two plus two equals four\" is labeled ~ 2p2e4 . </li> <li><b>Other markings.</b> In labels we sometimes use \"com\" for \"commutative\", \"ass\" for \"associative\", \"rot\" for \"rotation\", and \"di\" for \"distributive\". </li> <li><b>Focus on the important part of the conclusion.</b> Typically the conclusion is the part the user is most interested in. So, a rough guideline is that a label typically provides a hint about only the conclusion; a label rarely says anything about the hypotheses or antecedents. If there are multiple theorems with the same conclusion but different hypotheses/antecedents, then the labels will need to differ; those label differences should emphasize what is different. There is no need to always fully describe the conclusion; just identify the important part. For example, ~ cos0 is the theorem that provides the value for the cosine of 0; we would need to look at the theorem itself to see what that value is. The label \"cos0\" is concise and we use it instead of \"cos0eq1\". There is no need to add the \"eq1\", because there will never be a case where we have to disambiguate between different values produced by the cosine of zero, and we generally prefer shorter labels if they are unambiguous. </li> <li><b>Closures and values.</b> As noted above, if a function df-NAME is defined, there is typically a proof of its value labeled \"NAMEval\" and of its closure labeld \"NAMEcl\". E.g., for cosine ( ~ df-cos ) we have value ~ cosval and closure ~ coscl . </li> <li><b>Special cases.</b> Sometimes, syntax and related markings are insufficient to distinguish different theorems. For example, there are over a hundred different implication-only theorems. They are grouped in a more ad-hoc way that attempts to make their distinctions clearer. These often use abbreviations such as \"mp\" for \"modus ponens\", \"syl\" for syllogism, and \"id\" for \"identity\". It is especially hard to give good names in the propositional calculus section because there are so few primitives. However, in most cases this is not a serious problem. There are a few very common theorems like ~ ax-mp and ~ syl that you will have no trouble remembering, a few theorem series like syl*anc and simp* that you can use parametrically, and a few other useful glue things for destructuring 'and's and 'or's (see ~ natded for a list), and that is about all you need for most things. As for the rest, you can just assume that if it involves at most three connectives, then it is probably already proved in set.mm, and searching for it will give you the label. </li> <li><b>Suffixes.</b> Suffixes are used to indicate the form of a theorem (see above). Additionally, we sometimes suffix with \"v\" the label of a theorem eliminating a hypothesis such as ` F/ x ph ` in ~ 19.21 via the use of disjoint variable conditions combined with ~ nfv . If two (or three) such hypotheses are eliminated, the suffix \"vv\" resp. \"vvv\" is used, e.g. ~ exlimivv . Conversely, we sometimes suffix with \"f\" the label of a theorem introducing such a hypothesis to eliminate the need for the disjoint variable condition; e.g. ~ euf derived from ~ eu6 . The \"f\" stands for \"not free in\" which is less restrictive than \"does not occur in.\" The suffix \"b\" often means \"biconditional\" ( ` <-> ` , \"iff\" , \"if and only if\"), e.g. ~ sspwb . We sometimes suffix with \"s\" the label of an inference that manipulates an antecedent, leaving the consequent unchanged. The \"s\" means that the inference eliminates the need for a syllogism ( ~ syl ) -type inference in a proof. A theorem label is suffixed with \"ALT\" if it provides an alternate less-preferred proof of a theorem (e.g., the proof is clearer but uses more axioms than the preferred version). The \"ALT\" may be further suffixed with a number if there is more than one alternate theorem. Furthermore, a theorem label is suffixed with \"OLD\" if there is a new version of it and the OLD version is obsolete (and will be removed within one year). Finally, it should be mentioned that suffixes can be combined, for example in ~ cbvaldva ( ~ cbval in deduction form \"d\" with a not free variable replaced by a disjoint variable condition \"v\" with a conjunction as antecedent \"a\"). As a general rule, the suffixes for the theorem forms (\"i\", \"d\" or \"g\") should be the first of multiple suffixes, as for example in ~ vtocldf or ~ rabeqif . Here is a non-exhaustive list of common suffixes: <ul> <li> a : theorem having a conjunction as antecedent</li> <li> b : theorem expressing a logical equivalence</li> <li> c : contraction (e.g., ~ sylc , ~ syl2anc ), commutes (e.g., ~ biimpac )</li> <li> d : theorem in deduction form</li> <li> f : theorem with a hypothesis such as ` F/ x ph `</li> <li> g : theorem in closed form having an \"is a set\" antecedent</li> <li> i : theorem in inference form</li> <li> l : theorem concerning something at the left</li> <li> r : theorem concerning something at the right</li> <li> r : theorem with something reversed (e.g., a biconditional)</li> <li> s : inference that manipulates an antecedent (\"s\" refers to an application of ~ syl that is eliminated)</li> <li> v : theorem with one (main) disjoint variable condition</li> <li> vv : theorem with two (main) disjoint variable conditions</li> <li> w : weak(er) form of a theorem</li> <li> ALT : alternate proof of a theorem</li> <li> ALTV : alternate version of a theorem or definition</li> <li> OLD : old/obsolete version of a theorem/definition/proof</li> </ul> </li> <li><b>Reuse.</b> When creating a new theorem or axiom, try to reuse abbreviations used elsewhere. A comment should explain the first use of an abbreviation. </li> </ul> <p> The following table shows some commonly used abbreviations in labels, in alphabetical order. For each abbreviation we provide a mnenomic, the source theorem or the assumption defining it, an expression showing what it looks like, whether or not it is a \"syntax fragment\" (an abbreviation that indicates a particular kind of syntax), and hyperlinks to label examples that use the abbreviation. The abbreviation is bolded if there is a df-NAME definition but the label fragment is not NAME. This is <i>not</i> a complete list of abbreviations, though we do want this to eventually be a complete list of exceptions. <table border=\"1\" id=\"naming-abbreviation-table\"> <tr><th>Abbreviation</th><th>Mnenomic</th><th>Source</th> <th>Expression</th><th>Syntax?</th><th>Example(s)</th></tr> <tr><td>a</td><td>and (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ biimpa , ~ rexlimiva </td></tr> <tr><td>abl</td><td>Abelian group</td><td> ~ df-abl </td> <td> ` Abel ` </td><td>Yes</td><td> ~ ablgrp , ~ zringabl </td></tr> <tr><td>abs</td><td>absorption</td><td> </td> <td> </td><td>No</td> <td> ~ ressabs </td></tr> <tr><td>abs</td><td>absolute value (of a complex number)</td> <td> ~ df-abs </td><td> ` ( abs `` A ) ` </td><td>Yes</td> <td> ~ absval , ~ absneg , ~ abs1 </td></tr> <tr><td>ad</td><td>adding</td><td> </td> <td> </td><td>No</td><td> ~ adantr , ~ ad2antlr </td></tr> <tr><td>add</td><td>add (see \"p\")</td><td> ~ df-add </td> <td> ` ( A + B ) ` </td><td>Yes</td> <td> ~ addcl , ~ addcom , ~ addass </td></tr> <tr><td>al</td><td>\"for all\"</td><td> </td> <td> ` A. x ph ` </td><td>No</td><td> ~ alim , ~ alex </td></tr> <tr><td>ALT</td><td>alternative/less preferred (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ idALT </td></tr> <tr><td>an</td><td>and</td><td> ~ df-an </td> <td> ` ( ph /\\ ps ) ` </td><td>Yes</td> <td> ~ anor , ~ iman , ~ imnan </td></tr> <tr><td>ant</td><td>antecedent</td><td> </td> <td> </td><td>No</td><td> ~ adantr </td></tr> <tr><td>ass</td><td>associative</td><td> </td> <td> </td><td>No</td><td> ~ biass , ~ orass , ~ mulass </td></tr> <tr><td>asym</td><td>asymmetric, antisymmetric</td><td> </td> <td> </td><td>No</td><td> ~ intasym , ~ asymref , ~ posasymb </td></tr> <tr><td>ax</td><td>axiom</td><td> </td> <td> </td><td>No</td><td> ~ ax6dgen , ~ ax1cn </td></tr> <tr><td><b>bas</b>, base </td> <td>base (set of an extensible structure)</td><td> ~ df-base </td> <td> ` ( Base `` S ) ` </td><td>Yes</td> <td> ~ baseval , ~ ressbas , ~ cnfldbas </td></tr> <tr><td><b>b</b>, bi</td><td>biconditional (\"iff\", \"if and only if\") </td><td> ~ df-bi </td><td> ` ( ph <-> ps ) ` </td><td>Yes</td> <td> ~ impbid , ~ sspwb </td></tr> <tr><td>br</td><td>binary relation</td><td> ~ df-br </td> <td> ` A R B ` </td><td>Yes</td><td> ~ brab1 , ~ brun </td></tr> <tr><td>cbv</td><td>change bound variable</td><td> </td><td> </td> <td>No</td><td> ~ cbvalivw , ~ cbvrex </td></tr> <tr><td>cl</td><td>closure</td><td> </td><td> </td><td>No</td> <td> ~ ifclda , ~ ovrcl , ~ zaddcl </td></tr> <tr><td><b>cn</b></td><td>complex numbers</td><td> ~ df-c </td> <td> ` CC ` </td><td>Yes</td><td> ~ nnsscn , ~ nncn </td></tr> <tr><td>cnfld</td><td>field of complex numbers</td><td> ~ df-cnfld </td> <td> ` CCfld ` </td><td>Yes</td><td> ~ cnfldbas , ~ cnfldinv </td></tr> <tr><td>cntz</td><td>centralizer</td><td> ~ df-cntz </td> <td> ` ( Cntz `` M ) ` </td><td>Yes</td> <td> ~ cntzfval , ~ dprdfcntz </td></tr> <tr><td>cnv</td><td>converse</td><td> ~ df-cnv </td> <td> ` ``' A ` </td><td>Yes</td><td> ~ opelcnvg , ~ f1ocnv </td></tr> <tr><td>co</td><td>composition</td><td> ~ df-co </td> <td> ` ( A o. B ) ` </td><td>Yes</td><td> ~ cnvco , ~ fmptco </td></tr> <tr><td>com</td><td>commutative</td><td> </td> <td> </td><td>No</td><td> ~ orcom , ~ bicomi , ~ eqcomi </td></tr> <tr><td>con</td><td>contradiction, contraposition</td><td> </td> <td> </td><td>No</td><td> ~ condan , ~ con2d </td></tr> <tr><td>csb</td><td>class substitution</td><td> ~ df-csb </td> <td> ` [_ A / x ]_ B ` </td><td>Yes</td> <td> ~ csbid , ~ csbie2g </td></tr> <tr><td>cyg</td><td>cyclic group</td><td> ~ df-cyg </td> <td> ` CycGrp ` </td><td>Yes</td> <td> ~ iscyg , ~ zringcyg </td></tr> <tr><td>d</td><td>deduction form (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ idd , ~ impbid </td></tr> <tr><td>df</td><td>(alternate) definition (prefix)</td><td> </td> <td> </td><td>No</td><td> ~ dfrel2 , ~ dffn2 </td></tr> <tr><td>di, distr</td><td>distributive</td><td> </td> <td> </td><td>No</td> <td> ~ andi , ~ imdi , ~ ordi , ~ difindi , ~ ndmovdistr </td></tr> <tr><td>dif</td><td>class difference</td><td> ~ df-dif </td> <td> ` ( A \\ B ) ` </td><td>Yes</td> <td> ~ difss , ~ difindi </td></tr> <tr><td>div</td><td>division</td><td> ~ df-div </td> <td> ` ( A / B ) ` </td><td>Yes</td> <td> ~ divcl , ~ divval , ~ divmul </td></tr> <tr><td>dm</td><td>domain</td><td> ~ df-dm </td> <td> ` dom A ` </td><td>Yes</td><td> ~ dmmpt , ~ iswrddm0 </td></tr> <tr><td><b>e, eq, equ</b></td><td>equals</td><td> ~ df-cleq </td> <td> ` A = B ` </td><td>Yes</td> <td> ~ 2p2e4 , ~ uneqri , ~ equtr </td></tr> <tr><td>edg</td><td>edge</td><td> ~ df-edg </td> <td> ` ( Edg `` G ) ` </td><td>Yes</td> <td> ~ edgopval , ~ usgredgppr </td></tr> <tr><td>el</td><td>element of</td><td> </td> <td> ` A e. B ` </td><td>Yes</td> <td> ~ eldif , ~ eldifsn , ~ elssuni </td></tr> <tr><td>en</td><td>equinumerous</td><td> df-en </td> <td> ` A ~~ B ` </td><td>Yes</td><td> ~ domen , ~ enfi </td></tr> <tr><td>eu</td><td>\"there exists exactly one\"</td><td> ~ eu6 </td> <td> ` E! x ph ` </td><td>Yes</td><td> ~ euex , ~ euabsn </td></tr> <tr><td>ex</td><td>exists (i.e. is a set)</td><td> </td> <td> ` e. _V ` </td><td>No</td><td> ~ brrelex1 , ~ 0ex </td></tr> <tr><td>ex</td><td>\"there exists (at least one)\"</td><td> ~ df-ex </td> <td> ` E. x ph ` </td><td>Yes</td><td> ~ exim , ~ alex </td></tr> <tr><td>exp</td><td>export</td><td> </td> <td> </td><td>No</td><td> ~ expt , ~ expcom </td></tr> <tr><td>f</td><td>\"not free in\" (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ equs45f , ~ sbf </td></tr> <tr><td>f</td><td>function</td><td> ~ df-f </td> <td> ` F : A --> B ` </td><td>Yes</td><td> ~ fssxp , ~ opelf </td></tr> <tr><td>fal</td><td>false</td><td> ~ df-fal </td> <td> ` F. ` </td><td>Yes</td><td> ~ bifal , ~ falantru </td></tr> <tr><td>fi</td><td>finite intersection</td><td> ~ df-fi </td> <td> ` ( fi `` B ) ` </td><td>Yes</td><td> ~ fival , ~ inelfi </td></tr> <tr><td><b>fi</b>, fin</td><td>finite</td><td> ~ df-fin </td> <td> ` Fin ` </td><td>Yes</td> <td> ~ isfi , ~ snfi , ~ onfin </td></tr> <tr><td><b>fld</b></td><td>field (Note: there is an alternative definition ` Fld ` of a field, see ~ df-fld )</td><td> ~ df-field </td> <td> ` Field ` </td><td>Yes</td><td> ~ isfld , ~ fldidom </td></tr> <tr><td>fn</td><td>function with domain</td><td> ~ df-fn </td> <td> ` A Fn B ` </td><td>Yes</td><td> ~ ffn , ~ fndm </td></tr> <tr><td>frgp</td><td>free group</td><td> ~ df-frgp </td> <td> ` ( freeGrp `` I ) ` </td><td>Yes</td> <td> ~ frgpval , ~ frgpadd </td></tr> <tr><td>fsupp</td><td>finitely supported function</td> <td> ~ df-fsupp </td><td> ` R finSupp Z ` </td><td>Yes</td> <td> ~ isfsupp , ~ fdmfisuppfi , ~ fsuppco </td></tr> <tr><td>fun</td><td>function</td><td> ~ df-fun </td> <td> ` Fun F ` </td><td>Yes</td><td> ~ funrel , ~ ffun </td></tr> <tr><td>fv</td><td>function value</td><td> ~ df-fv </td> <td> ` ( F `` A ) ` </td><td>Yes</td><td> ~ fvres , ~ swrdfv </td></tr> <tr><td>fz</td><td>finite set of sequential integers</td> <td> ~ df-fz </td> <td> ` ( M ... N ) ` </td><td>Yes</td><td> ~ fzval , ~ eluzfz </td></tr> <tr><td>fz0</td><td>finite set of sequential nonnegative integers</td> <td> </td> <td> ` ( 0 ... N ) ` </td><td>Yes</td><td> ~ nn0fz0 , ~ fz0tp </td></tr> <tr><td>fzo</td><td>half-open integer range</td><td> ~ df-fzo </td> <td> ` ( M ..^ N ) ` </td><td>Yes</td> <td> ~ elfzo , ~ elfzofz </td></tr> <tr><td>g</td><td>more general (suffix); eliminates \"is a set\" hypotheses</td><td> </td> <td> </td><td>No</td><td> ~ uniexg </td></tr> <tr><td>gr</td><td>graph</td><td> </td> <td> </td><td>No</td><td> ~ uhgrf , ~ isumgr , ~ usgrres1 </td></tr> <tr><td>grp</td><td>group</td><td> ~ df-grp </td> <td> ` Grp ` </td><td>Yes</td><td> ~ isgrp , ~ tgpgrp </td></tr> <tr><td>gsum</td><td>group sum</td><td> ~ df-gsum </td> <td> ` ( G gsum F ) ` </td><td>Yes</td> <td> ~ gsumval , ~ gsumwrev </td></tr> <tr><td>hash</td><td>size (of a set)</td><td> ~ df-hash </td> <td> ` ( # `` A ) ` </td><td>Yes</td> <td> ~ hashgval , ~ hashfz1 , ~ hashcl </td></tr> <tr><td>hb</td><td>hypothesis builder (prefix)</td><td> </td> <td> </td><td>No</td><td> ~ hbxfrbi , ~ hbald , ~ hbequid </td></tr> <tr><td>hm</td><td>(monoid, group, ring) homomorphism</td><td> </td> <td> </td><td>No</td><td> ~ ismhm , ~ isghm , ~ isrhm </td></tr> <tr><td>i</td><td>inference (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ eleq1i , ~ tcsni </td></tr> <tr><td>i</td><td>implication (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ brwdomi , ~ infeq5i </td></tr> <tr><td>id</td><td>identity</td><td> </td> <td> </td><td>No</td><td> ~ biid </td></tr> <tr><td>iedg</td><td>indexed edge</td><td> ~ df-iedg </td> <td> ` ( iEdg `` G ) ` </td><td>Yes</td> <td> ~ iedgval0 , ~ edgiedgb </td></tr> <tr><td>idm</td><td>idempotent</td><td> </td> <td> </td><td>No</td><td> ~ anidm , ~ tpidm13 </td></tr> <tr><td>im, <b>imp</b></td><td>implication (label often omitted)</td> <td> ~ df-im </td><td> ` ( A -> B ) ` </td><td>Yes</td> <td> ~ iman , ~ imnan , ~ impbidd </td></tr> <tr><td>ima</td><td>image</td><td> ~ df-ima </td> <td> ` ( A \" B ) ` </td><td>Yes</td><td> ~ resima , ~ imaundi </td></tr> <tr><td>imp</td><td>import</td><td> </td> <td> </td><td>No</td><td> ~ biimpa , ~ impcom </td></tr> <tr><td>in</td><td>intersection</td><td> ~ df-in </td> <td> ` ( A i^i B ) ` </td><td>Yes</td><td> ~ elin , ~ incom </td></tr> <tr><td>inf</td><td>infimum</td><td> ~ df-inf </td> <td> ` inf ( RR+ , RR* , < ) ` </td><td>Yes</td> <td> ~ fiinfcl , ~ infiso </td></tr> <tr><td>is...</td><td>is (something a) ...?</td><td> </td> <td> </td><td>No</td><td> ~ isring </td></tr> <tr><td>j</td><td>joining, disjoining</td><td> </td> <td> </td><td>No</td><td> ~ jc , ~ jaoi </td></tr> <tr><td>l</td><td>left</td><td> </td> <td> </td><td>No</td><td> ~ olcd , ~ simpl </td></tr> <tr><td>map</td><td>mapping operation or set exponentiation</td> <td> ~ df-map </td><td> ` ( A ^m B ) ` </td><td>Yes</td> <td> ~ mapvalg , ~ elmapex </td></tr> <tr><td>mat</td><td>matrix</td><td> ~ df-mat </td> <td> ` ( N Mat R ) ` </td><td>Yes</td> <td> ~ matval , ~ matring </td></tr> <tr><td>mdet</td><td>determinant (of a square matrix)</td> <td> ~ df-mdet </td><td> ` ( N maDet R ) ` </td><td>Yes</td> <td> ~ mdetleib , ~ mdetrlin </td></tr> <tr><td>mgm</td><td>magma</td><td> ~ df-mgm </td> <td> ` Magma ` </td><td>Yes</td> <td> ~ mgmidmo , ~ mgmlrid , ~ ismgm </td></tr> <tr><td>mgp</td><td>multiplicative group</td><td> ~ df-mgp </td> <td> ` ( mulGrp `` R ) ` </td><td>Yes</td> <td> ~ mgpress , ~ ringmgp </td></tr> <tr><td>mnd</td><td>monoid</td><td> ~ df-mnd </td> <td> ` Mnd ` </td><td>Yes</td><td> ~ mndass , ~ mndodcong </td></tr> <tr><td>mo</td><td>\"there exists at most one\"</td><td> ~ df-mo </td> <td> ` E* x ph ` </td><td>Yes</td><td> ~ eumo , ~ moim </td></tr> <tr><td>mp</td><td>modus ponens</td><td> ~ ax-mp </td> <td> </td><td>No</td><td> ~ mpd , ~ mpi </td></tr> <tr><td>mpo</td><td>maps-to notation for an operation</td> <td> ~ df-mpo </td><td> ` ( x e. A , y e. B |-> C ) ` </td><td>Yes</td> <td></td></tr> <tr><td>mpt</td><td>modus ponendo tollens</td><td></td> <td> </td><td>No</td><td> ~ mptnan , ~ mptxor </td></tr> <tr><td>mpt</td><td>maps-to notation for a function</td> <td> ~ df-mpt </td><td> ` ( x e. A |-> B ) ` </td><td>Yes</td> <td> ~ fconstmpt , ~ resmpt </td></tr> <tr><td>mpt2</td><td>maps-to notation for an operation (deprecated). We are in the process of replacing mpt2 with mpo in labels.</td> <td> ~ df-mpo </td><td> ` ( x e. A , y e. B |-> C ) ` </td><td>Yes</td> <td> ~ mpt2mpt , ~ resmpt2 </td></tr> <tr><td>mul</td><td>multiplication (see \"t\")</td><td> ~ df-mul </td> <td> ` ( A x. B ) ` </td><td>Yes</td> <td> ~ mulcl , ~ divmul , ~ mulcom , ~ mulass </td></tr> <tr><td>n, not</td><td>not</td><td> </td> <td> ` -. ph ` </td><td>Yes</td> <td> ~ nan , ~ notnotr </td></tr> <tr><td>ne</td><td>not equal</td><td>df-ne</td><td> ` A =/= B ` </td> <td>Yes</td><td> ~ exmidne , ~ neeqtrd </td></tr> <tr><td>nel</td><td>not element of</td><td>df-nel</td><td> ` A e/ B ` </td> <td>Yes</td><td> ~ neli , ~ nnel </td></tr> <tr><td>ne0</td><td>not equal to zero (see n0)</td><td></td> <td> ` =/= 0 ` </td><td>No</td> <td> ~ negne0d , ~ ine0 , ~ gt0ne0 </td></tr> <tr><td>nf</td><td> \"not free in\" (prefix)</td><td> </td> <td> </td><td>No</td><td> ~ nfnd </td></tr> <tr><td>ngp</td><td>normed group</td><td> ~ df-ngp </td> <td> ` NrmGrp ` </td><td>Yes</td><td> ~ isngp , ~ ngptps </td></tr> <tr><td>nm</td><td>norm (on a group or ring)</td><td> ~ df-nm </td> <td> ` ( norm `` W ) ` </td><td>Yes</td> <td> ~ nmval , ~ subgnm </td></tr> <tr><td>nn</td><td>positive integers</td><td> ~ df-nn </td> <td> ` NN ` </td><td>Yes</td><td> ~ nnsscn , ~ nncn </td></tr> <tr><td><b>nn0</b></td><td>nonnegative integers</td><td> ~ df-n0 </td> <td> ` NN0 ` </td><td>Yes</td><td> ~ nnnn0 , ~ nn0cn </td></tr> <tr><td>n0</td><td>not the empty set (see ne0)</td><td></td> <td> ` =/= (/) ` </td><td>No</td><td> ~ n0i , ~ vn0 , ~ ssn0 </td></tr> <tr><td>OLD</td><td>old, obsolete (to be removed soon)</td><td> </td> <td> </td><td>No</td><td> ~ 19.43OLD </td></tr> <tr><td>on</td><td>ordinal number</td><td> ~ df-on </td> <td> ` A e. On ` </td><td>Yes</td> <td> ~ elon , ~ 1on ~ onelon </td></tr> <tr><td>op</td><td>ordered pair</td><td> ~ df-op </td> <td> ` <. A , B >. ` </td><td>Yes</td><td> ~ dfopif , ~ opth </td></tr> <tr><td>or</td><td>or</td><td> ~ df-or </td> <td> ` ( ph \\/ ps ) ` </td><td>Yes</td> <td> ~ orcom , ~ anor </td></tr> <tr><td>ot</td><td>ordered triple</td><td> ~ df-ot </td> <td> ` <. A , B , C >. ` </td><td>Yes</td> <td> ~ euotd , ~ fnotovb </td></tr> <tr><td>ov</td><td>operation value</td><td> ~ df-ov </td> <td> ` ( A F B ) ` </td><td>Yes </td><td> ~ fnotovb , ~ fnovrn </td></tr> <tr><td><b>p</b></td><td>plus (see \"add\"), for all-constant theorems</td><td> ~ df-add </td> <td> ` ( 3 + 2 ) = 5 ` </td><td>Yes</td> <td> ~ 3p2e5 </td></tr> <tr><td>pfx</td><td>prefix</td><td> ~ df-pfx </td> <td> ` ( W prefix L ) ` </td><td>Yes</td> <td> ~ pfxlen , ~ ccatpfx </td></tr> <tr><td>pm</td><td>Principia Mathematica</td><td> </td> <td> </td><td>No</td><td> ~ pm2.27 </td></tr> <tr><td>pm</td><td>partial mapping (operation)</td><td> ~ df-pm </td> <td> ` ( A ^pm B ) ` </td><td>Yes</td><td> ~ elpmi , ~ pmsspw </td></tr> <tr><td>pr</td><td>pair</td><td> ~ df-pr </td> <td> ` { A , B } ` </td><td>Yes</td> <td> ~ elpr , ~ prcom , ~ prid1g , ~ prnz </td></tr> <tr><td>prm, <b>prime</b></td><td>prime (number)</td><td> ~ df-prm </td> <td> ` Prime ` </td><td>Yes</td><td> ~ 1nprm , ~ dvdsprime </td></tr> <tr><td>pss</td><td>proper subset</td><td> ~ df-pss </td> <td> ` A C. B ` </td><td>Yes</td><td> ~ pssss , ~ sspsstri </td></tr> <tr><td>q</td><td> rational numbers (\"quotients\")</td><td> ~ df-q </td> <td> ` QQ ` </td><td>Yes</td><td> ~ elq </td></tr> <tr><td>r</td><td>right</td><td> </td> <td> </td><td>No</td><td> ~ orcd , ~ simprl </td></tr> <tr><td>rab</td><td>restricted class abstraction</td> <td> ~ df-rab </td><td> ` { x e. A | ph } ` </td><td>Yes</td> <td> ~ rabswap , ~ df-oprab </td></tr> <tr><td>ral</td><td>restricted universal quantification</td> <td> ~ df-ral </td><td> ` A. x e. A ph ` </td><td>Yes</td> <td> ~ ralnex , ~ ralrnmpt2 </td></tr> <tr><td>rcl</td><td>reverse closure</td><td> </td> <td> </td><td>No</td><td> ~ ndmfvrcl , ~ nnarcl </td></tr> <tr><td><b>re</b></td><td>real numbers</td><td> ~ df-r </td> <td> ` RR ` </td><td>Yes</td><td> ~ recn , ~ 0re </td></tr> <tr><td>rel</td><td>relation</td><td> ~ df-rel </td><td> ` Rel A ` </td> <td>Yes</td><td> ~ brrelex1 , ~ relmpt2opab </td></tr> <tr><td>res</td><td>restriction</td><td> ~ df-res </td> <td> ` ( A |`` B ) ` </td><td>Yes</td> <td> ~ opelres , ~ f1ores </td></tr> <tr><td>reu</td><td>restricted existential uniqueness</td> <td> ~ df-reu </td><td> ` E! x e. A ph ` </td><td>Yes</td> <td> ~ nfreud , ~ reurex </td></tr> <tr><td>rex</td><td>restricted existential quantification</td> <td> ~ df-rex </td><td> ` E. x e. A ph ` </td><td>Yes</td> <td> ~ rexnal , ~ rexrnmpt2 </td></tr> <tr><td>rmo</td><td>restricted \"at most one\"</td> <td> ~ df-rmo </td><td> ` E* x e. A ph ` </td><td>Yes</td> <td> ~ nfrmod , ~ nrexrmo </td></tr> <tr><td>rn</td><td>range</td><td> ~ df-rn </td><td> ` ran A ` </td> <td>Yes</td><td> ~ elrng , ~ rncnvcnv </td></tr> <tr><td>rng</td><td>(unital) ring</td><td> ~ df-ring </td> <td> ` Ring ` </td><td>Yes</td> <td> ~ ringidval , ~ isring , ~ ringgrp </td></tr> <tr><td>rot</td><td>rotation</td><td> </td> <td> </td><td>No</td><td> ~ 3anrot , ~ 3orrot </td></tr> <tr><td>s</td><td>eliminates need for syllogism (suffix)</td> <td> </td> <td> </td><td>No</td><td> ~ ancoms </td></tr> <tr><td>sb</td><td>(proper) substitution (of a set)</td> <td> ~ df-sb </td><td> ` [ y / x ] ph ` </td><td>Yes</td> <td> ~ spsbe , ~ sbimi </td></tr> <tr><td>sbc</td><td>(proper) substitution of a class</td> <td> ~ df-sbc </td><td> ` [. A / x ]. ph ` </td><td>Yes</td> <td> ~ sbc2or , ~ sbcth </td></tr> <tr><td>sca</td><td>scalar</td><td> ~ df-sca </td> <td> ` ( Scalar `` H ) ` </td><td>Yes</td> <td> ~ resssca , ~ mgpsca </td></tr> <tr><td>simp</td><td>simple, simplification</td><td> </td> <td> </td><td>No</td><td> ~ simpl , ~ simp3r3 </td></tr> <tr><td>sn</td><td>singleton</td><td> ~ df-sn </td> <td> ` { A } ` </td><td>Yes</td><td> ~ eldifsn </td></tr> <tr><td>sp</td><td>specialization</td><td> </td> <td> </td><td>No</td><td> ~ spsbe , ~ spei </td></tr> <tr><td>ss</td><td>subset</td><td> ~ df-ss </td> <td> ` A C_ B ` </td><td>Yes</td><td> ~ difss </td></tr> <tr><td>struct</td><td>structure</td><td> ~ df-struct </td> <td> ` Struct ` </td><td>Yes</td><td> ~ brstruct , ~ structfn </td></tr> <tr><td>sub</td><td>subtract</td><td> ~ df-sub </td> <td> ` ( A - B ) ` </td><td>Yes</td> <td> ~ subval , ~ subaddi </td></tr> <tr><td>sup</td><td>supremum</td><td> ~ df-sup </td> <td> ` sup ( A , B , < ) ` </td><td>Yes</td> <td> ~ fisupcl , ~ supmo </td></tr> <tr><td>supp</td><td>support (of a function)</td><td> ~ df-supp </td> <td> ` ( F supp Z ) ` </td><td>Yes</td> <td> ~ ressuppfi , ~ mptsuppd </td></tr> <tr><td>swap</td><td>swap (two parts within a theorem)</td> <td> </td><td> </td><td>No</td><td> ~ rabswap , ~ 2reuswap </td></tr> <tr><td>syl</td><td>syllogism</td><td> ~ syl </td> <td> </td><td>No</td><td> ~ 3syl </td></tr> <tr><td>sym</td><td>symmetric</td><td> </td> <td> </td><td>No</td><td> ~ df-symdif , ~ cnvsym </td></tr> <tr><td>symg</td><td>symmetric group</td><td> ~ df-symg </td> <td> ` ( SymGrp `` A ) ` </td><td>Yes</td> <td> ~ symghash , ~ pgrpsubgsymg </td></tr> <tr><td><b>t</b></td> <td>times (see \"mul\"), for all-constant theorems</td> <td> ~ df-mul </td> <td> ` ( 3 x. 2 ) = 6 ` </td><td>Yes</td> <td> ~ 3t2e6 </td></tr> <tr><td>th</td><td>theorem</td><td> </td> <td> </td><td>No</td><td> ~ nfth , ~ sbcth , ~ weth </td></tr> <tr><td>tp</td><td>triple</td><td> ~ df-tp </td> <td> ` { A , B , C } ` </td><td>Yes</td> <td> ~ eltpi , ~ tpeq1 </td></tr> <tr><td>tr</td><td>transitive</td><td> </td> <td> </td><td>No</td><td> ~ bitrd , ~ biantr </td></tr> <tr><td>tru</td><td>true</td><td> ~ df-tru </td> <td> ` T. ` </td><td>Yes</td><td> ~ bitru , ~ truanfal </td></tr> <tr><td>un</td><td>union</td><td> ~ df-un </td> <td> ` ( A u. B ) ` </td><td>Yes</td> <td> ~ uneqri , ~ uncom </td></tr> <tr><td>unit</td><td>unit (in a ring)</td> <td> ~ df-unit </td><td> ` ( Unit `` R ) ` </td><td>Yes</td> <td> ~ isunit , ~ nzrunit </td></tr> <tr><td>v</td><td>disjoint variable conditions used when a not-free hypothesis (suffix)</td> <td> </td> <td> </td><td>No</td><td> ~ spimv </td></tr> <tr><td>vtx</td><td>vertex</td><td> ~ df-vtx </td> <td> ` ( Vtx `` G ) ` </td><td>Yes</td> <td> ~ vtxval0 , ~ opvtxov </td></tr> <tr><td>vv</td><td>2 disjoint variables (in a not-free hypothesis) (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ 19.23vv </td></tr> <tr><td>w</td><td>weak (version of a theorem) (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ ax11w , ~ spnfw </td></tr> <tr><td><b>wrd</b></td><td>word</td> <td> ~ df-word </td><td> ` Word S ` </td><td>Yes</td> <td> ~ iswrdb , ~ wrdfn , ~ ffz0iswrd </td></tr> <tr><td>xp</td><td>cross product (Cartesian product)</td> <td> ~ df-xp </td><td> ` ( A X. B ) ` </td><td>Yes</td> <td> ~ elxp , ~ opelxpi , ~ xpundi </td></tr> <tr><td>xr</td><td>eXtended reals</td><td> ~ df-xr </td> <td> ` RR* ` </td><td>Yes</td><td> ~ ressxr , ~ rexr , ~ 0xr </td></tr> <tr><td>z</td><td> integers (from German \"Zahlen\")</td> <td> ~ df-z </td><td> ` ZZ ` </td><td>Yes</td> <td> ~ elz , ~ zcn </td></tr> <tr><td>zn</td><td> ring of integers ` mod N ` </td><td> ~ df-zn </td> <td> ` ( Z/nZ `` N ) ` </td><td>Yes</td> <td> ~ znval , ~ zncrng , ~ znhash </td></tr> <tr><td>zring</td><td>ring of integers</td><td> ~ df-zring </td> <td> ` ZZring ` </td><td>Yes</td><td> ~ zringbas , ~ zringcrng </td></tr> <tr><td><b>0, z</b></td> <td>slashed zero (empty set)</td><td> ~ df-nul </td> <td> ` (/) ` </td><td>Yes</td> <td> ~ n0i , ~ vn0 ; ~ snnz , ~ prnz </td></tr> </table> </p> </HTML> (Contributed by the Metamath team, 27-Dec-2016.) Date of last revision. (Revised by the Metamath team, 22-Sep-2022.) (Proof modification is discouraged.) (New usage is discouraged.)","parent":["idi"],"children":[]}