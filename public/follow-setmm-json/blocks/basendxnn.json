{"bIdx":17546,"bType":"thm","type":"","name":"basendxnn","params":"","body":["|- wcel(cfv(cbs, cnx), cn)"],"bodyPretty":["⊢ (Base ` ndx)∈ ℕ"],"proof":[{"stmt":{"origin":"eqeltri(cfv(cbs, cnx), cn, nat1)","pretty":"eqeltri((Base ` ndx), cn, nat1)"},"body":{"origin":"|- wcel(cfv(cbs, cnx), cn)\n-| wceq(cfv(cbs, cnx), nat1)\n-| wcel(nat1, cn)","pretty":"⊢ (Base ` ndx)∈ ℕ\n⊣ (Base ` ndx)= 1\n⊣ 1 ∈ ℕ"},"cumulated":{"origin":"|- wcel(cfv(cbs, cnx), cn)\n-| wceq(cfv(cbs, cnx), nat1)\n-| wcel(nat1, cn)","pretty":"⊢ (Base ` ndx)∈ ℕ\n⊣ (Base ` ndx)= 1\n⊣ 1 ∈ ℕ"}},{"stmt":{"origin":"ndxarg(cbs, nat1)","pretty":"ndxarg(cbs, nat1)"},"body":{"origin":"|- wceq(cfv(cbs, cnx), nat1)\n-| wceq(cbs, cslot(nat1))\n-| wcel(nat1, cn)","pretty":"⊢ (Base ` ndx)= 1\n⊣ Base = Slot(1)\n⊣ 1 ∈ ℕ"},"cumulated":{"origin":"|- wcel(cfv(cbs, cnx), cn)\n-| wcel(nat1, cn)\n-| wceq(cbs, cslot(nat1))","pretty":"⊢ (Base ` ndx)∈ ℕ\n⊣ 1 ∈ ℕ\n⊣ Base = Slot(1)"}},{"stmt":{"origin":"df-base()","pretty":"df-base()"},"body":{"origin":"|- wceq(cbs, cslot(nat1))","pretty":"⊢ Base = Slot(1)"},"cumulated":{"origin":"|- wcel(cfv(cbs, cnx), cn)\n-| wcel(nat1, cn)","pretty":"⊢ (Base ` ndx)∈ ℕ\n⊣ 1 ∈ ℕ"}},{"stmt":{"origin":"1nn()","pretty":"1nn()"},"body":{"origin":"|- wcel(nat1, cn)","pretty":"⊢ 1 ∈ ℕ"},"cumulated":{"origin":"|- wcel(cfv(cbs, cnx), cn)","pretty":"⊢ (Base ` ndx)∈ ℕ"}}],"comment":"The index value of the base set extractor is a positive integer. This property should be ensured for every concrete coding because otherwise it could not be used in an extensible structure (slots must be positive integers). (Contributed by AV, 23-Sep-2020.)","parent":["eqeltri","ndxarg","df-base","1nn"],"children":["slotsbaseefdif","structvtxvallem"]}