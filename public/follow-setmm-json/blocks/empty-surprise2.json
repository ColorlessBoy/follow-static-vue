{"bIdx":48319,"bType":"thm","type":"","name":"empty-surprise2","params":"setvar s0, class c0","body":["|- wral(s0, c0, wfal)","-| wn(wex(s0, wcel(cv(s0), c0)))"],"bodyPretty":["⊢ ∀(s0 ∈ c0, F)","⊣ ¬ ∃(s0, s0 ∈ c0)"],"proof":[{"stmt":{"origin":"empty-surprise(s0, c0, wfal)","pretty":"empty-surprise(s0, c0, wfal)"},"body":{"origin":"|- wral(s0, c0, wfal)\n-| wn(wex(s0, wcel(cv(s0), c0)))","pretty":"⊢ ∀(s0 ∈ c0, F)\n⊣ ¬ ∃(s0, s0 ∈ c0)"},"cumulated":{"origin":"|- wral(s0, c0, wfal)\n-| wn(wex(s0, wcel(cv(s0), c0)))","pretty":"⊢ ∀(s0 ∈ c0, F)\n⊣ ¬ ∃(s0, s0 ∈ c0)"}}],"comment":"\"Prove\" that false is true when using a restricted \"for all\" over the empty set, to demonstrate that the expression is always true if the value ranges over the empty set. Those inexperienced with formal notations of classical logic can be surprised with what restricted \"for all\" does over an empty set. We proved the general case in ~ empty-surprise . Here we prove an extreme example: we \"prove\" that false is true. Of course, we actually do no such thing (see ~ notfal ); the problem is that restricted \"for all\" works in ways that might seem counterintuitive to the inexperienced when given an empty set. Solutions to this can include requiring that the set not be empty or by using the allsome quantifier ~ df-alsc . (Contributed by David A. Wheeler, 20-Oct-2018.)","parent":["empty-surprise"],"children":[]}