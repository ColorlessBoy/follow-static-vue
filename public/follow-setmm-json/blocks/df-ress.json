{"bIdx":17489,"bType":"axiom","type":"","name":"df-ress","params":"setvar s0, setvar s1","body":["|- wceq(cress, cmpo(s0, s1, universe, universe, cif(cv(s0), co(cv(s0), csts, cop(cfv(cbs, cnx), cin(cv(s1), cfv(cbs, cv(s0))))), wss(cfv(cbs, cv(s0)), cv(s1)))))","-| diffss(s0, s1)"],"bodyPretty":["âŠ¢ |`s =(s0 âˆˆ ğ•Œ, s1 âˆˆ ğ•Œ â†¦ if((Base ` s0)âŠ† s1, s0,(s0[sSet]<(Base ` ndx),(s1 â‹‚(Base ` s0))>)))","âŠ£ d(s0, s1)"],"proof":[],"comment":"Define a multifunction restriction operator for extensible structures, which can be used to turn statements about rings into statements about subrings, modules into submodules, etc. This definition knows nothing about individual structures and merely truncates the ` Base ` set while leaving operators alone; individual kinds of structures will need to handle this behavior, by ignoring operators' values outside the range (like ` Ring ` ), defining a function using the base set and applying that (like ` TopGrp ` ), or explicitly truncating the slot before use (like ` MetSp ` ). (Credit for this operator goes to Mario Carneiro.) See ~ ressbas for the altered base set, and ~ resslem ( ~ subrg0 , ~ ressplusg , ~ subrg1 , ~ ressmulr ) for the (un)altered other operations. (Contributed by Stefan O'Rear, 29-Nov-2014.)","parent":[],"children":["reldmress","ressval"]}