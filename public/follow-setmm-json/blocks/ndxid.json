{"bIdx":17507,"bType":"thm","type":"","name":"ndxid","params":"class c0, class c1","body":["|- wceq(c0, cslot(cfv(c0, cnx)))","-| wceq(c0, cslot(c1))","-| wcel(c1, cn)"],"bodyPretty":["⊢ c0 = Slot((c0 ` ndx))","⊣ c0 = Slot(c1)","⊣ c1 ∈ ℕ"],"proof":[{"stmt":{"origin":"ax-mp(wceq(c0, cslot(cfv(c0, cnx))), wceq(c1, cfv(c0, cnx)))","pretty":"ax-mp(c0 = Slot((c0 ` ndx)), c1 =(c0 ` ndx))"},"body":{"origin":"|- wceq(c0, cslot(cfv(c0, cnx)))\n-| wceq(c1, cfv(c0, cnx))\n-| wi(wceq(c1, cfv(c0, cnx)), wceq(c0, cslot(cfv(c0, cnx))))","pretty":"⊢ c0 = Slot((c0 ` ndx))\n⊣ c1 =(c0 ` ndx)\n⊣ (c1 =(c0 ` ndx)→ c0 = Slot((c0 ` ndx)))"},"cumulated":{"origin":"|- wceq(c0, cslot(cfv(c0, cnx)))\n-| wceq(c1, cfv(c0, cnx))\n-| wi(wceq(c1, cfv(c0, cnx)), wceq(c0, cslot(cfv(c0, cnx))))","pretty":"⊢ c0 = Slot((c0 ` ndx))\n⊣ c1 =(c0 ` ndx)\n⊣ (c1 =(c0 ` ndx)→ c0 = Slot((c0 ` ndx)))"}},{"stmt":{"origin":"eqcomi(c1, cfv(c0, cnx))","pretty":"eqcomi(c1, (c0 ` ndx))"},"body":{"origin":"|- wceq(c1, cfv(c0, cnx))\n-| wceq(cfv(c0, cnx), c1)","pretty":"⊢ c1 =(c0 ` ndx)\n⊣ (c0 ` ndx)= c1"},"cumulated":{"origin":"|- wceq(c0, cslot(cfv(c0, cnx)))\n-| wi(wceq(c1, cfv(c0, cnx)), wceq(c0, cslot(cfv(c0, cnx))))\n-| wceq(cfv(c0, cnx), c1)","pretty":"⊢ c0 = Slot((c0 ` ndx))\n⊣ (c1 =(c0 ` ndx)→ c0 = Slot((c0 ` ndx)))\n⊣ (c0 ` ndx)= c1"}},{"stmt":{"origin":"ndxarg(c0, c1)","pretty":"ndxarg(c0, c1)"},"body":{"origin":"|- wceq(cfv(c0, cnx), c1)\n-| wceq(c0, cslot(c1))\n-| wcel(c1, cn)","pretty":"⊢ (c0 ` ndx)= c1\n⊣ c0 = Slot(c1)\n⊣ c1 ∈ ℕ"},"cumulated":{"origin":"|- wceq(c0, cslot(cfv(c0, cnx)))\n-| wi(wceq(c1, cfv(c0, cnx)), wceq(c0, cslot(cfv(c0, cnx))))\n-| wceq(c0, cslot(c1))\n-| wcel(c1, cn)","pretty":"⊢ c0 = Slot((c0 ` ndx))\n⊣ (c1 =(c0 ` ndx)→ c0 = Slot((c0 ` ndx)))\n⊣ c0 = Slot(c1)\n⊣ c1 ∈ ℕ"}},{"stmt":{"origin":"syl5eq(c0, cslot(cfv(c0, cnx)), cslot(c1), wceq(c1, cfv(c0, cnx)))","pretty":"syl5eq(c0, Slot((c0 ` ndx)), Slot(c1), c1 =(c0 ` ndx))"},"body":{"origin":"|- wi(wceq(c1, cfv(c0, cnx)), wceq(c0, cslot(cfv(c0, cnx))))\n-| wceq(c0, cslot(c1))\n-| wi(wceq(c1, cfv(c0, cnx)), wceq(cslot(c1), cslot(cfv(c0, cnx))))","pretty":"⊢ (c1 =(c0 ` ndx)→ c0 = Slot((c0 ` ndx)))\n⊣ c0 = Slot(c1)\n⊣ (c1 =(c0 ` ndx)→ Slot(c1)= Slot((c0 ` ndx)))"},"cumulated":{"origin":"|- wceq(c0, cslot(cfv(c0, cnx)))\n-| wceq(c0, cslot(c1))\n-| wcel(c1, cn)\n-| wi(wceq(c1, cfv(c0, cnx)), wceq(cslot(c1), cslot(cfv(c0, cnx))))","pretty":"⊢ c0 = Slot((c0 ` ndx))\n⊣ c0 = Slot(c1)\n⊣ c1 ∈ ℕ\n⊣ (c1 =(c0 ` ndx)→ Slot(c1)= Slot((c0 ` ndx)))"}},{"stmt":{"origin":"sloteq(c1, cfv(c0, cnx))","pretty":"sloteq(c1, (c0 ` ndx))"},"body":{"origin":"|- wi(wceq(c1, cfv(c0, cnx)), wceq(cslot(c1), cslot(cfv(c0, cnx))))","pretty":"⊢ (c1 =(c0 ` ndx)→ Slot(c1)= Slot((c0 ` ndx)))"},"cumulated":{"origin":"|- wceq(c0, cslot(cfv(c0, cnx)))\n-| wceq(c0, cslot(c1))\n-| wcel(c1, cn)","pretty":"⊢ c0 = Slot((c0 ` ndx))\n⊣ c0 = Slot(c1)\n⊣ c1 ∈ ℕ"}}],"comment":"A structure component extractor is defined by its own index. This theorem, together with ~ strfv below, is useful for avoiding direct reference to the hard-coded numeric index in component extractor definitions, such as the ` 1 ` in ~ df-base and the ` ; 1 0 ` in ~ df-ple , making it easier to change should the need arise. For example, we can refer to a specific poset with base set ` B ` and order relation ` L ` using ` { <. ( Base `` ndx ) , B >. , ` ` <. ( le `` ndx ) , L >. } ` rather than ` { <. 1 , B >. , ` ` <. ; 1 0 , L >. } ` . The latter, while shorter to state, requires revision if we later change ` ; 1 0 ` to some other number, and it may also be harder to remember. (Contributed by NM, 19-Oct-2012.) (Revised by Mario Carneiro, 6-Oct-2013.) (Proof shortened by BJ, 27-Dec-2021.)","parent":["ax-mp","eqcomi","ndxarg","syl5eq","sloteq"],"children":["strndxid","setsidvald","baseid","resslem","plusgid","2strop","2strop1","mulrid","starvid","scaid","vscaid","ipid","tsetid","pleid","ocid","dsid","unifid","homid","ccoid","oppglem","mgplem","opprlem","sralem","opsrbaslem","zlmlem","znbaslem","tnglem","itvid","lngid","ttglem","cchhllem","edgfid","resvlem","hlhilslem"]}