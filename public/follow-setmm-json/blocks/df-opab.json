{"bIdx":5390,"bType":"axiom","type":"","name":"df-opab","params":"setvar s0, setvar s1, setvar s2, wff w0","body":["|- wceq(copab(s0, s1, w0), cab(s2, wex(s0, wex(s1, wa(wceq(cv(s2), cop(cv(s0), cv(s1))), w0)))))","-| diffss(s0, s2)","-| diffss(s1, s2)","-| diffsw(s2, w0)"],"bodyPretty":["⊢ { < s0, s1 > | w0 } = { s2 | ∃(s0, ∃(s1,(s2 = < s0, s1 > ∧ w0)))}","⊣ d(s0, s2)","⊣ d(s1, s2)","⊣ d(s2, w0)"],"proof":[],"comment":"Define the class abstraction of a collection of ordered pairs. Definition 3.3 of [Monk1] p. 34. Usually ` x ` and ` y ` are distinct, although the definition doesn't strictly require it (see ~ dfid2 for a case where they are not distinct). The brace notation is called \"class abstraction\" by Quine; it is also (more commonly) called a \"class builder\" in the literature. An alternate definition using no existential quantifiers is shown by ~ dfopab2 . For example, ` R = { <. x , y >. | ( x e. CC /\\ y e. CC /\\ ( x + 1 ) = y ) } ` ` -> 3 R 4 ` ( ~ ex-opab ). (Contributed by NM, 4-Jul-1994.)","parent":[],"children":["opabss","opabbid","nfopab","nfopab1","nfopab2","cbvopab","cbvopab1","cbvopab2","cbvopab1s","cbvopab2v","unopab","opabid","elopab","ssopab2","iunopab","dfid3","elxpi","rabxp","csbxp","ssrel","relopabi","relopabiALT","opabssxpd","cnv0","dfoprab2","dmoprab","dfopab2","brdom7disj","brdom6disj","opabssi","cnvoprabOLD","cnfinltrel","rnxrn","dropab1","dropab2","csbxpgVD","relopabVD"]}