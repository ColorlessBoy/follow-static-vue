{"bIdx":37685,"bType":"axiom","type":"","name":"df-wl-ral","params":"setvar s0, setvar s1, class c0, wff w0","body":["|- wb(wl-ral(s0, c0, w0), wal(s1, wi(wcel(cv(s1), c0), wal(s0, wi(wceq(cv(s0), cv(s1)), w0)))))","-| diffss(s0, s1)","-| diffsc(s1, c0)","-| diffsw(s1, w0)"],"bodyPretty":["⊢ (∀(s0 ∈ c0, w0)↔ ∀(s1,(s1 ∈ c0 → ∀(s0,(s0 = s1 → w0)))))","⊣ d(s0, s1)","⊣ d(s1, c0)","⊣ d(s1, w0)"],"proof":[],"comment":"The definiens of ~ df-ral , ` A. x ( x e. A -> ph ) ` is a short and simple expression, but has a severe downside: It allows for two substantially different interpretations. One, and this is the common case, wants this expression to denote that ` ph ` holds for all elements of ` A ` . To this end, ` x ` must not be free in ` A ` , though . Should instead ` A ` vary with ` x ` , then we rather focus on those ` x ` , that happen to be an element of their respective ` A ( x ) ` . Such interpretation is rare, but must nevertheless be considered in design and comments. In addition, many want definitions be designed to express just a single idea, not many. Our definition here introduces a dummy variable ` y ` , disjoint from all other variables, to describe an element in ` A ` . It lets ` x ` appear as a formal parameter with no connection to ` A ` , but occurences in ` ph ` are still honored. The resulting subexpression ` A. x ( x = y -> ph ) ` is ` [ y / x ] ph ` in disguise (see ~ wl-dfralsb ). If ` x ` is not free in ` A ` , a simplification is possible ( see ~ wl-dfralf , ~ wl-dfralv ). (Contributed by NM, 19-Aug-1993.) Isolate x from A, idea of Mario Carneiro. (Revised by Wolf Lammen, 21-May-2023.)","parent":[],"children":["wl-dfralsb","wl-dfralf","wl-dfralv","wl-dfrexex"]}