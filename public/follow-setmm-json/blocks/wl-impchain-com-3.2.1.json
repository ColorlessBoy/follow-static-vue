{"bIdx":37560,"bType":"thm","type":"","name":"wl-impchain-com-3.2.1","params":"wff w0, wff w1, wff w2, wff w3","body":["|- wi(w0, wi(w1, wi(w2, w3)))","-| wi(w1, wi(w2, wi(w0, w3)))"],"bodyPretty":["⊢ (w0 →(w1 →(w2 → w3)))","⊣ (w1 →(w2 →(w0 → w3)))"],"proof":[{"stmt":{"origin":"wl-impchain-com-1.2(w0, w1, wi(w2, w3))","pretty":"wl-impchain-com-1.2(w0, w1, (w2 → w3))"},"body":{"origin":"|- wi(w0, wi(w1, wi(w2, w3)))\n-| wi(w1, wi(w0, wi(w2, w3)))","pretty":"⊢ (w0 →(w1 →(w2 → w3)))\n⊣ (w1 →(w0 →(w2 → w3)))"},"cumulated":{"origin":"|- wi(w0, wi(w1, wi(w2, w3)))\n-| wi(w1, wi(w0, wi(w2, w3)))","pretty":"⊢ (w0 →(w1 →(w2 → w3)))\n⊣ (w1 →(w0 →(w2 → w3)))"}},{"stmt":{"origin":"wl-impchain-com-2.3(w1, w0, w2, w3)","pretty":"wl-impchain-com-2.3(w1, w0, w2, w3)"},"body":{"origin":"|- wi(w1, wi(w0, wi(w2, w3)))\n-| wi(w1, wi(w2, wi(w0, w3)))","pretty":"⊢ (w1 →(w0 →(w2 → w3)))\n⊣ (w1 →(w2 →(w0 → w3)))"},"cumulated":{"origin":"|- wi(w0, wi(w1, wi(w2, w3)))\n-| wi(w1, wi(w2, wi(w0, w3)))","pretty":"⊢ (w0 →(w1 →(w2 → w3)))\n⊣ (w1 →(w2 →(w0 → w3)))"}}],"comment":"This theorem is in fact a copy of ~ com3r . The proof is an example of how to arrive at arbitrary permutations of antecedents, using only swapping theorems. The recursion principle is to first swap the correct antecedent to the position just before the consequent, and then employ a theorem handling an implication chain of length one less to reorder the others. (Contributed by Wolf Lammen, 17-Nov-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","parent":["wl-impchain-com-1.2","wl-impchain-com-2.3"],"children":[]}