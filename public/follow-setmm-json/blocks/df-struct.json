{"bIdx":17483,"bType":"axiom","type":"","name":"df-struct","params":"setvar s0, setvar s1","body":["|- wceq(cstr, copab(s0, s1, w3a(wcel(cv(s1), cin(cle, cxp(cn, cn))), wfun(cdif(cv(s0), csn(emptycls))), wss(cdm(cv(s0)), cfv(cfz, cv(s1))))))","-| diffss(s0, s1)"],"bodyPretty":["⊢ Struct = { < s0, s1 > |(s1 ∈(≤ ⋂(ℕ × ℕ))∧ Fun((s0 \\ { ∅ }))∧ dom(s0)⊆(... ` s1))}","⊣ d(s0, s1)"],"proof":[],"comment":"Define a structure with components in ` M ... N ` . This is not a requirement for groups, posets, etc., but it is a useful assumption for component extraction theorems. As mentioned in the section header, an \"extensible structure should be implemented as a function (a set of ordered pairs)\". The current definition, however, is less restrictive: it allows for classes which contain the empty set ` (/) ` to be extensible structures. Because of ~ 0nelfun , such classes cannot be functions. Without the empty set, however, a structure must be a function, see ~ structn0fun : ` F Struct X -> Fun ( F \\ { (/) } ) ` . Allowing an extensible structure to contain the empty set ensures that expressions like ` { <. A , B >. , <. C , D >. } ` are structures without asserting or implying that ` A ` , ` B ` , ` C ` and ` D ` are sets (if ` A ` or ` B ` is a proper class, then ` <. A , B >. = (/) ` , see ~ opprc ). This is used critically in ~ strle1 , ~ strle2 , ~ strle3 and ~ strleun to avoid sethood hypotheses on the \"payload\" sets: without this, ~ ipsstr and theorems like it will have many sethood assumptions, and may not even be usable in the empty context. Instead, the sethood assumption is deferred until it is actually needed, e.g., ~ ipsbase , which requires that the base set be a set but not any of the other components. Usually, a concrete structure like ` CCfld ` does not contain the empty set, and therefore is a function, see ~ cnfldfun . (Contributed by Mario Carneiro, 29-Aug-2015.)","parent":[],"children":["brstruct","isstruct2"]}