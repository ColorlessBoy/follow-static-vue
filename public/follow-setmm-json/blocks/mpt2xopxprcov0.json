{"bIdx":8206,"bType":"thm","type":"","name":"mpt2xopxprcov0","params":"setvar s0, setvar s1, class c0, class c1, class c2, class c3, class c4","body":["|- wi(wn(wa(wcel(c0, universe), wcel(c1, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))","-| wceq(c2, cmpo(s0, s1, universe, cfv(c1st, cv(s0)), c4))","-| diffss(s0, s1)","-| diffsc(s0, c0)","-| diffsc(s0, c1)","-| diffsc(s0, c2)","-| diffsc(s0, c3)"],"bodyPretty":["⊢ (¬(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌)→(< c0, c1 >[c2]c3)= ∅)","⊣ c2 =(s0 ∈ 𝕌, s1 ∈(1st ` s0)↦ c4)","⊣ d(s0, s1)","⊣ d(s0, c0)","⊣ d(s0, c1)","⊣ d(s0, c2)","⊣ d(s0, c3)"],"proof":[{"stmt":{"origin":"sylnbir(wa(wcel(c0, universe), wcel(c1, universe)), wceq(co(cop(c0, c1), c2, c3), emptycls), wcel(cop(c0, c1), cxp(universe, universe)))","pretty":"sylnbir((c0 ∈ 𝕌 ∧ c1 ∈ 𝕌), (< c0, c1 >[c2]c3)= ∅, < c0, c1 > ∈(𝕌 × 𝕌))"},"body":{"origin":"|- wi(wn(wa(wcel(c0, universe), wcel(c1, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))\n-| wb(wcel(cop(c0, c1), cxp(universe, universe)), wa(wcel(c0, universe), wcel(c1, universe)))\n-| wi(wn(wcel(cop(c0, c1), cxp(universe, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))","pretty":"⊢ (¬(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌)→(< c0, c1 >[c2]c3)= ∅)\n⊣ (< c0, c1 > ∈(𝕌 × 𝕌)↔(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌))\n⊣ (¬ < c0, c1 > ∈(𝕌 × 𝕌)→(< c0, c1 >[c2]c3)= ∅)"},"cumulated":{"origin":"|- wi(wn(wa(wcel(c0, universe), wcel(c1, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))\n-| wb(wcel(cop(c0, c1), cxp(universe, universe)), wa(wcel(c0, universe), wcel(c1, universe)))\n-| wi(wn(wcel(cop(c0, c1), cxp(universe, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))","pretty":"⊢ (¬(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌)→(< c0, c1 >[c2]c3)= ∅)\n⊣ (< c0, c1 > ∈(𝕌 × 𝕌)↔(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌))\n⊣ (¬ < c0, c1 > ∈(𝕌 × 𝕌)→(< c0, c1 >[c2]c3)= ∅)"}},{"stmt":{"origin":"opelxp(c0, c1, universe, universe)","pretty":"opelxp(c0, c1, universe, universe)"},"body":{"origin":"|- wb(wcel(cop(c0, c1), cxp(universe, universe)), wa(wcel(c0, universe), wcel(c1, universe)))","pretty":"⊢ (< c0, c1 > ∈(𝕌 × 𝕌)↔(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌))"},"cumulated":{"origin":"|- wi(wn(wa(wcel(c0, universe), wcel(c1, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))\n-| wi(wn(wcel(cop(c0, c1), cxp(universe, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))","pretty":"⊢ (¬(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌)→(< c0, c1 >[c2]c3)= ∅)\n⊣ (¬ < c0, c1 > ∈(𝕌 × 𝕌)→(< c0, c1 >[c2]c3)= ∅)"}},{"stmt":{"origin":"mpt2xopxnop0(s0, s1, cop(c0, c1), c2, c3, c4)","pretty":"mpt2xopxnop0(s0, s1, < c0, c1 >, c2, c3, c4)"},"body":{"origin":"|- wi(wn(wcel(cop(c0, c1), cxp(universe, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))\n-| wceq(c2, cmpo(s0, s1, universe, cfv(c1st, cv(s0)), c4))\n-| diffss(s0, s1)\n-| diffsc(s0, cop(c0, c1))\n-| diffsc(s0, c2)\n-| diffsc(s0, c3)","pretty":"⊢ (¬ < c0, c1 > ∈(𝕌 × 𝕌)→(< c0, c1 >[c2]c3)= ∅)\n⊣ c2 =(s0 ∈ 𝕌, s1 ∈(1st ` s0)↦ c4)\n⊣ d(s0, s1)\n⊣ d(s0, < c0, c1 >)\n⊣ d(s0, c2)\n⊣ d(s0, c3)"},"cumulated":{"origin":"|- wi(wn(wa(wcel(c0, universe), wcel(c1, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))\n-| wceq(c2, cmpo(s0, s1, universe, cfv(c1st, cv(s0)), c4))\n-| diffss(s0, s1)\n-| diffsc(s0, cop(c0, c1))\n-| diffsc(s0, c2)\n-| diffsc(s0, c3)","pretty":"⊢ (¬(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌)→(< c0, c1 >[c2]c3)= ∅)\n⊣ c2 =(s0 ∈ 𝕌, s1 ∈(1st ` s0)↦ c4)\n⊣ d(s0, s1)\n⊣ d(s0, < c0, c1 >)\n⊣ d(s0, c2)\n⊣ d(s0, c3)"}},{"stmt":{"origin":"diff.cop.s(s0, c0, c1)","pretty":"diff.cop.s(s0, c0, c1)"},"body":{"origin":"|- diffsc(s0, cop(c0, c1))\n-| diffsc(s0, c0)\n-| diffsc(s0, c1)","pretty":"⊢ d(s0, < c0, c1 >)\n⊣ d(s0, c0)\n⊣ d(s0, c1)"},"cumulated":{"origin":"|- wi(wn(wa(wcel(c0, universe), wcel(c1, universe))), wceq(co(cop(c0, c1), c2, c3), emptycls))\n-| wceq(c2, cmpo(s0, s1, universe, cfv(c1st, cv(s0)), c4))\n-| diffss(s0, s1)\n-| diffsc(s0, c2)\n-| diffsc(s0, c3)\n-| diffsc(s0, c0)\n-| diffsc(s0, c1)","pretty":"⊢ (¬(c0 ∈ 𝕌 ∧ c1 ∈ 𝕌)→(< c0, c1 >[c2]c3)= ∅)\n⊣ c2 =(s0 ∈ 𝕌, s1 ∈(1st ` s0)↦ c4)\n⊣ d(s0, s1)\n⊣ d(s0, c2)\n⊣ d(s0, c3)\n⊣ d(s0, c0)\n⊣ d(s0, c1)"}}],"comment":"If the components of the first argument of an operation given by a maps-to rule, where the first argument is a pair and the base set of the second argument is the first component of the first argument, are not sets, then the value of the operation is the empty set. (Contributed by Alexander van der Vekens, 10-Oct-2017.)","parent":["sylnbir","opelxp","mpt2xopxnop0","diff.cop.s"],"children":["mpt2xopynvov0"]}