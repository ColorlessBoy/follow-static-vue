{"bIdx":33015,"bType":"axiom","type":"","name":"df-dp","params":"setvar s0, setvar s1","body":["|- wceq(cdp, cmpo(s0, s1, cn0, cr, cdp2(cv(s0), cv(s1))))","-| diffss(s0, s1)"],"bodyPretty":["⊢ . =(s0 ∈ ℕ0, s1 ∈ ℝ ↦ _(s0, s1))","⊣ d(s0, s1)"],"proof":[],"comment":"Define the ` . ` (decimal point) operator. For example, ` ( 1 . 5 ) = ( 3 / 2 ) ` , and ` -u ( ; 3 2 . _ 7 _ 1 8 ) = -u ( ; ; ; ; 3 2 7 1 8 / ; ; ; 1 0 0 0 ) ` Unary minus, if applied, should normally be applied in front of the parentheses. Metamath intentionally does not have a built-in construct for numbers, so it can show that numbers are something you can build based on set theory. However, that means that Metamath has no built-in way to parse and handle decimal numbers as traditionally written, e.g., \"2.54\". Here we create a system for modeling traditional decimal point notation; it is not syntactically identical, but it is sufficiently similar so it is a reasonable model of decimal point notation. It should also serve as a convenient way to write some fractional numbers. The RHS is ` RR ` , not ` QQ ` ; this should simplify some proofs. The LHS is ` NN0 ` , since that is what is used in practice. The definition intentionally does not allow negative numbers on the LHS; if it did, nonzero fractions would produce the wrong results. (It would be possible to define the decimal point to do this, but using it would be more complicated, and the expression ` -u ( A . B ) ` is just as convenient.) (Contributed by David A. Wheeler, 15-May-2015.)","parent":[],"children":["dpval"]}