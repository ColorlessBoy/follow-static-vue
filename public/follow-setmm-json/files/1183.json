{"index":1183,"title":"Implication chains","content":"","blocks":[{"name":"wl-section-impchain","content":"An implication like ` ( ps -> ph ) ` with one antecedent can easily be extended by prepending more and more antecedents, as in ` ( ch -> ( ps -> ph ) ) ` or ` ( th -> ( ch -> ( ps -> ph ) ) ) ` . I call these expressions implication chains, and the number of antecedents (number of nodes minus one) denotes their length. A given length often marks just a required minimum value, since the consequent ` ph ` itself may represent an implication, or even an implication chain, such hiding part of the whole chain. As an extension, it is useful to consider a single variable ` ph ` as a degenerate implication chain of length zero. Implication chains play a particular role in logic, as all propositional expressions turn out to be convertible to one or more implication chains, their nodes as simple as a variable, or its negation. So there is good reason to focus on implication chains as a sort of normalized expressions, and build some general theorems around them, with proofs using recursive patterns. This allows for theorems referring to longer and longer implication chains in an automated way. The theorem names in this section contain the text fragment 'impchain' to point out their relevance to implication chains, followed by a number indicating the (minimal) length of the longest chain involved. (Contributed by Wolf Lammen, 6-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-section-impchain(wff w0) {\n  |- w0\n  -| w0\n} = {\n  idi(w0)\n}","pretty":"thm wl-section-impchain(wff w0) {\n  ⊢ w0\n  ⊣ w0\n} = {\n  idi(w0)\n}","parent":["idi"],"children":[]},{"name":"wl-impchain-mp-x","content":"This series of theorems provide a means of exchanging the consequent of an implication chain via a simple implication. In the main part, the theorems ~ ax-mp , ~ syl , ~ syl6 , ~ syl8 form the beginning of this series. These theorems are replicated here, but with proofs that aim at a recursive scheme, allowing to base a proof on that of the previous one in the series. (Contributed by Wolf Lammen, 17-Nov-2019.)","origin":"thm wl-impchain-mp-x() {\n  |- wtru\n} = {\n  tru()\n}","pretty":"thm wl-impchain-mp-x() {\n  ⊢ wtru\n} = {\n  tru()\n}","parent":["tru"],"children":[]},{"name":"wl-impchain-mp-0","content":"This theorem is the start of a proof recursion scheme where we replace the consequent of an implication chain. The number '0' in the theorem name indicates that the modified chain has no antecedents. This theorem is in fact a copy of ~ ax-mp , and is repeated here to emphasize the recursion using similar theorem names. (Contributed by Wolf Lammen, 6-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-mp-0(wff w0, wff w1) {\n  |- w0\n  -| w1\n  -| wi(w1, w0)\n} = {\n  ax-mp(w0, w1)\n}","pretty":"thm wl-impchain-mp-0(wff w0, wff w1) {\n  ⊢ w0\n  ⊣ w1\n  ⊣ (w1 → w0)\n} = {\n  ax-mp(w0, w1)\n}","parent":["ax-mp"],"children":["wl-impchain-mp-1","wl-impchain-com-1.2"]},{"name":"wl-impchain-mp-1","content":"This theorem is in fact a copy of ~ wl-luk-syl , and repeated here to demonstrate a recursive proof scheme. The number '1' in the theorem name indicates that a chain of length 1 is modified. (Contributed by Wolf Lammen, 6-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-mp-1(wff w0, wff w1, wff w2) {\n  |- wi(w0, w1)\n  -| wi(w0, w2)\n  -| wi(w2, w1)\n} = {\n  wl-impchain-mp-0(wi(w0, w1), wi(w0, w2))\n  wl-luk-imim2i(w0, w2, w1)\n}","pretty":"thm wl-impchain-mp-1(wff w0, wff w1, wff w2) {\n  ⊢ (w0 → w1)\n  ⊣ (w0 → w2)\n  ⊣ (w2 → w1)\n} = {\n  wl-impchain-mp-0((w0 → w1), (w0 → w2))\n  wl-luk-imim2i(w0, w2, w1)\n}","parent":["wl-impchain-mp-0","wl-luk-imim2i"],"children":["wl-impchain-mp-2","wl-impchain-com-1.3"]},{"name":"wl-impchain-mp-2","content":"This theorem is in fact a copy of ~ wl-luk-syl6 , and repeated here to demonstrate a recursive proof scheme. The number '2' in the theorem name indicates that a chain of length 2 is modified. (Contributed by Wolf Lammen, 6-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-mp-2(wff w0, wff w1, wff w2, wff w3) {\n  |- wi(w0, wi(w1, w2))\n  -| wi(w0, wi(w1, w3))\n  -| wi(w3, w2)\n} = {\n  wl-impchain-mp-1(w0, wi(w1, w2), wi(w1, w3))\n  wl-luk-imim2i(w1, w3, w2)\n}","pretty":"thm wl-impchain-mp-2(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ (w0 →(w1 → w2))\n  ⊣ (w0 →(w1 → w3))\n  ⊣ (w3 → w2)\n} = {\n  wl-impchain-mp-1(w0, (w1 → w2), (w1 → w3))\n  wl-luk-imim2i(w1, w3, w2)\n}","parent":["wl-impchain-mp-1","wl-luk-imim2i"],"children":["wl-impchain-com-1.4"]},{"name":"wl-impchain-com-1.x","content":"It is often convenient to have the antecedent under focus in first position, so we can apply immediate theorem forms (as opposed to deduction, tautology form). This series of theorems swaps the first with the last antecedent in an implication chain. This kind of swapping is self-inverse, whence we prefer it over, say, rotating theorems. A consequent can hide a tail of a longer chain, so theorems of this series appear as swapping a pair of antecedents with fixed offsets. This form of swapping antecedents is flexible enough to allow for any permutation of antecedents in an implication chain. The first elements of this series correspond to ~ com12 , ~ com13 , ~ com14 and ~ com15 in the main part. The proofs of this series aim at automated proving using a simple recursive scheme. It employs the previous theorem in the series along with a sample from the ~ wl-impchain-mp-x series developed before. (Contributed by Wolf Lammen, 17-Nov-2019.)","origin":"thm wl-impchain-com-1.x() {\n  |- wtru\n} = {\n  tru()\n}","pretty":"thm wl-impchain-com-1.x() {\n  ⊢ wtru\n} = {\n  tru()\n}","parent":["tru"],"children":[]},{"name":"wl-impchain-com-1.1","content":"A degenerate form of antecedent swapping. The number '1' in the theorem name indicates that it handles a chain of length 1. Since there is just one antecedent in the chain, there is nothing to swap. Nondegenerated forms begin with ~ wl-impchain-com-1.2 , for more see there. (Contributed by Wolf Lammen, 7-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-com-1.1(wff w0, wff w1) {\n  |- wi(w0, w1)\n  -| wi(w0, w1)\n} = {\n  idi(wi(w0, w1))\n}","pretty":"thm wl-impchain-com-1.1(wff w0, wff w1) {\n  ⊢ (w0 → w1)\n  ⊣ (w0 → w1)\n} = {\n  idi((w0 → w1))\n}","parent":["idi"],"children":["wl-impchain-com-1.2"]},{"name":"wl-impchain-com-1.2","content":"This theorem is in fact a copy of ~ wl-luk-com12 , and repeated here to demonstrate a simple proof scheme. The number '2' in the theorem name indicates that a chain of length 2 is modified. See ~ wl-impchain-com-1.x for more information how this proof is generated. (Contributed by Wolf Lammen, 7-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-com-1.2(wff w0, wff w1, wff w2) {\n  |- wi(w0, wi(w1, w2))\n  -| wi(w1, wi(w0, w2))\n} = {\n  wl-impchain-com-1.1(w0, wi(w1, w2))\n  wl-impchain-mp-0(wi(w0, wi(w1, w2)), wi(w1, wi(w0, w2)))\n  wl-impchain-com-1.1(w1, wi(w0, w2))\n  wl-luk-pm2.04(w1, w0, w2)\n}","pretty":"thm wl-impchain-com-1.2(wff w0, wff w1, wff w2) {\n  ⊢ (w0 →(w1 → w2))\n  ⊣ (w1 →(w0 → w2))\n} = {\n  wl-impchain-com-1.1(w0, (w1 → w2))\n  wl-impchain-mp-0((w0 →(w1 → w2)), (w1 →(w0 → w2)))\n  wl-impchain-com-1.1(w1, (w0 → w2))\n  wl-luk-pm2.04(w1, w0, w2)\n}","parent":["wl-impchain-com-1.1","wl-impchain-mp-0","wl-luk-pm2.04"],"children":["wl-impchain-com-1.3","wl-impchain-com-2.3","wl-impchain-com-2.4","wl-impchain-com-3.2.1","wl-impchain-a1-2"]},{"name":"wl-impchain-com-1.3","content":"This theorem is in fact a copy of ~ com13 , and repeated here to demonstrate a simple proof scheme. The number '3' in the theorem name indicates that a chain of length 3 is modified. See ~ wl-impchain-com-1.x for more information how this proof is generated. (Contributed by Wolf Lammen, 7-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-com-1.3(wff w0, wff w1, wff w2, wff w3) {\n  |- wi(w0, wi(w1, wi(w2, w3)))\n  -| wi(w2, wi(w1, wi(w0, w3)))\n} = {\n  wl-impchain-com-1.2(w0, w1, wi(w2, w3))\n  wl-impchain-mp-1(w1, wi(w0, wi(w2, w3)), wi(w2, wi(w0, w3)))\n  wl-impchain-com-1.2(w1, w2, wi(w0, w3))\n  wl-luk-pm2.04(w2, w0, w3)\n}","pretty":"thm wl-impchain-com-1.3(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ (w0 →(w1 →(w2 → w3)))\n  ⊣ (w2 →(w1 →(w0 → w3)))\n} = {\n  wl-impchain-com-1.2(w0, w1, (w2 → w3))\n  wl-impchain-mp-1(w1, (w0 →(w2 → w3)), (w2 →(w0 → w3)))\n  wl-impchain-com-1.2(w1, w2, (w0 → w3))\n  wl-luk-pm2.04(w2, w0, w3)\n}","parent":["wl-impchain-com-1.2","wl-impchain-mp-1","wl-luk-pm2.04"],"children":["wl-impchain-com-1.4","wl-impchain-com-2.3"]},{"name":"wl-impchain-com-1.4","content":"This theorem is in fact a copy of ~ com14 , and repeated here to demonstrate a simple proof scheme. The number '4' in the theorem name indicates that a chain of length 4 is modified. See ~ wl-impchain-com-1.x for more information how this proof is generated. (Contributed by Wolf Lammen, 7-Jul-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-com-1.4(wff w0, wff w1, wff w2, wff w3, wff w4) {\n  |- wi(w0, wi(w1, wi(w2, wi(w3, w4))))\n  -| wi(w3, wi(w1, wi(w2, wi(w0, w4))))\n} = {\n  wl-impchain-com-1.3(w0, w1, w2, wi(w3, w4))\n  wl-impchain-mp-2(w2, w1, wi(w0, wi(w3, w4)), wi(w3, wi(w0, w4)))\n  wl-impchain-com-1.3(w2, w1, w3, wi(w0, w4))\n  wl-luk-pm2.04(w3, w0, w4)\n}","pretty":"thm wl-impchain-com-1.4(wff w0, wff w1, wff w2, wff w3, wff w4) {\n  ⊢ (w0 →(w1 →(w2 →(w3 → w4))))\n  ⊣ (w3 →(w1 →(w2 →(w0 → w4))))\n} = {\n  wl-impchain-com-1.3(w0, w1, w2, (w3 → w4))\n  wl-impchain-mp-2(w2, w1, (w0 →(w3 → w4)), (w3 →(w0 → w4)))\n  wl-impchain-com-1.3(w2, w1, w3, (w0 → w4))\n  wl-luk-pm2.04(w3, w0, w4)\n}","parent":["wl-impchain-com-1.3","wl-impchain-mp-2","wl-luk-pm2.04"],"children":["wl-impchain-com-2.4"]},{"name":"wl-impchain-com-n.m","content":"This series of theorems allow swapping any two antecedents in an implication chain. The theorem names follow a pattern wl-impchain-com-n.m with integral numbers n < m, that swaps the m-th antecedent with n-th one in an implication chain. It is sufficient to restrict the length of the chain to m, too, since the consequent can be assumed to be the tail right of the m-th antecedent of any arbitrary sized implication chain. We further assume n > 1, since the ~ wl-impchain-com-1.x series already covers the special case n = 1. Being able to swap any two antecedents in an implication chain lays the foundation of permuting its antecedents arbitrarily. The proofs of this series aim at automated proofing using a simple scheme. Any instance of this series is a triple step of swapping the first and n-th antecedent, then the first and the m-th, then the first and the n-th antecedent again. Each of these steps is an instance of the ~ wl-impchain-com-1.x series. (Contributed by Wolf Lammen, 17-Nov-2019.)","origin":"thm wl-impchain-com-n.m() {\n  |- wtru\n} = {\n  tru()\n}","pretty":"thm wl-impchain-com-n.m() {\n  ⊢ wtru\n} = {\n  tru()\n}","parent":["tru"],"children":[]},{"name":"wl-impchain-com-2.3","content":"This theorem is in fact a copy of ~ com23 . It starts a series of theorems named after ~ wl-impchain-com-n.m . For more information see there. (Contributed by Wolf Lammen, 12-Nov-2019.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-com-2.3(wff w0, wff w1, wff w2, wff w3) {\n  |- wi(w0, wi(w1, wi(w2, w3)))\n  -| wi(w0, wi(w2, wi(w1, w3)))\n} = {\n  wl-impchain-com-1.2(w0, w1, wi(w2, w3))\n  wl-impchain-com-1.3(w1, w0, w2, w3)\n  wl-impchain-com-1.2(w2, w0, wi(w1, w3))\n}","pretty":"thm wl-impchain-com-2.3(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ (w0 →(w1 →(w2 → w3)))\n  ⊣ (w0 →(w2 →(w1 → w3)))\n} = {\n  wl-impchain-com-1.2(w0, w1, (w2 → w3))\n  wl-impchain-com-1.3(w1, w0, w2, w3)\n  wl-impchain-com-1.2(w2, w0, (w1 → w3))\n}","parent":["wl-impchain-com-1.2","wl-impchain-com-1.3"],"children":["wl-impchain-com-3.2.1","wl-impchain-a1-3"]},{"name":"wl-impchain-com-2.4","content":"This theorem is in fact a copy of ~ com24 . It is another instantiation of theorems named after ~ wl-impchain-com-n.m . For more information see there. (Contributed by Wolf Lammen, 17-Nov-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm wl-impchain-com-2.4(wff w0, wff w1, wff w2, wff w3, wff w4) {\n  |- wi(w0, wi(w1, wi(w2, wi(w3, w4))))\n  -| wi(w0, wi(w3, wi(w2, wi(w1, w4))))\n} = {\n  wl-impchain-com-1.2(w0, w1, wi(w2, wi(w3, w4)))\n  wl-impchain-com-1.4(w1, w0, w2, w3, w4)\n  wl-impchain-com-1.2(w3, w0, wi(w2, wi(w1, w4)))\n}","pretty":"thm wl-impchain-com-2.4(wff w0, wff w1, wff w2, wff w3, wff w4) {\n  ⊢ (w0 →(w1 →(w2 →(w3 → w4))))\n  ⊣ (w0 →(w3 →(w2 →(w1 → w4))))\n} = {\n  wl-impchain-com-1.2(w0, w1, (w2 →(w3 → w4)))\n  wl-impchain-com-1.4(w1, w0, w2, w3, w4)\n  wl-impchain-com-1.2(w3, w0, (w2 →(w1 → w4)))\n}","parent":["wl-impchain-com-1.2","wl-impchain-com-1.4"],"children":[]},{"name":"wl-impchain-com-3.2.1","content":"This theorem is in fact a copy of ~ com3r . The proof is an example of how to arrive at arbitrary permutations of antecedents, using only swapping theorems. The recursion principle is to first swap the correct antecedent to the position just before the consequent, and then employ a theorem handling an implication chain of length one less to reorder the others. (Contributed by Wolf Lammen, 17-Nov-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm wl-impchain-com-3.2.1(wff w0, wff w1, wff w2, wff w3) {\n  |- wi(w0, wi(w1, wi(w2, w3)))\n  -| wi(w1, wi(w2, wi(w0, w3)))\n} = {\n  wl-impchain-com-1.2(w0, w1, wi(w2, w3))\n  wl-impchain-com-2.3(w1, w0, w2, w3)\n}","pretty":"thm wl-impchain-com-3.2.1(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ (w0 →(w1 →(w2 → w3)))\n  ⊣ (w1 →(w2 →(w0 → w3)))\n} = {\n  wl-impchain-com-1.2(w0, w1, (w2 → w3))\n  wl-impchain-com-2.3(w1, w0, w2, w3)\n}","parent":["wl-impchain-com-1.2","wl-impchain-com-2.3"],"children":[]},{"name":"wl-impchain-a1-x","content":"If an implication chain is assumed (hypothesis) or proven (theorem) to hold, then we may add any extra antecedent to it, without changing its truth. This is expressed in its simplest form in ~ wl-luk-a1i , that allows us prepending an arbitrary antecedent to an implication chain. Using our antecedent swapping theorems described in ~ wl-impchain-com-n.m , we may then move such a prepended antecedent to any desired location within all antecedents. The first series of theorems of this kind adds a single antecedent somewhere to an implication chain. The appended number in the theorem name indicates its position within all antecedents, 1 denoting the head position. A second theorem series extends this idea to multiple additions (TODO). Adding antecedents to an implication chain usually weakens their universality. The consequent afterwards dependends on more conditions than before, which renders the implication chain less versatile. So you find this proof technique mostly when you adjust a chain to a hypothesis of a rule. A common case are syllogisms merging two implication chains into one. The first elements of the first series correspond to ~ a1i , ~ a1d and ~ a1dd in the main part. The proofs of this series aim at automated proving using a simple recursive scheme. It employs the previous theorem in the series along with a sample from the ~ wl-impchain-com-1.x series developed before. (Contributed by Wolf Lammen, 20-Jun-2020.)","origin":"thm wl-impchain-a1-x() {\n  |- wtru\n} = {\n  tru()\n}","pretty":"thm wl-impchain-a1-x() {\n  ⊢ wtru\n} = {\n  tru()\n}","parent":["tru"],"children":[]},{"name":"wl-impchain-a1-1","content":"Inference rule, a copy of ~ a1i . Head start of a recursive proof pattern. (Contributed by Wolf Lammen, 20-Jun-2020.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-a1-1(wff w0, wff w1) {\n  |- wi(w0, w1)\n  -| w1\n} = {\n  wl-luk-a1i(w0, w1)\n}","pretty":"thm wl-impchain-a1-1(wff w0, wff w1) {\n  ⊢ (w0 → w1)\n  ⊣ w1\n} = {\n  wl-luk-a1i(w0, w1)\n}","parent":["wl-luk-a1i"],"children":["wl-impchain-a1-2"]},{"name":"wl-impchain-a1-2","content":"Inference rule, a copy of ~ a1d . First recursive proof based on the previous instance. (Contributed by Wolf Lammen, 20-Jun-2020.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-a1-2(wff w0, wff w1, wff w2) {\n  |- wi(w0, wi(w1, w2))\n  -| wi(w0, w2)\n} = {\n  wl-impchain-com-1.2(w0, w1, w2)\n  wl-impchain-a1-1(w1, wi(w0, w2))\n}","pretty":"thm wl-impchain-a1-2(wff w0, wff w1, wff w2) {\n  ⊢ (w0 →(w1 → w2))\n  ⊣ (w0 → w2)\n} = {\n  wl-impchain-com-1.2(w0, w1, w2)\n  wl-impchain-a1-1(w1, (w0 → w2))\n}","parent":["wl-impchain-com-1.2","wl-impchain-a1-1"],"children":["wl-impchain-a1-3"]},{"name":"wl-impchain-a1-3","content":"Inference rule, a copy of ~ a1dd . A recursive proof depending on previous instances, and demonstrating the proof pattern. (Contributed by Wolf Lammen, 20-Jun-2020.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm wl-impchain-a1-3(wff w0, wff w1, wff w2, wff w3) {\n  |- wi(w0, wi(w1, wi(w2, w3)))\n  -| wi(w0, wi(w1, w3))\n} = {\n  wl-impchain-com-2.3(w0, w1, w2, w3)\n  wl-impchain-a1-2(w0, w2, wi(w1, w3))\n}","pretty":"thm wl-impchain-a1-3(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ (w0 →(w1 →(w2 → w3)))\n  ⊣ (w0 →(w1 → w3))\n} = {\n  wl-impchain-com-2.3(w0, w1, w2, w3)\n  wl-impchain-a1-2(w0, w2, (w1 → w3))\n}","parent":["wl-impchain-com-2.3","wl-impchain-a1-2"],"children":[]}]}