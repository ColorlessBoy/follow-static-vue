{"index":273,"title":"Functions with a domain containing at least two different elements","content":"","blocks":[{"name":"fundmge2nop0","content":"A function with a domain containing (at least) two different elements is not an ordered pair. This stronger version of ~ fundmge2nop (with the less restrictive requirement that ` ( G \\ { (/) } ) ` needs to be a function instead of ` G ` ) is useful for proofs for extensible structures, see ~ structn0fun . (Contributed by AV, 12-Oct-2020.) (Revised by AV, 7-Jun-2021.) (Proof shortened by AV, 15-Nov-2021.)","origin":"thm fundmge2nop0(class c0) {\n  |- wi(wa(wfun(cdif(c0, csn(emptycls))), wbr(nat2, cle, cfv(chash, cdm(c0)))), wn(wcel(c0, cxp(universe, universe))))\n} = {\n  pm2.61d1(wa(wfun(cdif(c0, csn(emptycls))), wbr(nat2, cle, cfv(chash, cdm(c0)))), wn(wcel(c0, cxp(universe, universe))), wcel(c0, universe))\n  imp(wfun(cdif(c0, csn(emptycls))), wbr(nat2, cle, cfv(chash, cdm(c0))), wi(wcel(c0, universe), wn(wcel(c0, cxp(universe, universe)))))\n  com13(wfun(cdif(c0, csn(emptycls))), wbr(nat2, cle, cfv(chash, cdm(c0))), wcel(c0, universe), wn(wcel(c0, cxp(universe, universe))))\n  syl6(wcel(c0, universe), wbr(nat2, cle, cfv(chash, cdm(c0))), wi(wfun(cdif(c0, csn(emptycls))), wn(wcel(c0, cxp(universe, universe)))), wrex(hs0, cdm(c0), wrex(hs1, cdm(c0), wne(cv(hs0), cv(hs1)))))\n  syl(wcel(c0, universe), wi(wbr(nat2, cle, cfv(chash, cdm(c0))), wrex(hs0, cdm(c0), wrex(hs1, cdm(c0), wne(cv(hs0), cv(hs1))))), wcel(cdm(c0), universe))\n  dmexg(c0, universe)\n  ex(wcel(cdm(c0), universe), wbr(nat2, cle, cfv(chash, cdm(c0))), wrex(hs0, cdm(c0), wrex(hs1, cdm(c0), wne(cv(hs0), cv(hs1)))))\n  hashge2el2dif(hs0, hs1, cdm(c0), universe)\n  rexlimivv(hs0, hs1, cdm(c0), cdm(c0), wne(cv(hs0), cv(hs1)), wi(wfun(cdif(c0, csn(emptycls))), wn(wcel(c0, cxp(universe, universe)))))\n  syl5bi(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wne(cv(hs0), cv(hs1)), wi(wfun(cdif(c0, csn(emptycls))), wn(wcel(c0, cxp(universe, universe)))), wn(wceq(cv(hs0), cv(hs1))))\n  df-ne(cv(hs0), cv(hs1))\n  com23(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wn(wceq(cv(hs0), cv(hs1))), wfun(cdif(c0, csn(emptycls))), wn(wcel(c0, cxp(universe, universe))))\n  ex(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls))), wi(wn(wceq(cv(hs0), cv(hs1))), wn(wcel(c0, cxp(universe, universe)))))\n  con3d(wa(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls)))), wceq(cv(hs0), cv(hs1)), wcel(c0, cxp(universe, universe)))\n  syl5bi(wa(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls)))), wcel(c0, cxp(universe, universe)), wceq(cv(hs0), cv(hs1)), wex(hs2, wex(hs3, wceq(c0, cop(cv(hs2), cv(hs3))))))\n  elvv(hs2, hs3, c0)\n  com12(wa(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls)))), wex(hs2, wex(hs3, wceq(c0, cop(cv(hs2), cv(hs3))))), wceq(cv(hs0), cv(hs1)))\n  exlimivv(hs2, hs3, wceq(c0, cop(cv(hs2), cv(hs3))), wi(wa(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls)))), wceq(cv(hs0), cv(hs1))))\n  impcomd(wceq(c0, cop(cv(hs2), cv(hs3))), wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls))), wceq(cv(hs0), cv(hs1)))\n  sylbid(wceq(c0, cop(cv(hs2), cv(hs3))), wfun(cdif(c0, csn(emptycls))), wi(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wceq(cv(hs0), cv(hs1))), wfun(cdif(cop(cv(hs2), cv(hs3)), csn(emptycls))))\n  funeqd(cdif(c0, csn(emptycls)), cdif(cop(cv(hs2), cv(hs3)), csn(emptycls)), wceq(c0, cop(cv(hs2), cv(hs3))))\n  difeq1(c0, cop(cv(hs2), cv(hs3)), csn(emptycls))\n  syl5bi(wceq(c0, cop(cv(hs2), cv(hs3))), wfun(cdif(cop(cv(hs2), cv(hs3)), csn(emptycls))), wi(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wceq(cv(hs0), cv(hs1))), wfun(cop(cv(hs2), cv(hs3))))\n  funeqi(cdif(cop(cv(hs2), cv(hs3)), csn(emptycls)), cop(cv(hs2), cv(hs3)))\n  eqcomi(cdif(cop(cv(hs2), cv(hs3)), csn(emptycls)), cop(cv(hs2), cv(hs3)))\n  opwo0id(cv(hs2), cv(hs3))\n  com23(wceq(c0, cop(cv(hs2), cv(hs3))), wfun(cop(cv(hs2), cv(hs3))), wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wceq(cv(hs0), cv(hs1)))\n  syl6bi(wceq(c0, cop(cv(hs2), cv(hs3))), wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wi(wfun(cop(cv(hs2), cv(hs3))), wceq(cv(hs0), cv(hs1))), wa(wcel(cv(hs0), cdm(cop(cv(hs2), cv(hs3)))), wcel(cv(hs1), cdm(cop(cv(hs2), cv(hs3))))))\n  anbi12d(wceq(c0, cop(cv(hs2), cv(hs3))), wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0)), wcel(cv(hs0), cdm(cop(cv(hs2), cv(hs3)))), wcel(cv(hs1), cdm(cop(cv(hs2), cv(hs3)))))\n  eleq2d(cv(hs0), cdm(c0), cdm(cop(cv(hs2), cv(hs3))), wceq(c0, cop(cv(hs2), cv(hs3))))\n  eleq2d(cv(hs1), cdm(c0), cdm(cop(cv(hs2), cv(hs3))), wceq(c0, cop(cv(hs2), cv(hs3))))\n  dmeq(c0, cop(cv(hs2), cv(hs3)))\n  expcom(wa(wcel(cv(hs0), cdm(cop(cv(hs2), cv(hs3)))), wcel(cv(hs1), cdm(cop(cv(hs2), cv(hs3))))), wfun(cop(cv(hs2), cv(hs3))), wceq(cv(hs0), cv(hs1)))\n  3expb(wfun(cop(cv(hs2), cv(hs3))), wcel(cv(hs0), cdm(cop(cv(hs2), cv(hs3)))), wcel(cv(hs1), cdm(cop(cv(hs2), cv(hs3)))), wceq(cv(hs0), cv(hs1)))\n  funopdmsn(cop(cv(hs2), cv(hs3)), cv(hs0), cv(hs1), cv(hs2), cv(hs3), universe, universe)\n  eqid(cop(cv(hs2), cv(hs3)))\n  vex(hs2)\n  vex(hs3)\n  prcnel(c0, cxp(universe, universe))\n  diff.hs0.s(hs1)\n  diff.hs0.c(cdm(c0))\n  diff.hs0.c(universe)\n  diff.hs1.c(cdm(c0))\n  diff.hs1.c(universe)\n  diff.hs0.w(wi(wfun(cdif(c0, csn(emptycls))), wn(wcel(c0, cxp(universe, universe)))))\n  diff.hs1.w(wi(wfun(cdif(c0, csn(emptycls))), wn(wcel(c0, cxp(universe, universe)))))\n  diff.hs2.s(hs3)\n  diff.hs2.c(c0)\n  diff.hs3.c(c0)\n  diff.hs2.w(wi(wa(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls)))), wceq(cv(hs0), cv(hs1))))\n  diff.hs3.w(wi(wa(wa(wcel(cv(hs0), cdm(c0)), wcel(cv(hs1), cdm(c0))), wfun(cdif(c0, csn(emptycls)))), wceq(cv(hs0), cv(hs1))))\n}","pretty":"thm fundmge2nop0(class c0) {\n  ⊢ ((Fun((c0 \\ { ∅ }))∧ 2[≤](# ` dom(c0)))→ ¬ c0 ∈(𝕌 × 𝕌))\n} = {\n  pm2.61d1((Fun((c0 \\ { ∅ }))∧ 2[≤](# ` dom(c0))), ¬ c0 ∈(𝕌 × 𝕌), c0 ∈ 𝕌)\n  imp(Fun((c0 \\ { ∅ })), 2[≤](# ` dom(c0)), (c0 ∈ 𝕌 → ¬ c0 ∈(𝕌 × 𝕌)))\n  com13(Fun((c0 \\ { ∅ })), 2[≤](# ` dom(c0)), c0 ∈ 𝕌, ¬ c0 ∈(𝕌 × 𝕌))\n  syl6(c0 ∈ 𝕌, 2[≤](# ` dom(c0)), (Fun((c0 \\ { ∅ }))→ ¬ c0 ∈(𝕌 × 𝕌)), ∃(hs0 ∈ dom(c0), ∃(hs1 ∈ dom(c0), hs0 ≠ hs1)))\n  syl(c0 ∈ 𝕌, (2[≤](# ` dom(c0))→ ∃(hs0 ∈ dom(c0), ∃(hs1 ∈ dom(c0), hs0 ≠ hs1))), dom(c0)∈ 𝕌)\n  dmexg(c0, universe)\n  ex(dom(c0)∈ 𝕌, 2[≤](# ` dom(c0)), ∃(hs0 ∈ dom(c0), ∃(hs1 ∈ dom(c0), hs0 ≠ hs1)))\n  hashge2el2dif(hs0, hs1, dom(c0), universe)\n  rexlimivv(hs0, hs1, dom(c0), dom(c0), hs0 ≠ hs1, (Fun((c0 \\ { ∅ }))→ ¬ c0 ∈(𝕌 × 𝕌)))\n  syl5bi((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0)), hs0 ≠ hs1, (Fun((c0 \\ { ∅ }))→ ¬ c0 ∈(𝕌 × 𝕌)), ¬ hs0 = hs1)\n  df-ne(hs0, hs1)\n  com23((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0)), ¬ hs0 = hs1, Fun((c0 \\ { ∅ })), ¬ c0 ∈(𝕌 × 𝕌))\n  ex((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0)), Fun((c0 \\ { ∅ })), (¬ hs0 = hs1 → ¬ c0 ∈(𝕌 × 𝕌)))\n  con3d(((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))∧ Fun((c0 \\ { ∅ }))), hs0 = hs1, c0 ∈(𝕌 × 𝕌))\n  syl5bi(((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))∧ Fun((c0 \\ { ∅ }))), c0 ∈(𝕌 × 𝕌), hs0 = hs1, ∃(hs2, ∃(hs3, c0 = < hs2, hs3 >)))\n  elvv(hs2, hs3, c0)\n  com12(((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))∧ Fun((c0 \\ { ∅ }))), ∃(hs2, ∃(hs3, c0 = < hs2, hs3 >)), hs0 = hs1)\n  exlimivv(hs2, hs3, c0 = < hs2, hs3 >, (((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))∧ Fun((c0 \\ { ∅ })))→ hs0 = hs1))\n  impcomd(c0 = < hs2, hs3 >, (hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0)), Fun((c0 \\ { ∅ })), hs0 = hs1)\n  sylbid(c0 = < hs2, hs3 >, Fun((c0 \\ { ∅ })), ((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))→ hs0 = hs1), Fun((< hs2, hs3 > \\ { ∅ })))\n  funeqd((c0 \\ { ∅ }), (< hs2, hs3 > \\ { ∅ }), c0 = < hs2, hs3 >)\n  difeq1(c0, < hs2, hs3 >, { ∅ })\n  syl5bi(c0 = < hs2, hs3 >, Fun((< hs2, hs3 > \\ { ∅ })), ((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))→ hs0 = hs1), Fun(< hs2, hs3 >))\n  funeqi((< hs2, hs3 > \\ { ∅ }), < hs2, hs3 >)\n  eqcomi((< hs2, hs3 > \\ { ∅ }), < hs2, hs3 >)\n  opwo0id(hs2, hs3)\n  com23(c0 = < hs2, hs3 >, Fun(< hs2, hs3 >), (hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0)), hs0 = hs1)\n  syl6bi(c0 = < hs2, hs3 >, (hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0)), (Fun(< hs2, hs3 >)→ hs0 = hs1), (hs0 ∈ dom(< hs2, hs3 >)∧ hs1 ∈ dom(< hs2, hs3 >)))\n  anbi12d(c0 = < hs2, hs3 >, hs0 ∈ dom(c0), hs1 ∈ dom(c0), hs0 ∈ dom(< hs2, hs3 >), hs1 ∈ dom(< hs2, hs3 >))\n  eleq2d(hs0, dom(c0), dom(< hs2, hs3 >), c0 = < hs2, hs3 >)\n  eleq2d(hs1, dom(c0), dom(< hs2, hs3 >), c0 = < hs2, hs3 >)\n  dmeq(c0, < hs2, hs3 >)\n  expcom((hs0 ∈ dom(< hs2, hs3 >)∧ hs1 ∈ dom(< hs2, hs3 >)), Fun(< hs2, hs3 >), hs0 = hs1)\n  3expb(Fun(< hs2, hs3 >), hs0 ∈ dom(< hs2, hs3 >), hs1 ∈ dom(< hs2, hs3 >), hs0 = hs1)\n  funopdmsn(< hs2, hs3 >, hs0, hs1, hs2, hs3, universe, universe)\n  eqid(< hs2, hs3 >)\n  vex(hs2)\n  vex(hs3)\n  prcnel(c0, (𝕌 × 𝕌))\n  diff.hs0.s(hs1)\n  diff.hs0.c(dom(c0))\n  diff.hs0.c(universe)\n  diff.hs1.c(dom(c0))\n  diff.hs1.c(universe)\n  diff.hs0.w((Fun((c0 \\ { ∅ }))→ ¬ c0 ∈(𝕌 × 𝕌)))\n  diff.hs1.w((Fun((c0 \\ { ∅ }))→ ¬ c0 ∈(𝕌 × 𝕌)))\n  diff.hs2.s(hs3)\n  diff.hs2.c(c0)\n  diff.hs3.c(c0)\n  diff.hs2.w((((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))∧ Fun((c0 \\ { ∅ })))→ hs0 = hs1))\n  diff.hs3.w((((hs0 ∈ dom(c0)∧ hs1 ∈ dom(c0))∧ Fun((c0 \\ { ∅ })))→ hs0 = hs1))\n}","parent":["pm2.61d1","imp","com13","syl6","syl","dmexg","ex","hashge2el2dif","rexlimivv","syl5bi","df-ne","com23","con3d","elvv","com12","exlimivv","impcomd","sylbid","funeqd","difeq1","funeqi","eqcomi","opwo0id","syl6bi","anbi12d","eleq2d","dmeq","expcom","3expb","funopdmsn","eqid","vex","prcnel","diff.hs0.s","diff.hs0.c","diff.hs1.c","diff.hs0.w","diff.hs1.w","diff.hs2.s","diff.hs2.c","diff.hs3.c","diff.hs2.w","diff.hs3.w"],"children":["fundmge2nop","fun2dmnop0","funvtxdmge2val","funiedgdmge2val"]},{"name":"fundmge2nop","content":"A function with a domain containing (at least) two different elements is not an ordered pair. (Contributed by AV, 12-Oct-2020.) (Proof shortened by AV, 9-Jun-2021.)","origin":"thm fundmge2nop(class c0) {\n  |- wi(wa(wfun(c0), wbr(nat2, cle, cfv(chash, cdm(c0)))), wn(wcel(c0, cxp(universe, universe))))\n} = {\n  sylan(wfun(c0), wbr(nat2, cle, cfv(chash, cdm(c0))), wn(wcel(c0, cxp(universe, universe))), wfun(cdif(c0, csn(emptycls))))\n  fundif(c0, csn(emptycls))\n  fundmge2nop0(c0)\n}","pretty":"thm fundmge2nop(class c0) {\n  ⊢ ((Fun(c0)∧ 2[≤](# ` dom(c0)))→ ¬ c0 ∈(𝕌 × 𝕌))\n} = {\n  sylan(Fun(c0), 2[≤](# ` dom(c0)), ¬ c0 ∈(𝕌 × 𝕌), Fun((c0 \\ { ∅ })))\n  fundif(c0, { ∅ })\n  fundmge2nop0(c0)\n}","parent":["sylan","fundif","fundmge2nop0"],"children":[]},{"name":"fun2dmnop0","content":"A function with a domain containing (at least) two different elements is not an ordered pair. This stronger version of ~ fun2dmnop (with the less restrictive requirement that ` ( G \\ { (/) } ) ` needs to be a function instead of ` G ` ) is useful for proofs for extensible structures, see ~ structn0fun . (Contributed by AV, 21-Sep-2020.) (Revised by AV, 7-Jun-2021.)","origin":"thm fun2dmnop0(class c0, class c1, class c2) {\n  |- wi(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wn(wcel(c0, cxp(universe, universe))))\n  -| wcel(c1, universe)\n  -| wcel(c2, universe)\n} = {\n  pm2.61d1(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wn(wcel(c0, cxp(universe, universe))), wcel(c0, universe))\n  ex(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wcel(c0, universe), wn(wcel(c0, cxp(universe, universe))))\n  syl2anc(wa(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wcel(c0, universe)), wn(wcel(c0, cxp(universe, universe))), wfun(cdif(c0, csn(emptycls))), wbr(nat2, cle, cfv(chash, cdm(c0))))\n  simpl1(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0)), wcel(c0, universe))\n  nehash2(cdm(c0), universe, c1, c2, wa(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wcel(c0, universe)))\n  adantl(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wcel(c0, universe), wcel(cdm(c0), universe))\n  dmexg(c0, universe)\n  adantr(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wcel(c0, universe), wcel(c1, cdm(c0)))\n  3ad2ant3(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0)), wcel(c1, cdm(c0)))\n  sylbir(wss(cpr(c1, c2), cdm(c0)), wcel(c1, cdm(c0)), wa(wcel(c1, cdm(c0)), wcel(c2, cdm(c0))))\n  simpl(wcel(c1, cdm(c0)), wcel(c2, cdm(c0)))\n  adantr(w3a(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wcel(c0, universe), wcel(c2, cdm(c0)))\n  3ad2ant3(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0)), wcel(c2, cdm(c0)))\n  sylbir(wss(cpr(c1, c2), cdm(c0)), wcel(c2, cdm(c0)), wa(wcel(c1, cdm(c0)), wcel(c2, cdm(c0))))\n  prss(c1, cdm(c0), c2)\n  simpr(wcel(c1, cdm(c0)), wcel(c2, cdm(c0)))\n  simpl2(wfun(cdif(c0, csn(emptycls))), wne(c1, c2), wss(cpr(c1, c2), cdm(c0)), wcel(c0, universe))\n  fundmge2nop0(c0)\n  prcnel(c0, cxp(universe, universe))\n}","pretty":"thm fun2dmnop0(class c0, class c1, class c2) {\n  ⊢ ((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0))→ ¬ c0 ∈(𝕌 × 𝕌))\n  ⊣ c1 ∈ 𝕌\n  ⊣ c2 ∈ 𝕌\n} = {\n  pm2.61d1((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0)), ¬ c0 ∈(𝕌 × 𝕌), c0 ∈ 𝕌)\n  ex((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0)), c0 ∈ 𝕌, ¬ c0 ∈(𝕌 × 𝕌))\n  syl2anc(((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0))∧ c0 ∈ 𝕌), ¬ c0 ∈(𝕌 × 𝕌), Fun((c0 \\ { ∅ })), 2[≤](# ` dom(c0)))\n  simpl1(Fun((c0 \\ { ∅ })), c1 ≠ c2, { c1, c2 } ⊆ dom(c0), c0 ∈ 𝕌)\n  nehash2(dom(c0), universe, c1, c2, ((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0))∧ c0 ∈ 𝕌))\n  adantl((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0)), c0 ∈ 𝕌, dom(c0)∈ 𝕌)\n  dmexg(c0, universe)\n  adantr((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0)), c0 ∈ 𝕌, c1 ∈ dom(c0))\n  3ad2ant3(Fun((c0 \\ { ∅ })), c1 ≠ c2, { c1, c2 } ⊆ dom(c0), c1 ∈ dom(c0))\n  sylbir({ c1, c2 } ⊆ dom(c0), c1 ∈ dom(c0), (c1 ∈ dom(c0)∧ c2 ∈ dom(c0)))\n  simpl(c1 ∈ dom(c0), c2 ∈ dom(c0))\n  adantr((Fun((c0 \\ { ∅ }))∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0)), c0 ∈ 𝕌, c2 ∈ dom(c0))\n  3ad2ant3(Fun((c0 \\ { ∅ })), c1 ≠ c2, { c1, c2 } ⊆ dom(c0), c2 ∈ dom(c0))\n  sylbir({ c1, c2 } ⊆ dom(c0), c2 ∈ dom(c0), (c1 ∈ dom(c0)∧ c2 ∈ dom(c0)))\n  prss(c1, dom(c0), c2)\n  simpr(c1 ∈ dom(c0), c2 ∈ dom(c0))\n  simpl2(Fun((c0 \\ { ∅ })), c1 ≠ c2, { c1, c2 } ⊆ dom(c0), c0 ∈ 𝕌)\n  fundmge2nop0(c0)\n  prcnel(c0, (𝕌 × 𝕌))\n}","parent":["pm2.61d1","ex","syl2anc","simpl1","nehash2","adantl","dmexg","adantr","3ad2ant3","sylbir","simpl","prss","simpr","simpl2","fundmge2nop0","prcnel"],"children":["fun2dmnop","funvtxdm2val","funiedgdm2val"]},{"name":"fun2dmnop","content":"A function with a domain containing (at least) two different elements is not an ordered pair. (Contributed by AV, 21-Sep-2020.) (Proof shortened by AV, 9-Jun-2021.)","origin":"thm fun2dmnop(class c0, class c1, class c2) {\n  |- wi(w3a(wfun(c0), wne(c1, c2), wss(cpr(c1, c2), cdm(c0))), wn(wcel(c0, cxp(universe, universe))))\n  -| wcel(c1, universe)\n  -| wcel(c2, universe)\n} = {\n  syl3an1(wfun(c0), wne(c1, c2), wss(cpr(c1, c2), cdm(c0)), wn(wcel(c0, cxp(universe, universe))), wfun(cdif(c0, csn(emptycls))))\n  fundif(c0, csn(emptycls))\n  fun2dmnop0(c0, c1, c2)\n}","pretty":"thm fun2dmnop(class c0, class c1, class c2) {\n  ⊢ ((Fun(c0)∧ c1 ≠ c2 ∧ { c1, c2 } ⊆ dom(c0))→ ¬ c0 ∈(𝕌 × 𝕌))\n  ⊣ c1 ∈ 𝕌\n  ⊣ c2 ∈ 𝕌\n} = {\n  syl3an1(Fun(c0), c1 ≠ c2, { c1, c2 } ⊆ dom(c0), ¬ c0 ∈(𝕌 × 𝕌), Fun((c0 \\ { ∅ })))\n  fundif(c0, { ∅ })\n  fun2dmnop0(c0, c1, c2)\n}","parent":["syl3an1","fundif","fun2dmnop0"],"children":[]}]}