{"index":1138,"title":"Eliminability of class terms","content":"In this section, we give a sketch of the proof of the Eliminability Theorem for class terms in an extensional set theory where quantification occurs only over set variables. Eliminability of class variables using the $a-statements ~ ax-ext , ~ df-clab , ~ df-cleq , ~ df-clel is an easy result, proved for instance in Appendix X of Azriel Levy, _Basic Set Theory_, Dover Publications, 2002. Note that viewed from the set.mm axiomatization, it is a metatheorem not formalizable is set.mm. It states: every formula in the language of FOL + ` e. ` + class terms, but without class variables, is provably equivalent (over {FOL, ~ ax-ext , ~ df-clab , ~ df-cleq , ~ df-clel }) to a formula in the language of FOL + ` e. ` (that is, without class terms). The proof goes by induction on the complexity of the formula (see op. cit. for details). The base case is that of atomic formulas. The atomic formulas containing class terms are of one of the following forms: for equality, ` x = { y | ph } ` , ` { x | ph } = y ` , ` { x | ph } = { y | ps } ` , and for membership, ` y e. { x | ph } ` , ` { x | ph } e. y ` , ` { x | ph } e. { y | ps } ` . These cases are dealt with by ~ eliminable1 and the following theorems of this section, which are special instances of ~ df-clab , ~ dfcleq (proved from {FOL, ~ ax-ext , ~ df-cleq }), and ~ df-clel . Indeed, denote by (i) the formula proved by \"eliminablei\". One sees that the RHS of (1) has no class terms, the RHS's of (2x) have only class terms of the form dealt with by (1), and the RHS's of (3x) have only class terms of the forms dealt with by (1) and (2a). Note that in order to prove ~ eliminable2a , ~ eliminable2b and ~ eliminable3a , we need to substitute a class variable for a setvar variable. This is possible because setvars are class terms: this is the content of the syntactic theorem ~ cv , which is used in these proofs (this does not appear in the html pages but it is in the set.mm file and you can check it using the Metamath program). The induction step relies on the fact that any formula is a FOL-combination of atomic formulas, so if one found equivalents for all atomic formulas constituting the formula, then the same FOL-combination of these equivalents will be equivalent to the original formula. Note that one has a slightly more precise result: if the original formula has only class terms appearing in atomic formulas of the form ` y e. { x | ph } ` , then ~ df-clab is sufficient (over FOL) to eliminate class terms, and if the original formula has only class terms appearing in atomic formulas of the form ` y e. { x | ph } ` and equalities, then ~ df-clab , ~ ax-ext and ~ df-cleq are sufficient (over FOL) to eliminate class terms. To prove that { ~ df-clab , ~ df-cleq , ~ df-clel } provides a definitional extension of {FOL, ~ ax-ext }, one needs to prove the above Eliminability Theorem, which compares the expressive powers of the languages with and without class terms, and the Conservativity Theorem, which compares the deductive powers when one adds { ~ df-clab , ~ df-cleq , ~ df-clel }. It states that a formula without class terms is provable in one axiom system if and only if it is provable in the other, and that this remains true when one adds further definitions to {FOL, ~ ax-ext }. It is also proved in op. cit. The proof is more difficult, since one has to construct for each proof of a statement without class terms, an associated proof not using { ~ df-clab , ~ df-cleq , ~ df-clel }. It involves a careful case study on the structure of the proof tree.","blocks":[{"name":"eliminable1","content":"A theorem used to prove the base case of the Eliminability Theorem (see section comment). (Contributed by BJ, 19-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm eliminable1(setvar s0, setvar s1, wff w0) {\n  |- wb(wcel(cv(s0), cab(s1, w0)), wsb(s0, s1, w0))\n} = {\n  df-clab(s0, s1, w0)\n}","pretty":"thm eliminable1(setvar s0, setvar s1, wff w0) {\n  ⊢ (s0 ∈ { s1 | w0 } ↔[s0 / s1]w0)\n} = {\n  df-clab(s0, s1, w0)\n}","parent":["df-clab"],"children":[]},{"name":"eliminable2a","content":"A theorem used to prove the base case of the Eliminability Theorem (see section comment). (Contributed by BJ, 19-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm eliminable2a(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wceq(cv(s0), cab(s1, w0)), wal(s2, wb(wcel(cv(s2), cv(s0)), wcel(cv(s2), cab(s1, w0)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsw(s2, w0)\n} = {\n  dfcleq(s2, cv(s0), cab(s1, w0))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cab.s(s2, s1, w0)\n  diffss.ex(s2, s1)\n}","pretty":"thm eliminable2a(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ (s0 = { s1 | w0 } ↔ ∀(s2,(s2 ∈ s0 ↔ s2 ∈ { s1 | w0 })))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s2, w0)\n} = {\n  dfcleq(s2, s0, { s1 | w0 })\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cab.s(s2, s1, w0)\n  diffss.ex(s2, s1)\n}","parent":["dfcleq","diff.cv.s","diffss.ex","diff.cab.s"],"children":[]},{"name":"eliminable2b","content":"A theorem used to prove the base case of the Eliminability Theorem (see section comment). (Contributed by BJ, 19-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm eliminable2b(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wceq(cab(s0, w0), cv(s1)), wal(s2, wb(wcel(cv(s2), cab(s0, w0)), wcel(cv(s2), cv(s1)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsw(s2, w0)\n} = {\n  dfcleq(s2, cab(s0, w0), cv(s1))\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm eliminable2b(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ ({ s0 | w0 } = s1 ↔ ∀(s2,(s2 ∈ { s0 | w0 } ↔ s2 ∈ s1)))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s2, w0)\n} = {\n  dfcleq(s2, { s0 | w0 }, s1)\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["dfcleq","diff.cab.s","diffss.ex","diff.cv.s"],"children":[]},{"name":"eliminable2c","content":"A theorem used to prove the base case of the Eliminability Theorem (see section comment). (Contributed by BJ, 19-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm eliminable2c(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  |- wb(wceq(cab(s0, w0), cab(s1, w1)), wal(s2, wb(wcel(cv(s2), cab(s0, w0)), wcel(cv(s2), cab(s1, w1)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsw(s2, w0)\n  -| diffsw(s2, w1)\n} = {\n  dfcleq(s2, cab(s0, w0), cab(s1, w1))\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cab.s(s2, s1, w1)\n  diffss.ex(s2, s1)\n}","pretty":"thm eliminable2c(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  ⊢ ({ s0 | w0 } = { s1 | w1 } ↔ ∀(s2,(s2 ∈ { s0 | w0 } ↔ s2 ∈ { s1 | w1 })))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s2, w0)\n  ⊣ d(s2, w1)\n} = {\n  dfcleq(s2, { s0 | w0 }, { s1 | w1 })\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cab.s(s2, s1, w1)\n  diffss.ex(s2, s1)\n}","parent":["dfcleq","diff.cab.s","diffss.ex"],"children":[]},{"name":"eliminable3a","content":"A theorem used to prove the base case of the Eliminability Theorem (see section comment). (Contributed by BJ, 19-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm eliminable3a(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wcel(cab(s0, w0), cv(s1)), wex(s2, wa(wceq(cv(s2), cab(s0, w0)), wcel(cv(s2), cv(s1)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsw(s2, w0)\n} = {\n  df-clel(s2, cab(s0, w0), cv(s1))\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm eliminable3a(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ ({ s0 | w0 } ∈ s1 ↔ ∃(s2,(s2 = { s0 | w0 } ∧ s2 ∈ s1)))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s2, w0)\n} = {\n  df-clel(s2, { s0 | w0 }, s1)\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["df-clel","diff.cab.s","diffss.ex","diff.cv.s"],"children":[]},{"name":"eliminable3b","content":"A theorem used to prove the base case of the Eliminability Theorem (see section comment). (Contributed by BJ, 19-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm eliminable3b(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  |- wb(wcel(cab(s0, w0), cab(s1, w1)), wex(s2, wa(wceq(cv(s2), cab(s0, w0)), wcel(cv(s2), cab(s1, w1)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsw(s2, w0)\n  -| diffsw(s2, w1)\n} = {\n  df-clel(s2, cab(s0, w0), cab(s1, w1))\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cab.s(s2, s1, w1)\n  diffss.ex(s2, s1)\n}","pretty":"thm eliminable3b(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  ⊢ ({ s0 | w0 } ∈ { s1 | w1 } ↔ ∃(s2,(s2 = { s0 | w0 } ∧ s2 ∈ { s1 | w1 })))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s2, w0)\n  ⊣ d(s2, w1)\n} = {\n  df-clel(s2, { s0 | w0 }, { s1 | w1 })\n  diff.cab.s(s2, s0, w0)\n  diffss.ex(s2, s0)\n  diff.cab.s(s2, s1, w1)\n  diffss.ex(s2, s1)\n}","parent":["df-clel","diff.cab.s","diffss.ex"],"children":[]},{"name":"bj-termab","content":"Every class can be written as (is equal to) a class abstraction. ~ cvjust is a special instance of it, but the present proof does not require ~ ax-13 , contrary to ~ cvjust . This theorem requires ~ ax-ext , ~ df-clab , ~ df-cleq , ~ df-clel , but to prove that any specific class term not containing class variables is a setvar or can be written as (is equal to) a class abstraction does not require these $a-statements. This last fact is a metatheorem, consequence of the fact that the only $a-statements with typecode ` class ` are ~ cv , ~ cab and statements corresponding to defined class constructors. UPDATE: This theorem is (almost) ~ abid2 and ~ bj-abid2 , though the present proof is shorter than a proof from ~ bj-abid2 and ~ eqcomi (and is shorter than the proof of either); plus, it is of the same form as ~ cvjust and such a basic statement deserves to be present in both forms. Note that ~ bj-termab shortens the proof of ~ abid2 , and shortens five proofs by a total of 72 bytes. Move it to Main as \"abid1\" proved from ~ abbi2i ? Note also that this is the form in Quine, more than ~ abid2 . (Contributed by BJ, 21-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-termab(setvar s0, class c0) {\n  |- wceq(c0, cab(s0, wcel(cv(s0), c0)))\n  -| diffsc(s0, c0)\n} = {\n  bj-abbi2i(s0, c0, wcel(cv(s0), c0))\n  biid(wcel(cv(s0), c0))\n}","pretty":"thm bj-termab(setvar s0, class c0) {\n  ⊢ c0 = { s0 | s0 ∈ c0 }\n  ⊣ d(s0, c0)\n} = {\n  bj-abbi2i(s0, c0, s0 ∈ c0)\n  biid(s0 ∈ c0)\n}","parent":["bj-abbi2i","biid"],"children":[]}]}