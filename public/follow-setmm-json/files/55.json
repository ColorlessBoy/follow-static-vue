{"index":55,"title":"Axiom scheme ax-7 (Equality)","content":"","blocks":[{"name":"ax-7","content":"Axiom of Equality. One of the equality and substitution axioms of predicate calculus with equality. It states that equality is a right-Euclidean binary relation (this is similar, but not identical, to being transitive, which is proved as ~ equtr ). This axiom scheme is a sub-scheme of Axiom Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our notation. Also appears as Axiom C7 of [Monk2] p. 105 and Axiom Scheme C8' in [Megill] p. 448 (p. 16 of the preprint). The equality symbol was invented in 1557 by Robert Recorde. He chose a pair of parallel lines of the same length because \"noe .2. thynges, can be moare equalle\". We prove in ~ ax7 that this axiom can be recovered from its weakened version ~ ax7v where ` x ` and ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-7 should be ~ ax7v . See the comment of ~ ax7v for more details on these matters. (Contributed by NM, 10-Jan-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax7 instead. (New usage is discouraged.)","origin":"axiom ax-7(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2))))\n}","pretty":"axiom ax-7(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 = s2 → s1 = s2))\n}","parent":[],"children":["ax7v"]},{"name":"ax7v","content":"Weakened version of ~ ax-7 , with a disjoint variable condition on ` x , y ` . This should be the only proof referencing ~ ax-7 , and it should be referenced only by its two weakened versions ~ ax7v1 and ~ ax7v2 , from which ~ ax-7 is then rederived as ~ ax7 , which shows that either ~ ax7v or the conjunction of ~ ax7v1 and ~ ax7v2 is sufficient. In ~ ax7v , it is still allowed to substitute the same variable for ` x ` and ` z ` , or the same variable for ` y ` and ` z ` . Therefore, ~ ax7v \"bundles\" (a term coined by Raph Levien) its \"principal instance\" ` ( x = y -> ( x = z -> y = z ) ) ` with ` x , y , z ` distinct, and its \"degenerate instances\" ` ( x = y -> ( x = x -> y = x ) ) ` and ` ( x = y -> ( x = y -> y = y ) ) ` with ` x , y ` distinct. These degenerate instances are for instance used in the proofs of ~ equcomiv and ~ equid respectively. (Contributed by BJ, 7-Dec-2020.) Use ~ ax7 instead. (New usage is discouraged.)","origin":"thm ax7v(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2))))\n  -| diffss(s0, s1)\n} = {\n  a1ii(wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))), diffss(s0, s1))\n  ax-7(s0, s1, s2)\n}","pretty":"thm ax7v(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 = s2 → s1 = s2))\n  ⊣ d(s0, s1)\n} = {\n  a1ii((s0 = s1 →(s0 = s2 → s1 = s2)), d(s0, s1))\n  ax-7(s0, s1, s2)\n}","parent":["a1ii","ax-7"],"children":["ax7v1","ax7v2"]},{"name":"ax7v1","content":"First of two weakened versions of ~ ax7v , with an extra disjoint variable condition on ` x , z ` , see comments there. (Contributed by BJ, 7-Dec-2020.)","origin":"thm ax7v1(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n} = {\n  a1ii(wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))), diffss(s0, s2))\n  ax7v(s0, s1, s2)\n}","pretty":"thm ax7v1(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 = s2 → s1 = s2))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n} = {\n  a1ii((s0 = s1 →(s0 = s2 → s1 = s2)), d(s0, s2))\n  ax7v(s0, s1, s2)\n}","parent":["a1ii","ax7v"],"children":["equid","ax7","ax13"]},{"name":"ax7v2","content":"Second of two weakened versions of ~ ax7v , with an extra disjoint variable condition on ` y , z ` , see comments there. (Contributed by BJ, 7-Dec-2020.)","origin":"thm ax7v2(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2))))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n} = {\n  a1ii(wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))), diffss(s1, s2))\n  ax7v(s0, s1, s2)\n}","pretty":"thm ax7v2(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 = s2 → s1 = s2))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, s2)\n} = {\n  a1ii((s0 = s1 →(s0 = s2 → s1 = s2)), d(s1, s2))\n  ax7v(s0, s1, s2)\n}","parent":["a1ii","ax7v"],"children":["equcomiv","ax7","wl-cbvmotv"]},{"name":"equid","content":"Identity law for equality. Lemma 2 of [KalishMontague] p. 85. See also Lemma 6 of [Tarski] p. 68. (Contributed by NM, 1-Apr-2005.) (Revised by NM, 9-Apr-2017.) (Proof shortened by Wolf Lammen, 22-Aug-2020.)","origin":"thm equid(setvar s0) {\n  |- wceq(cv(s0), cv(s0))\n} = {\n  exlimiiv(hs0, wceq(cv(s0), cv(s0)), wceq(cv(hs0), cv(s0)))\n  pm2.43i(wceq(cv(hs0), cv(s0)), wceq(cv(s0), cv(s0)))\n  ax7v1(hs0, s0, s0)\n  ax6ev(hs0, s0)\n  diff.hs0.w(wceq(cv(s0), cv(s0)))\n  diff.hs0.s(s0)\n}","pretty":"thm equid(setvar s0) {\n  ⊢ s0 = s0\n} = {\n  exlimiiv(hs0, s0 = s0, hs0 = s0)\n  pm2.43i(hs0 = s0, s0 = s0)\n  ax7v1(hs0, s0, s0)\n  ax6ev(hs0, s0)\n  diff.hs0.w(s0 = s0)\n  diff.hs0.s(s0)\n}","parent":["exlimiiv","pm2.43i","ax7v1","ax6ev","diff.hs0.w","diff.hs0.s"],"children":["nfequid","equcomiv","equcomi","stdpc6","equsb1v","ax6dgen","ax13dgen1","ax13dgen3","sbid","exists1","vjust","vex","reu6","sbc8g","dfnul2","dfnul3","dfid3","isso2i","relop","iotanul","f1eqcocnv","fsplit","mpt2xopoveq","ruv","dfac2b","konigthlem","hash2prde","hashge2el2difr","pospo","mamulid","mdetdiagid","alexsubALTlem3","trust","isppw2","xmstrkgc","avril1","sa-abvi","domep","wlimeq12","frecseq123","bj-ssbid2","bj-ssbid1","mptsnunlem","ax12eq","elnev","ipo0","ifr0","tratrb","tratrbVD","unirnmapsn","hspmbl"]},{"name":"nfequid","content":"Bound-variable hypothesis builder for ` x = x ` . This theorem tells us that any variable, including ` x ` , is effectively not free in ` x = x ` , even though ` x ` is technically free according to the traditional definition of free variable. (Contributed by NM, 13-Jan-2011.) (Revised by NM, 21-Aug-2017.)","origin":"thm nfequid(setvar s0, setvar s1) {\n  |- wnf(s0, wceq(cv(s1), cv(s1)))\n} = {\n  nfth(s0, wceq(cv(s1), cv(s1)))\n  equid(s1)\n}","pretty":"thm nfequid(setvar s0, setvar s1) {\n  ⊢ F/(s0, s1 = s1)\n} = {\n  nfth(s0, s1 = s1)\n  equid(s1)\n}","parent":["nfth","equid"],"children":[]},{"name":"equcomiv","content":"Weaker form of ~ equcomi with a disjoint variable condition on ` x , y ` . This is an intermediate step and ~ equcomi is fully recovered later. (Contributed by BJ, 7-Dec-2020.)","origin":"thm equcomiv(setvar s0, setvar s1) {\n  |- wi(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s0)))\n  -| diffss(s0, s1)\n} = {\n  mpi(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s0)), wceq(cv(s0), cv(s0)))\n  equid(s0)\n  ax7v2(s0, s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm equcomiv(setvar s0, setvar s1) {\n  ⊢ (s0 = s1 → s1 = s0)\n  ⊣ d(s0, s1)\n} = {\n  mpi(s0 = s1, s1 = s0, s0 = s0)\n  equid(s0)\n  ax7v2(s0, s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["mpi","equid","ax7v2","diffss.ex"],"children":["ax6evr"]},{"name":"ax6evr","content":"A commuted form of ~ ax6ev . (Contributed by BJ, 7-Dec-2020.)","origin":"thm ax6evr(setvar s0, setvar s1) {\n  |- wex(s0, wceq(cv(s1), cv(s0)))\n  -| diffss(s0, s1)\n} = {\n  eximii(s0, wceq(cv(s1), cv(s0)), wceq(cv(s0), cv(s1)))\n  ax6ev(s0, s1)\n  equcomiv(s0, s1)\n}","pretty":"thm ax6evr(setvar s0, setvar s1) {\n  ⊢ ∃(s0, s1 = s0)\n  ⊣ d(s0, s1)\n} = {\n  eximii(s0, s1 = s0, s0 = s1)\n  ax6ev(s0, s1)\n  equcomiv(s0, s1)\n}","parent":["eximii","ax6ev","equcomiv"],"children":["ax7","equvinva","ax12v2","19.8a","axc11n","eu6lem","eu6OLD","euequOLD","axprlem3","relopabi","relop","elridOLD","bj-ax6e","axc11n11r","wl-spae"]},{"name":"ax7","content":"Proof of ~ ax-7 from ~ ax7v1 and ~ ax7v2 (and earlier axioms), proving sufficiency of the conjunction of the latter two weakened versions of ~ ax7v , which is itself a weakened version of ~ ax-7 . Note that the weakened version of ~ ax-7 obtained by adding a disjoint variable condition on ` x , z ` (resp. on ` y , z ` ) does not permit, together with the other axioms, to prove reflexivity (resp. symmetry). (Contributed by BJ, 7-Dec-2020.)","origin":"thm ax7(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2))))\n} = {\n  ex(wceq(cv(s0), cv(s1)), wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))\n  exlimiiv(hs0, wi(wa(wceq(cv(s0), cv(s1)), wceq(cv(s0), cv(s2))), wceq(cv(s1), cv(s2))), wceq(cv(s0), cv(hs0)))\n  syl2and(wceq(cv(s0), cv(hs0)), wceq(cv(s0), cv(s1)), wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)), wceq(cv(hs0), cv(s1)), wceq(cv(hs0), cv(s2)))\n  ax7v2(s0, hs0, s1)\n  ax7v2(s0, hs0, s2)\n  a1i(wceq(cv(s0), cv(hs0)), wi(wa(wceq(cv(hs0), cv(s1)), wceq(cv(hs0), cv(s2))), wceq(cv(s1), cv(s2))))\n  imp(wceq(cv(hs0), cv(s1)), wceq(cv(hs0), cv(s2)), wceq(cv(s1), cv(s2)))\n  ax7v1(hs0, s1, s2)\n  ax6evr(hs0, s0)\n  diff.hs0.w(wi(wa(wceq(cv(s0), cv(s1)), wceq(cv(s0), cv(s2))), wceq(cv(s1), cv(s2))))\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s1)\n  diff.hs0.s(s2)\n  diff.hs0.s(s0)\n}","pretty":"thm ax7(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 = s2 → s1 = s2))\n} = {\n  ex(s0 = s1, s0 = s2, s1 = s2)\n  exlimiiv(hs0, ((s0 = s1 ∧ s0 = s2)→ s1 = s2), s0 = hs0)\n  syl2and(s0 = hs0, s0 = s1, s0 = s2, s1 = s2, hs0 = s1, hs0 = s2)\n  ax7v2(s0, hs0, s1)\n  ax7v2(s0, hs0, s2)\n  a1i(s0 = hs0, ((hs0 = s1 ∧ hs0 = s2)→ s1 = s2))\n  imp(hs0 = s1, hs0 = s2, s1 = s2)\n  ax7v1(hs0, s1, s2)\n  ax6evr(hs0, s0)\n  diff.hs0.w(((s0 = s1 ∧ s0 = s2)→ s1 = s2))\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s1)\n  diff.hs0.s(s2)\n  diff.hs0.s(s0)\n}","parent":["ex","exlimiiv","syl2and","ax7v2","a1i","imp","ax7v1","ax6evr","diff.hs0.w","diffss.ex","diff.hs0.s"],"children":["equcomi","equtr","equequ1","cbvaev","aeveq","axc16i","equvel","axext3","dtru","axextnd","bj-dtru","wl-aetr","wl-exeq","wl-aleq","wl-nfeqfb","equcomi1","hbequid","equidqe","aev-o","ax6e2eq","ax6e2eqVD","2reu8i"]},{"name":"equcomi","content":"Commutative law for equality. Equality is a symmetric relation. Lemma 3 of [KalishMontague] p. 85. See also Lemma 7 of [Tarski] p. 69. (Contributed by NM, 10-Jan-1993.) (Revised by NM, 9-Apr-2017.)","origin":"thm equcomi(setvar s0, setvar s1) {\n  |- wi(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s0)))\n} = {\n  mpi(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s0)), wceq(cv(s0), cv(s0)))\n  equid(s0)\n  ax7(s0, s1, s0)\n}","pretty":"thm equcomi(setvar s0, setvar s1) {\n  ⊢ (s0 = s1 → s1 = s0)\n} = {\n  mpi(s0 = s1, s1 = s0, s0 = s0)\n  equid(s0)\n  ax7(s0, s1, s0)\n}","parent":["mpi","equid","ax7"],"children":["equcom","equcoms","ax13dgen2","sbequ2","cbv2h","axc16i","equsb2","axsep","rext","soxp","axextnd","prodmo","mpt2matmul","finminlem","bj-ssbid2ALT","axc11n11","axc11n11r","bj-cbv2hv","bj-axsep","ax6er","wl-axc11rc11","poimirlem25","axc11nfromc11","aev-o"]},{"name":"equcom","content":"Commutative law for equality. Equality is a symmetric relation. (Contributed by NM, 20-Aug-1993.)","origin":"thm equcom(setvar s0, setvar s1) {\n  |- wb(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s0)))\n} = {\n  impbii(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s0)))\n  equcomi(s0, s1)\n  equcomi(s1, s0)\n}","pretty":"thm equcom(setvar s0, setvar s1) {\n  ⊢ (s0 = s1 ↔ s1 = s0)\n} = {\n  impbii(s0 = s1, s1 = s0)\n  equcomi(s0, s1)\n  equcomi(s1, s0)\n}","parent":["impbii","equcomi"],"children":["equcomd","equsb3r","dvelimhw","nfeqf1","eu1","eu1OLD","reu7","reu8","dfdif3","issn","iunid","disjxun","copsexg","opelopabsbALT","dfid3","dfid4","opeliunxp","dmi","elidinxp","opabresid","asymref2","intirr","cnvi","coi1","cnvso","iotaval","brprcneu","dffv2","fvn0ssdmfun","f1oiso","qsid","mapsnend","marypha2lem2","fiinfg","dfac5lem2","dfac5lem3","kmlem15","brdom7disj","suplem2pr","wloglei","fimaxre","fimaxreOLD","arch","dflt2","hashgt12el","hashge2el2dif","summo","tosso","opsrtoslem1","mamulid","mpt2matmul","mattpos1","scmatscm","1marepvmarrepid","ist1-3","unisngl","fmid","tgphaus","dscopn","iundisj2","dvlip","ply1divmo","disjabrex","disjabrexf","iundisj2f","iundisj2fi","ordtconnlem1","dfdm5","dfrn5","dffun10","elfuns","dfiota3","brimg","dfrdg4","nn0prpwlem","wl-equsalcom","wl-dfralflem","matunitlindflem2","pmapglb","polval2N","diclspsn","eq0rabdioph","undmrnresiss","relopabVD","icheq","ichexmpl1","opeliun2xp","itsclquadeu"]},{"name":"equcomd","content":"Deduction form of ~ equcom , symmetry of equality. For the versions for classes, see ~ eqcom and ~ eqcomd . (Contributed by BJ, 6-Oct-2019.)","origin":"thm equcomd(setvar s0, setvar s1, wff w0) {\n  |- wi(w0, wceq(cv(s0), cv(s1)))\n  -| wi(w0, wceq(cv(s1), cv(s0)))\n} = {\n  sylib(w0, wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s0)))\n  equcom(s1, s0)\n}","pretty":"thm equcomd(setvar s0, setvar s1, wff w0) {\n  ⊢ (w0 → s0 = s1)\n  ⊣ (w0 → s1 = s0)\n} = {\n  sylib(w0, s0 = s1, s1 = s0)\n  equcom(s1, s0)\n}","parent":["sylib","equcom"],"children":["sndisj","fsumcom2","fprodcom2","catideu","pospo","dprdfcntz","ordtt1","eengtrkg","cusgrfilem2","frgr2wwlk1","bj-nfcsym","exidu1","rngoideu","2reu8i","sprsymrelf1lem"]},{"name":"equcoms","content":"An inference commuting equality in antecedent. Used to eliminate the need for a syllogism. (Contributed by NM, 10-Jan-1993.)","origin":"thm equcoms(setvar s0, setvar s1, wff w0) {\n  |- wi(wceq(cv(s0), cv(s1)), w0)\n  -| wi(wceq(cv(s1), cv(s0)), w0)\n} = {\n  syl(wceq(cv(s0), cv(s1)), w0, wceq(cv(s1), cv(s0)))\n  equcomi(s0, s1)\n}","pretty":"thm equcoms(setvar s0, setvar s1, wff w0) {\n  ⊢ (s0 = s1 → w0)\n  ⊣ (s1 = s0 → w0)\n} = {\n  syl(s0 = s1, w0, s1 = s0)\n  equcomi(s0, s1)\n}","parent":["syl","equcomi"],"children":["equtr","equeuclr","spfw","cbvalw","alcomiw","ax8","elequ1","ax9","elequ2","stdpc7","sbequ12r","sbequvvOLD","cbvalv1","cbval","cbvalv","sbequOLD","sb9","sbequALT","rabrabi","reu8","sbcco2","reu8nf","sbcop1","opeliunxp","elrnmpt1","elidinxp","fvn0ssdmfun","elabrex","tfisi","tfinds2","opabex3d","opabex3","mpt2curryd","boxriin","ixpiunwdom","elirrv","rabssnn0fi","fproddivf","prmodvdslcmf","1mavmul","ptbasfi","elmptrab","pcoass","iundisj2","dchrisumlema","dchrisumlem2","cusgrfilem2","frgrncvvdeq","frgr2wwlk1","iundisj2f","iundisj2fi","bnj1014","cvmsss2","ax8dfeq","bj-ssbid1ALT","bj-cbvexw","bj-sb","bj-cleljustab","bj-ax9-2","finxpreclem6","wl-nfs1t","wl-equsb4","wl-euequf","wl-ax11-lem8","matunitlindflem1","poimirlem26","mblfinlem2","sdclem2","axc11-o","rexzrexnn0","elabrexg","disjinfi","dvnmptdivc","iblsplitf","vonn0ioo2","vonn0icc2","funressnvmo","funressnvmoOLD","ichcircshi","paireqne","reuopreuprim","uspgrsprf1","opeliun2xp"]},{"name":"equtr","content":"A transitive law for equality. (Contributed by NM, 23-Aug-1993.)","origin":"thm equtr(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s1), cv(s2)), wceq(cv(s0), cv(s2))))\n} = {\n  equcoms(s0, s1, wi(wceq(cv(s1), cv(s2)), wceq(cv(s0), cv(s2))))\n  ax7(s1, s0, s2)\n}","pretty":"thm equtr(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s1 = s2 → s0 = s2))\n} = {\n  equcoms(s0, s1, (s1 = s2 → s0 = s2))\n  ax7(s1, s0, s2)\n}","parent":["equcoms","ax7"],"children":["equtrr","equequ1","equvinva","ax6e","equvini","sbequiOLD","sbequiALT","axsep","axprlem3","bj-axsep"]},{"name":"equtrr","content":"A transitive law for equality. Lemma L17 in [Megill] p. 446 (p. 14 of the preprint). (Contributed by NM, 23-Aug-1993.)","origin":"thm equtrr(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s2), cv(s0)), wceq(cv(s2), cv(s1))))\n} = {\n  com12(wceq(cv(s0), cv(s1)), wceq(cv(s2), cv(s0)), wceq(cv(s2), cv(s1)))\n  equtr(s2, s0, s1)\n}","pretty":"thm equtrr(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s2 = s0 → s2 = s1))\n} = {\n  com12(s0 = s1, s2 = s0, s2 = s1)\n  equtr(s2, s0, s1)\n}","parent":["com12","equtr"],"children":["equeuclr","equequ2","ax12v2","2ax6elem","axprlem3","wl-spae","ax12eq","ax6e2eq","ax6e2eqVD"]},{"name":"equeuclr","content":"Commuted version of ~ equeucl (equality is left-Euclidean). (Contributed by BJ, 12-Apr-2021.)","origin":"thm equeuclr(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s2), cv(s1)), wceq(cv(s2), cv(s0))))\n} = {\n  equcoms(s0, s1, wi(wceq(cv(s2), cv(s1)), wceq(cv(s2), cv(s0))))\n  equtrr(s1, s0, s2)\n}","pretty":"thm equeuclr(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s2 = s1 → s2 = s0))\n} = {\n  equcoms(s0, s1, (s2 = s1 → s2 = s0))\n  equtrr(s1, s0, s2)\n}","parent":["equcoms","equtrr"],"children":["equeucl","equequ2","ax13b","aevlem0","sbequivvOLD","axc15","equvini","sbequiOLD","sbequiALT","euequ"]},{"name":"equeucl","content":"Equality is a left-Euclidean binary relation. (Right-Euclideanness is stated in ~ ax-7 .) Curried (exported) form of ~ equtr2 . (Contributed by BJ, 11-Apr-2021.)","origin":"thm equeucl(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wceq(cv(s2), cv(s1)), wceq(cv(s0), cv(s2))))\n} = {\n  com12(wceq(cv(s0), cv(s1)), wceq(cv(s2), cv(s1)), wceq(cv(s0), cv(s2)))\n  equeuclr(s2, s1, s0)\n}","pretty":"thm equeucl(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s2 = s1 → s0 = s2))\n} = {\n  com12(s0 = s1, s2 = s1, s0 = s2)\n  equeuclr(s2, s1, s0)\n}","parent":["com12","equeuclr"],"children":["equtr2","sbequ1","ax13lem1","ax13lem2","bj-ax6elem2","wl-ax13lem1"]},{"name":"equequ1","content":"An equivalence law for equality. (Contributed by NM, 1-Aug-1993.) (Proof shortened by Wolf Lammen, 10-Dec-2017.)","origin":"thm equequ1(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wb(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2))))\n} = {\n  impbid(wceq(cv(s0), cv(s1)), wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))\n  ax7(s0, s1, s2)\n  equtr(s0, s1, s2)\n}","pretty":"thm equequ1(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 = s2 ↔ s1 = s2))\n} = {\n  impbid(s0 = s1, s0 = s2, s1 = s2)\n  ax7(s0, s1, s2)\n  equtr(s0, s1, s2)\n}","parent":["impbid","ax7","equtr"],"children":["equvinv","equvelv","spaev","sbjustlem","equsb3","drsb1","sb8eulem","axext3ALT","reu6","reu7","reu8nf","disjxun","cbviota","dff13f","poxp","unxpdomlem1","unxpdomlem2","aceq0","zfac","axrepndlem1","zfcndac","injresinj","fsum2dlem","ramub1lem2","ramcl","symgextf1","mamulid","mamurid","mdetdiagid","mdetunilem9","alexsubALTlem3","ptcmplem2","dscmet","dyadmbllem","opnmbllem","isppw2","2sqreulem1","2sqreunnlem1","frgr2wwlk1","disji2f","disjif2","bj-ssblem1","bj-ssblem2","bj-axext3","wl-naevhba1v","wl-equsb3","mblfinlem1","bfp","dveeq1-o","dveeq1-o16","axc11n-16","ax12eq","fphpd","ax6e2nd","ax6e2ndVD","ax6e2ndALT","disjinfi","iundjiun","hspdifhsp","hspmbl","2reu8i","2reuimp0","ichexmpl1","lcoss"]},{"name":"equequ2","content":"An equivalence law for equality. (Contributed by NM, 21-Jun-1993.) (Proof shortened by Wolf Lammen, 4-Aug-2017.) (Proof shortened by BJ, 12-Apr-2021.)","origin":"thm equequ2(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wb(wceq(cv(s2), cv(s0)), wceq(cv(s2), cv(s1))))\n} = {\n  impbid(wceq(cv(s0), cv(s1)), wceq(cv(s2), cv(s0)), wceq(cv(s2), cv(s1)))\n  equtrr(s0, s1, s2)\n  equeuclr(s0, s1, s2)\n}","pretty":"thm equequ2(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s2 = s0 ↔ s2 = s1))\n} = {\n  impbid(s0 = s1, s2 = s0, s2 = s1)\n  equtrr(s0, s1, s2)\n  equeuclr(s0, s1, s2)\n}","parent":["impbid","equtrr","equeuclr"],"children":["sbjustlem","sbequ","sb6","ax13lem2","axc15OLD","dveeq2ALT","sb4b","mojust","mof","mofOLD","eujust","eujustALT","eu6lem","eu6OLD","euf","eufOLD","euequOLD","eleq1w","disjxun","axrep2","dtru","zfpair","dfid3","isso2i","iotaval","dff13f","dfwe2","aceq0","zfac","axpowndlem4","zfcndac","injresinj","infpn2","ramub1lem2","fullestrcsetc","fullsetcestrc","symgextf1","mplcoe1","evlslem2","mamulid","mamurid","mdetdiagid","dscmet","lgseisenlem2","dchrisumlem3","frgr2wwlk1","bj-ssblem1","bj-ssblem2","bj-ax12","bj-axrep2","bj-dtru","bj-ax8","wl-aleq","wl-mo2df","wl-eudf","wl-euequf","wl-mo2t","dveeq2-o","axc11n-16","ax12eq","ax12inda","ax12v2-o","fphpd","iotavalb","disjinfi","eusnsn","2reu8i","2reuimp0","ichexmpl1"]},{"name":"equtr2","content":"Equality is a left-Euclidean binary relation. Uncurried (imported) form of ~ equeucl . (Contributed by NM, 12-Aug-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened by BJ, 11-Apr-2021.)","origin":"thm equtr2(setvar s0, setvar s1, setvar s2) {\n  |- wi(wa(wceq(cv(s0), cv(s1)), wceq(cv(s2), cv(s1))), wceq(cv(s0), cv(s2)))\n} = {\n  imp(wceq(cv(s0), cv(s1)), wceq(cv(s2), cv(s1)), wceq(cv(s0), cv(s2)))\n  equeucl(s0, s1, s2)\n}","pretty":"thm equtr2(setvar s0, setvar s1, setvar s2) {\n  ⊢ ((s0 = s1 ∧ s2 = s1)→ s0 = s2)\n} = {\n  imp(s0 = s1, s2 = s1, s0 = s2)\n  equeucl(s0, s1, s2)\n}","parent":["imp","equeucl"],"children":["nfeqf","mo3","mo3OLD","madurid","dchrisumlema","funpartfun","wl-mo3t"]},{"name":"stdpc6","content":"One of the two equality axioms of standard predicate calculus, called reflexivity of equality. (The other one is ~ stdpc7 .) Axiom 6 of [Mendelson] p. 95. Mendelson doesn't say why he prepended the redundant quantifier, but it was probably to be compatible with free logic (which is valid in the empty domain). (Contributed by NM, 16-Feb-2005.)","origin":"thm stdpc6(setvar s0) {\n  |- wal(s0, wceq(cv(s0), cv(s0)))\n} = {\n  ax-gen(s0, wceq(cv(s0), cv(s0)))\n  equid(s0)\n}","pretty":"thm stdpc6(setvar s0) {\n  ⊢ ∀(s0, s0 = s0)\n} = {\n  ax-gen(s0, s0 = s0)\n  equid(s0)\n}","parent":["ax-gen","equid"],"children":[]},{"name":"equvinv","content":"A variable introduction law for equality. Lemma 15 of [Monk2] p. 109. (Contributed by NM, 9-Jan-1993.) Remove dependencies on ~ ax-10 , ~ ax-13 . (Revised by Wolf Lammen, 10-Jun-2019.) Move the quantified variable ( ` z ` ) to the left of the equality signs. (Revised by Wolf Lammen, 11-Apr-2021.) (Proof shortened by Wolf Lammen, 12-Jul-2022.)","origin":"thm equvinv(setvar s0, setvar s1, setvar s2) {\n  |- wb(wceq(cv(s0), cv(s1)), wex(s2, wa(wceq(cv(s2), cv(s0)), wceq(cv(s2), cv(s1)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  bicomi(wceq(cv(s0), cv(s1)), wex(s2, wa(wceq(cv(s2), cv(s0)), wceq(cv(s2), cv(s1)))))\n  equsexvw(s2, s0, wceq(cv(s2), cv(s1)), wceq(cv(s0), cv(s1)))\n  equequ1(s2, s0, s1)\n  diff.wceq.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm equvinv(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 ↔ ∃(s2,(s2 = s0 ∧ s2 = s1)))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  bicomi(s0 = s1, ∃(s2,(s2 = s0 ∧ s2 = s1)))\n  equsexvw(s2, s0, s2 = s1, s0 = s1)\n  equequ1(s2, s0, s1)\n  diff.wceq.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["bicomi","equsexvw","equequ1","diff.wceq.s","diff.cv.s","diffss.ex"],"children":["ax8","ax9","ax13","cossid"]},{"name":"equvinva","content":"A modified version of the forward implication of ~ equvinv adapted to common usage. (Contributed by Wolf Lammen, 8-Sep-2018.)","origin":"thm equvinva(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wex(s2, wa(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  mpi(wceq(cv(s0), cv(s1)), wex(s2, wa(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))), wex(s2, wceq(cv(s1), cv(s2))))\n  ax6evr(s2, s1)\n  eximdv(s2, wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s2)), wa(wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2))))\n  ancrd(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s2)), wceq(cv(s0), cv(s2)))\n  equtr(s0, s1, s2)\n  diff.wceq.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm equvinva(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 → ∃(s2,(s0 = s2 ∧ s1 = s2)))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  mpi(s0 = s1, ∃(s2,(s0 = s2 ∧ s1 = s2)), ∃(s2, s1 = s2))\n  ax6evr(s2, s1)\n  eximdv(s2, s0 = s1, s1 = s2, (s0 = s2 ∧ s1 = s2))\n  ancrd(s0 = s1, s1 = s2, s0 = s2)\n  equtr(s0, s1, s2)\n  diff.wceq.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["mpi","ax6evr","eximdv","ancrd","equtr","diff.wceq.s","diff.cv.s","diffss.ex"],"children":["sbequ2","ax13lem1","nfeqf","wl-ax13lem1"]},{"name":"equvelv","content":"A biconditional form of ~ equvel with disjoint variable conditions and proved from Tarski's FOL axiom schemes. (Contributed by Andrew Salmon, 2-Jun-2011.) Reduce axiom usage. (Revised by Wolf Lammen, 10-Apr-2021.) (Proof shortened by Wolf Lammen, 12-Jul-2022.)","origin":"thm equvelv(setvar s0, setvar s1, setvar s2) {\n  |- wb(wal(s0, wi(wceq(cv(s0), cv(s1)), wceq(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2)))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n} = {\n  equsalvw(s0, s1, wceq(cv(s0), cv(s2)), wceq(cv(s1), cv(s2)))\n  equequ1(s0, s1, s2)\n  diff.wceq.s(s0, cv(s1), cv(s2))\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, s2)\n}","pretty":"thm equvelv(setvar s0, setvar s1, setvar s2) {\n  ⊢ (∀(s0,(s0 = s1 → s0 = s2))↔ s1 = s2)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n} = {\n  equsalvw(s0, s1, s0 = s2, s1 = s2)\n  equequ1(s0, s1, s2)\n  diff.wceq.s(s0, s1, s2)\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, s2)\n}","parent":["equsalvw","equequ1","diff.wceq.s","diff.cv.s"],"children":["eu6lem","eu6OLD"]},{"name":"ax13b","content":"An equivalence between two ways of expressing ~ ax-13 . See the comment for ~ ax-13 . (Contributed by NM, 2-May-2017.) (Proof shortened by Wolf Lammen, 26-Feb-2018.) (Revised by BJ, 15-Sep-2020.)","origin":"thm ax13b(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wi(wn(wceq(cv(s0), cv(s1))), wi(wceq(cv(s1), cv(s2)), w0)), wi(wn(wceq(cv(s0), cv(s1))), wi(wn(wceq(cv(s0), cv(s2))), wi(wceq(cv(s1), cv(s2)), w0))))\n} = {\n  pm5.74i(wn(wceq(cv(s0), cv(s1))), wi(wceq(cv(s1), cv(s2)), w0), wi(wn(wceq(cv(s0), cv(s2))), wi(wceq(cv(s1), cv(s2)), w0)))\n  impbid2(wn(wceq(cv(s0), cv(s1))), wi(wceq(cv(s1), cv(s2)), w0), wi(wn(wceq(cv(s0), cv(s2))), wi(wceq(cv(s1), cv(s2)), w0)))\n  ax-1(wi(wceq(cv(s1), cv(s2)), w0), wn(wceq(cv(s0), cv(s2))))\n  syl6(wn(wceq(cv(s0), cv(s1))), wi(wn(wceq(cv(s0), cv(s2))), wi(wceq(cv(s1), cv(s2)), w0)), wi(wceq(cv(s1), cv(s2)), w0), wi(wceq(cv(s1), cv(s2)), wi(wceq(cv(s1), cv(s2)), w0)))\n  imim1d(wn(wceq(cv(s0), cv(s1))), wn(wceq(cv(s0), cv(s2))), wi(wceq(cv(s1), cv(s2)), w0), wceq(cv(s1), cv(s2)))\n  con3rr3(wceq(cv(s0), cv(s1)), wceq(cv(s1), cv(s2)), wceq(cv(s0), cv(s2)))\n  equeuclr(s1, s2, s0)\n  pm2.43(wceq(cv(s1), cv(s2)), w0)\n}","pretty":"thm ax13b(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ ((¬ s0 = s1 →(s1 = s2 → w0))↔(¬ s0 = s1 →(¬ s0 = s2 →(s1 = s2 → w0))))\n} = {\n  pm5.74i(¬ s0 = s1, (s1 = s2 → w0), (¬ s0 = s2 →(s1 = s2 → w0)))\n  impbid2(¬ s0 = s1, (s1 = s2 → w0), (¬ s0 = s2 →(s1 = s2 → w0)))\n  ax-1((s1 = s2 → w0), ¬ s0 = s2)\n  syl6(¬ s0 = s1, (¬ s0 = s2 →(s1 = s2 → w0)), (s1 = s2 → w0), (s1 = s2 →(s1 = s2 → w0)))\n  imim1d(¬ s0 = s1, ¬ s0 = s2, (s1 = s2 → w0), s1 = s2)\n  con3rr3(s0 = s1, s1 = s2, s0 = s2)\n  equeuclr(s1, s2, s0)\n  pm2.43(s1 = s2, w0)\n}","parent":["pm5.74i","impbid2","ax-1","syl6","imim1d","con3rr3","equeuclr","pm2.43"],"children":["ax13","ax13ALT","ax13fromc9"]},{"name":"spfw","content":"Weak version of ~ sp . Uses only Tarski's FOL axiom schemes. Lemma 9 of [KalishMontague] p. 87. This may be the best we can do with minimal distinct variable conditions. (Contributed by NM, 19-Apr-2017.) (Proof shortened by Wolf Lammen, 10-Oct-2021.)","origin":"thm spfw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), w0)\n  -| wi(wn(w1), wal(s0, wn(w1)))\n  -| wi(wal(s0, w0), wal(s1, wal(s0, w0)))\n  -| wi(wn(w0), wal(s1, wn(w0)))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n} = {\n  syl(wal(s0, w0), w0, wal(s1, w1))\n  cbvaliw(s0, s1, w0, w1)\n  biimpd(wceq(cv(s0), cv(s1)), w0, w1)\n  spimw(s1, s0, w1, w0)\n  equcoms(s1, s0, wi(w1, w0))\n  biimprd(wceq(cv(s0), cv(s1)), w1, w0)\n  diffss.ex(s1, s0)\n}","pretty":"thm spfw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ w0)\n  ⊣ (¬ w1 → ∀(s0, ¬ w1))\n  ⊣ (∀(s0, w0)→ ∀(s1, ∀(s0, w0)))\n  ⊣ (¬ w0 → ∀(s1, ¬ w0))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n} = {\n  syl(∀(s0, w0), w0, ∀(s1, w1))\n  cbvaliw(s0, s1, w0, w1)\n  biimpd(s0 = s1, w0, w1)\n  spimw(s1, s0, w1, w0)\n  equcoms(s1, s0, (w1 → w0))\n  biimprd(s0 = s1, w1, w0)\n  diffss.ex(s1, s0)\n}","parent":["syl","cbvaliw","biimpd","spimw","equcoms","biimprd","diffss.ex"],"children":["spw"]},{"name":"spw","content":"Weak version of the specialization scheme ~ sp . Lemma 9 of [KalishMontague] p. 87. While it appears that ~ sp in its general form does not follow from Tarski's FOL axiom schemes, from this theorem we can prove any _instance_ of ~ sp having mutually distinct setvar variables and no wff metavariables (see ~ ax12wdemo for an example of the procedure to eliminate the hypothesis). Other approximations of ~ sp are ~ spfw (minimal distinct variable requirements), ~ spnfw (when ` x ` is not free in ` -. ph ` ), ~ spvw (when ` x ` does not appear in ` ph ` ), ~ sptruw (when ` ph ` is true), and ~ spfalw (when ` ph ` is false). (Contributed by NM, 9-Apr-2017.) (Proof shortened by Wolf Lammen, 27-Feb-2018.)","origin":"thm spw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), w0)\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  spfw(s0, s1, w0, w1)\n  ax-5(s0, wn(w1))\n  ax-5(s1, wal(s0, w0))\n  ax-5(s1, wn(w0))\n  diff.wn.s(s0, w1)\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n  diff.wn.s(s1, w0)\n}","pretty":"thm spw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ w0)\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  spfw(s0, s1, w0, w1)\n  ax-5(s0, ¬ w1)\n  ax-5(s1, ∀(s0, w0))\n  ax-5(s1, ¬ w0)\n  diff.wn.s(s0, w1)\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n  diff.wn.s(s1, w0)\n}","parent":["spfw","ax-5","diff.wn.s","diff.wal.s","diffss.ex"],"children":["hba1w","spaev","ax12w","bj-ssblem1","bj-ax12w"]},{"name":"cbvalw","content":"Change bound variable. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 9-Apr-2017.)","origin":"thm cbvalw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wal(s0, w0), wal(s1, w1))\n  -| wi(wal(s0, w0), wal(s1, wal(s0, w0)))\n  -| wi(wn(w1), wal(s0, wn(w1)))\n  -| wi(wal(s1, w1), wal(s0, wal(s1, w1)))\n  -| wi(wn(w0), wal(s1, wn(w0)))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n} = {\n  impbii(wal(s0, w0), wal(s1, w1))\n  cbvaliw(s0, s1, w0, w1)\n  biimpd(wceq(cv(s0), cv(s1)), w0, w1)\n  cbvaliw(s1, s0, w1, w0)\n  equcoms(s1, s0, wi(w1, w0))\n  biimprd(wceq(cv(s0), cv(s1)), w1, w0)\n  diffss.ex(s1, s0)\n}","pretty":"thm cbvalw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)↔ ∀(s1, w1))\n  ⊣ (∀(s0, w0)→ ∀(s1, ∀(s0, w0)))\n  ⊣ (¬ w1 → ∀(s0, ¬ w1))\n  ⊣ (∀(s1, w1)→ ∀(s0, ∀(s1, w1)))\n  ⊣ (¬ w0 → ∀(s1, ¬ w0))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n} = {\n  impbii(∀(s0, w0), ∀(s1, w1))\n  cbvaliw(s0, s1, w0, w1)\n  biimpd(s0 = s1, w0, w1)\n  cbvaliw(s1, s0, w1, w0)\n  equcoms(s1, s0, (w1 → w0))\n  biimprd(s0 = s1, w1, w0)\n  diffss.ex(s1, s0)\n}","parent":["impbii","cbvaliw","biimpd","equcoms","biimprd","diffss.ex"],"children":["cbvalvw","hbn1fw"]},{"name":"cbvalvw","content":"Change bound variable. Uses only Tarski's FOL axiom schemes. See ~ cbvalv for a version with fewer disjoint variable conditions but requiring more axioms. (Contributed by NM, 9-Apr-2017.) (Proof shortened by Wolf Lammen, 28-Feb-2018.)","origin":"thm cbvalvw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wal(s0, w0), wal(s1, w1))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  cbvalw(s0, s1, w0, w1)\n  ax-5(s1, wal(s0, w0))\n  ax-5(s0, wn(w1))\n  ax-5(s0, wal(s1, w1))\n  ax-5(s1, wn(w0))\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n  diff.wn.s(s0, w1)\n  diff.wal.s(s0, s1, w1)\n  diff.wn.s(s1, w0)\n}","pretty":"thm cbvalvw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)↔ ∀(s1, w1))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  cbvalw(s0, s1, w0, w1)\n  ax-5(s1, ∀(s0, w0))\n  ax-5(s0, ¬ w1)\n  ax-5(s0, ∀(s1, w1))\n  ax-5(s1, ¬ w0)\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n  diff.wn.s(s0, w1)\n  diff.wal.s(s0, s1, w1)\n  diff.wn.s(s1, w0)\n}","parent":["cbvalw","ax-5","diff.wal.s","diffss.ex","diff.wn.s"],"children":["cbvexvw","hba1w","sbjustlem","ax12wdemo","nfcjust","cbvraldva2","cbvrexdva2OLD","zfpow","tfisi","pssnn","findcard","findcard3","zfinf","aceq0","kmlem1","kmlem13","fin23lem32","fin23lem41","zfac","zfcndpow","zfcndinf","zfcndac","axgroth4","relexpindlem","ramcl","mreexexlemd","bnj1112","dfon2lem6","dfon2lem7","dfon2","phpreu","axc11n-16","dfac11"]},{"name":"cbvexvw","content":"Change bound variable. Uses only Tarski's FOL axiom schemes. See ~ cbvexv for a version with fewer disjoint variable conditions but requiring more axioms. (Contributed by NM, 19-Apr-2017.)","origin":"thm cbvexvw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wex(s0, w0), wex(s1, w1))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  3bitr4i(wex(s0, w0), wex(s1, w1), wn(wal(s0, wn(w0))), wn(wal(s1, wn(w1))))\n  notbii(wal(s0, wn(w0)), wal(s1, wn(w1)))\n  cbvalvw(s0, s1, wn(w0), wn(w1))\n  notbid(wceq(cv(s0), cv(s1)), w0, w1)\n  df-ex(s0, w0)\n  df-ex(s1, w1)\n  diff.wn.s(s0, w1)\n  diff.wn.s(s1, w0)\n}","pretty":"thm cbvexvw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∃(s0, w0)↔ ∃(s1, w1))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  3bitr4i(∃(s0, w0), ∃(s1, w1), ¬ ∀(s0, ¬ w0), ¬ ∀(s1, ¬ w1))\n  notbii(∀(s0, ¬ w0), ∀(s1, ¬ w1))\n  cbvalvw(s0, s1, ¬ w0, ¬ w1)\n  notbid(s0 = s1, w0, w1)\n  df-ex(s0, w0)\n  df-ex(s1, w1)\n  diff.wn.s(s0, w1)\n  diff.wn.s(s1, w0)\n}","parent":["3bitr4i","notbii","cbvalvw","notbid","df-ex","diff.wn.s"],"children":["mojust","eujust","cbvrexdva2","euind","reuind","cbvopab2v","bm1.3ii","reusv2lem2","relop","dmcoss","fv3","exfo","zfun","suppimacnv","wfrlem1","ac6sfi","brwdom2","aceq1","aceq0","aceq3lem","dfac4","kmlem2","kmlem13","axdc4lem","zfac","zfcndun","zfcndac","sup2","supmul","climmo","summo","prodmo","gsumval3eu","elpt","bnj1185","frrlem1","bj-denotesv","bj-bm1.3ii","fdc","axc11next","fnchoice"]},{"name":"alcomiw","content":"Weak version of ~ alcom . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 10-Apr-2017.) (Proof shortened by Wolf Lammen, 12-Jul-2022.)","origin":"thm alcomiw(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  |- wi(wal(s0, wal(s1, w0)), wal(s1, wal(s0, w0)))\n  -| wi(wceq(cv(s1), cv(s2)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n  -| diffsw(s1, w1)\n  -| diffsw(s2, w0)\n} = {\n  3syl(wal(s0, wal(s1, w0)), wal(s1, wal(s0, w0)), wal(s0, wal(s2, w1)), wal(s1, wal(s0, wal(s2, w1))))\n  alimi(s0, wal(s1, w0), wal(s2, w1))\n  cbvalivw(s1, s2, w0, w1)\n  biimpd(wceq(cv(s1), cv(s2)), w0, w1)\n  ax-5(s1, wal(s0, wal(s2, w1)))\n  2alimi(s1, s0, wal(s2, w1), w0)\n  spimvw(s2, s1, w1, w0)\n  equcoms(s2, s1, wi(w1, w0))\n  biimprd(wceq(cv(s1), cv(s2)), w1, w0)\n  diff.wal.s(s1, s0, wal(s2, w1))\n  diffss.ex(s1, s0)\n  diff.wal.s(s1, s2, w1)\n  diffss.ex(s2, s1)\n}","pretty":"thm alcomiw(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  ⊢ (∀(s0, ∀(s1, w0))→ ∀(s1, ∀(s0, w0)))\n  ⊣ (s1 = s2 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, s2)\n  ⊣ d(s1, w1)\n  ⊣ d(s2, w0)\n} = {\n  3syl(∀(s0, ∀(s1, w0)), ∀(s1, ∀(s0, w0)), ∀(s0, ∀(s2, w1)), ∀(s1, ∀(s0, ∀(s2, w1))))\n  alimi(s0, ∀(s1, w0), ∀(s2, w1))\n  cbvalivw(s1, s2, w0, w1)\n  biimpd(s1 = s2, w0, w1)\n  ax-5(s1, ∀(s0, ∀(s2, w1)))\n  2alimi(s1, s0, ∀(s2, w1), w0)\n  spimvw(s2, s1, w1, w0)\n  equcoms(s2, s1, (w1 → w0))\n  biimprd(s1 = s2, w1, w0)\n  diff.wal.s(s1, s0, ∀(s2, w1))\n  diffss.ex(s1, s0)\n  diff.wal.s(s1, s2, w1)\n  diffss.ex(s2, s1)\n}","parent":["3syl","alimi","cbvalivw","biimpd","ax-5","2alimi","spimvw","equcoms","biimprd","diff.wal.s","diffss.ex"],"children":["hbalw","ax11w","bj-ssblem2"]},{"name":"hbn1fw","content":"Weak version of ~ ax-10 from which we can prove any ~ ax-10 instance not involving wff variables or bundling. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 19-Apr-2017.) (Proof shortened by Wolf Lammen, 28-Feb-2018.)","origin":"thm hbn1fw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wn(wal(s0, w0)), wal(s0, wn(wal(s0, w0))))\n  -| wi(wal(s0, w0), wal(s1, wal(s0, w0)))\n  -| wi(wn(w1), wal(s0, wn(w1)))\n  -| wi(wal(s1, w1), wal(s0, wal(s1, w1)))\n  -| wi(wn(w0), wal(s1, wn(w0)))\n  -| wi(wn(wal(s1, w1)), wal(s0, wn(wal(s1, w1))))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n} = {\n  hbxfrbi(s0, wn(wal(s0, w0)), wn(wal(s1, w1)))\n  notbii(wal(s0, w0), wal(s1, w1))\n  cbvalw(s0, s1, w0, w1)\n}","pretty":"thm hbn1fw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (¬ ∀(s0, w0)→ ∀(s0, ¬ ∀(s0, w0)))\n  ⊣ (∀(s0, w0)→ ∀(s1, ∀(s0, w0)))\n  ⊣ (¬ w1 → ∀(s0, ¬ w1))\n  ⊣ (∀(s1, w1)→ ∀(s0, ∀(s1, w1)))\n  ⊣ (¬ w0 → ∀(s1, ¬ w0))\n  ⊣ (¬ ∀(s1, w1)→ ∀(s0, ¬ ∀(s1, w1)))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n} = {\n  hbxfrbi(s0, ¬ ∀(s0, w0), ¬ ∀(s1, w1))\n  notbii(∀(s0, w0), ∀(s1, w1))\n  cbvalw(s0, s1, w0, w1)\n}","parent":["hbxfrbi","notbii","cbvalw"],"children":["hbn1w"]},{"name":"hbn1w","content":"Weak version of ~ hbn1 . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 9-Apr-2017.)","origin":"thm hbn1w(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wn(wal(s0, w0)), wal(s0, wn(wal(s0, w0))))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  hbn1fw(s0, s1, w0, w1)\n  ax-5(s1, wal(s0, w0))\n  ax-5(s0, wn(w1))\n  ax-5(s0, wal(s1, w1))\n  ax-5(s1, wn(w0))\n  ax-5(s0, wn(wal(s1, w1)))\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n  diff.wn.s(s0, w1)\n  diff.wn.s(s1, w0)\n  diff.wn.s(s0, wal(s1, w1))\n  diff.wal.s(s0, s1, w1)\n}","pretty":"thm hbn1w(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (¬ ∀(s0, w0)→ ∀(s0, ¬ ∀(s0, w0)))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  hbn1fw(s0, s1, w0, w1)\n  ax-5(s1, ∀(s0, w0))\n  ax-5(s0, ¬ w1)\n  ax-5(s0, ∀(s1, w1))\n  ax-5(s1, ¬ w0)\n  ax-5(s0, ¬ ∀(s1, w1))\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n  diff.wn.s(s0, w1)\n  diff.wn.s(s1, w0)\n  diff.wn.s(s0, ∀(s1, w1))\n  diff.wal.s(s0, s1, w1)\n}","parent":["hbn1fw","ax-5","diff.wal.s","diffss.ex","diff.wn.s"],"children":["hba1w","hbe1w","ax10w","wl-naevhba1v"]},{"name":"hba1w","content":"Weak version of ~ hba1 . See comments for ~ ax10w . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 9-Apr-2017.) (Proof shortened by Wolf Lammen, 10-Oct-2021.)","origin":"thm hba1w(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), wal(s0, wal(s0, w0)))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  3syl(wal(s0, w0), wal(s0, wal(s0, w0)), wn(wal(s0, wn(wal(s0, w0)))), wal(s0, wn(wal(s0, wn(wal(s0, w0))))))\n  con2i(wal(s0, w0), wal(s0, wn(wal(s0, w0))))\n  spw(s0, s1, wn(wal(s0, w0)), wn(wal(s1, w1)))\n  hbn1w(s0, s1, wn(wal(s0, w0)), wn(wal(s1, w1)))\n  a1i(wceq(cv(s0), cv(s1)), wb(wn(wal(s0, w0)), wn(wal(s1, w1))))\n  notbii(wal(s0, w0), wal(s1, w1))\n  cbvalvw(s0, s1, w0, w1)\n  alimi(s0, wn(wal(s0, wn(wal(s0, w0)))), wal(s0, w0))\n  con1i(wal(s0, wn(wal(s0, w0))), wal(s0, w0))\n  hbn1w(s0, s1, w0, w1)\n  diff.wn.s(s0, wal(s1, w1))\n  diff.wal.s(s0, s1, w1)\n  diff.wn.s(s1, wal(s0, w0))\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","pretty":"thm hba1w(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ ∀(s0, ∀(s0, w0)))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  3syl(∀(s0, w0), ∀(s0, ∀(s0, w0)), ¬ ∀(s0, ¬ ∀(s0, w0)), ∀(s0, ¬ ∀(s0, ¬ ∀(s0, w0))))\n  con2i(∀(s0, w0), ∀(s0, ¬ ∀(s0, w0)))\n  spw(s0, s1, ¬ ∀(s0, w0), ¬ ∀(s1, w1))\n  hbn1w(s0, s1, ¬ ∀(s0, w0), ¬ ∀(s1, w1))\n  a1i(s0 = s1, (¬ ∀(s0, w0)↔ ¬ ∀(s1, w1)))\n  notbii(∀(s0, w0), ∀(s1, w1))\n  cbvalvw(s0, s1, w0, w1)\n  alimi(s0, ¬ ∀(s0, ¬ ∀(s0, w0)), ∀(s0, w0))\n  con1i(∀(s0, ¬ ∀(s0, w0)), ∀(s0, w0))\n  hbn1w(s0, s1, w0, w1)\n  diff.wn.s(s0, ∀(s1, w1))\n  diff.wal.s(s0, s1, w1)\n  diff.wn.s(s1, ∀(s0, w0))\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","parent":["3syl","con2i","spw","hbn1w","a1i","notbii","cbvalvw","alimi","con1i","diff.wn.s","diff.wal.s","diffss.ex"],"children":[]},{"name":"hbe1w","content":"Weak version of ~ hbe1 . See comments for ~ ax10w . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 19-Apr-2017.)","origin":"thm hbe1w(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wex(s0, w0), wal(s0, wex(s0, w0)))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  hbxfrbi(s0, wex(s0, w0), wn(wal(s0, wn(w0))))\n  df-ex(s0, w0)\n  hbn1w(s0, s1, wn(w0), wn(w1))\n  notbid(wceq(cv(s0), cv(s1)), w0, w1)\n  diff.wn.s(s0, w1)\n  diff.wn.s(s1, w0)\n}","pretty":"thm hbe1w(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∃(s0, w0)→ ∀(s0, ∃(s0, w0)))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  hbxfrbi(s0, ∃(s0, w0), ¬ ∀(s0, ¬ w0))\n  df-ex(s0, w0)\n  hbn1w(s0, s1, ¬ w0, ¬ w1)\n  notbid(s0 = s1, w0, w1)\n  diff.wn.s(s0, w1)\n  diff.wn.s(s1, w0)\n}","parent":["hbxfrbi","df-ex","hbn1w","notbid","diff.wn.s"],"children":[]},{"name":"hbalw","content":"Weak version of ~ hbal . Uses only Tarski's FOL axiom schemes. Unlike ~ hbal , this theorem requires that ` x ` and ` y ` be distinct, i.e. not be bundled. (Contributed by NM, 19-Apr-2017.)","origin":"thm hbalw(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  |- wi(wal(s0, w0), wal(s1, wal(s0, w0)))\n  -| wi(wceq(cv(s1), cv(s2)), wb(w0, w1))\n  -| wi(w0, wal(s1, w0))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n  -| diffsw(s1, w1)\n  -| diffsw(s2, w0)\n} = {\n  syl(wal(s0, w0), wal(s1, wal(s0, w0)), wal(s0, wal(s1, w0)))\n  alimi(s0, w0, wal(s1, w0))\n  alcomiw(s0, s1, s2, w0, w1)\n}","pretty":"thm hbalw(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ ∀(s1, ∀(s0, w0)))\n  ⊣ (s1 = s2 →(w0 ↔ w1))\n  ⊣ (w0 → ∀(s1, w0))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, s2)\n  ⊣ d(s1, w1)\n  ⊣ d(s2, w0)\n} = {\n  syl(∀(s0, w0), ∀(s1, ∀(s0, w0)), ∀(s0, ∀(s1, w0)))\n  alimi(s0, w0, ∀(s1, w0))\n  alcomiw(s0, s1, s2, w0, w1)\n}","parent":["syl","alimi","alcomiw"],"children":[]},{"name":"spaev","content":"A special instance of ~ sp applied to an equality with a disjoint variable condition. Unlike the more general ~ sp , we can prove this without ~ ax-12 . Instance of ~ aeveq . The antecedent ` A. x x = y ` with distinct ` x ` and ` y ` is a characteristic of a degenerate universe, in which just one object exists. Actually more than one object may still exist, but if so, we give up on equality as a discriminating term. Separating this degenerate case from a richer universe, where inequality is possible, is a common proof idea. The name of this theorem follows a convention, where the condition ` A. x x = y ` is denoted by 'aev', a shorthand for 'all equal, with a distinct variable condition'. (Contributed by Wolf Lammen, 14-Mar-2021.)","origin":"thm spaev(setvar s0, setvar s1) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wceq(cv(s0), cv(s1)))\n  -| diffss(s0, s1)\n} = {\n  spw(s0, hs0, wceq(cv(s0), cv(s1)), wceq(cv(hs0), cv(s1)))\n  equequ1(s0, hs0, s1)\n  diff.wceq.s(s0, cv(hs0), cv(s1))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.cv.s(s0, s1)\n  diff.hs0.w(wceq(cv(s0), cv(s1)))\n}","pretty":"thm spaev(setvar s0, setvar s1) {\n  ⊢ (∀(s0, s0 = s1)→ s0 = s1)\n  ⊣ d(s0, s1)\n} = {\n  spw(s0, hs0, s0 = s1, hs0 = s1)\n  equequ1(s0, hs0, s1)\n  diff.wceq.s(s0, hs0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.cv.s(s0, s1)\n  diff.hs0.w(s0 = s1)\n}","parent":["spw","equequ1","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.hs0.w"],"children":["aevlem0"]},{"name":"cbvaev","content":"Change bound variable in an equality with a disjoint variable condition. Instance of ~ aev . (Contributed by NM, 22-Jul-2015.) (Revised by BJ, 18-Jun-2019.)","origin":"thm cbvaev(setvar s0, setvar s1, setvar s2) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s2), cv(s1))))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n} = {\n  syl(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s2), cv(s1))), wal(hs0, wceq(cv(hs0), cv(s1))))\n  cbvalivw(s0, hs0, wceq(cv(s0), cv(s1)), wceq(cv(hs0), cv(s1)))\n  ax7(s0, hs0, s1)\n  cbvalivw(hs0, s2, wceq(cv(hs0), cv(s1)), wceq(cv(s2), cv(s1)))\n  ax7(hs0, s2, s1)\n  diff.wceq.s(s0, cv(hs0), cv(s1))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.cv.s(s0, s1)\n  diff.hs0.w(wceq(cv(s0), cv(s1)))\n  diff.hs0.w(wceq(cv(s2), cv(s1)))\n  diff.wceq.s(s2, cv(hs0), cv(s1))\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm cbvaev(setvar s0, setvar s1, setvar s2) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, s2 = s1))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, s2)\n} = {\n  syl(∀(s0, s0 = s1), ∀(s2, s2 = s1), ∀(hs0, hs0 = s1))\n  cbvalivw(s0, hs0, s0 = s1, hs0 = s1)\n  ax7(s0, hs0, s1)\n  cbvalivw(hs0, s2, hs0 = s1, s2 = s1)\n  ax7(hs0, s2, s1)\n  diff.wceq.s(s0, hs0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.cv.s(s0, s1)\n  diff.hs0.w(s0 = s1)\n  diff.hs0.w(s2 = s1)\n  diff.wceq.s(s2, hs0, s1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["syl","cbvalivw","ax7","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.hs0.w"],"children":["aevlem0","aevlem"]},{"name":"aevlem0","content":"Lemma for ~ aevlem . Instance of ~ aev . (Contributed by NM, 8-Jul-2016.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 14-Mar-2021.) (Revised by BJ, 29-Mar-2021.) (Proof shortened by Wolf Lammen, 30-Mar-2021.)","origin":"thm aevlem0(setvar s0, setvar s1, setvar s2) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s2), cv(s0))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  sylc(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s2), cv(s0))), wal(s2, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s2), cv(s1))))\n  alrimiv(s2, wal(s0, wceq(cv(s0), cv(s1))), wceq(cv(s0), cv(s1)))\n  spaev(s0, s1)\n  cbvaev(s0, s1, s2)\n  al2imi(s2, wceq(cv(s0), cv(s1)), wceq(cv(s2), cv(s1)), wceq(cv(s2), cv(s0)))\n  equeuclr(s0, s1, s2)\n  diff.wal.s(s2, s0, wceq(cv(s0), cv(s1)))\n  diff.wceq.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm aevlem0(setvar s0, setvar s1, setvar s2) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, s2 = s0))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  sylc(∀(s0, s0 = s1), ∀(s2, s2 = s0), ∀(s2, s0 = s1), ∀(s2, s2 = s1))\n  alrimiv(s2, ∀(s0, s0 = s1), s0 = s1)\n  spaev(s0, s1)\n  cbvaev(s0, s1, s2)\n  al2imi(s2, s0 = s1, s2 = s1, s2 = s0)\n  equeuclr(s0, s1, s2)\n  diff.wal.s(s2, s0, s0 = s1)\n  diff.wceq.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["sylc","alrimiv","spaev","cbvaev","al2imi","equeuclr","diff.wal.s","diff.wceq.s","diff.cv.s","diffss.ex"],"children":["aevlem"]},{"name":"aevlem","content":"Lemma for ~ aev and ~ axc16g . Change free and bound variables. Instance of ~ aev . (Contributed by NM, 22-Jul-2015.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-13 , along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 29-Mar-2021.)","origin":"thm aevlem(setvar s0, setvar s1, setvar s2, setvar s3) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s2), cv(s3))))\n  -| diffss(s0, s1)\n  -| diffss(s2, s3)\n} = {\n  4syl(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s2), cv(s3))), wal(hs0, wceq(cv(hs0), cv(s1))), wal(s0, wceq(cv(s0), cv(hs0))), wal(s3, wceq(cv(s3), cv(hs0))))\n  cbvaev(s0, s1, hs0)\n  aevlem0(hs0, s1, s0)\n  cbvaev(s0, hs0, s3)\n  aevlem0(s3, hs0, s2)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s1, s0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s3, hs0)\n  diff.hs0.s(s3)\n  diffss.ex(s3, s2)\n  diff.hs0.s(s2)\n}","pretty":"thm aevlem(setvar s0, setvar s1, setvar s2, setvar s3) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, s2 = s3))\n  ⊣ d(s0, s1)\n  ⊣ d(s2, s3)\n} = {\n  4syl(∀(s0, s0 = s1), ∀(s2, s2 = s3), ∀(hs0, hs0 = s1), ∀(s0, s0 = hs0), ∀(s3, s3 = hs0))\n  cbvaev(s0, s1, hs0)\n  aevlem0(hs0, s1, s0)\n  cbvaev(s0, hs0, s3)\n  aevlem0(s3, hs0, s2)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s1, s0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s3, hs0)\n  diff.hs0.s(s3)\n  diffss.ex(s3, s2)\n  diff.hs0.s(s2)\n}","parent":["4syl","cbvaev","aevlem0","diffss.ex","diff.hs0.s"],"children":["aeveq","aev","hbaevg","axc16g","bj-axc16g16","bj-axc11nv","bj-aecomsv"]},{"name":"aeveq","content":"The antecedent ` A. x x = y ` with a disjoint variable condition (typical of a one-object universe) forces equality of everything. (Contributed by Wolf Lammen, 19-Mar-2021.)","origin":"thm aeveq(setvar s0, setvar s1, setvar s2, setvar s3) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wceq(cv(s2), cv(s3)))\n  -| diffss(s0, s1)\n} = {\n  3syl(wal(s0, wceq(cv(s0), cv(s1))), wceq(cv(s2), cv(s3)), wal(hs0, wceq(cv(hs0), cv(s2))), wex(hs0, wceq(cv(s2), cv(s3))))\n  aevlem(s0, s1, hs0, s2)\n  mpi(wal(hs0, wceq(cv(hs0), cv(s2))), wex(hs0, wceq(cv(s2), cv(s3))), wex(hs0, wceq(cv(hs0), cv(s3))))\n  ax6ev(hs0, s3)\n  aleximi(hs0, wceq(cv(hs0), cv(s2)), wceq(cv(hs0), cv(s3)), wceq(cv(s2), cv(s3)))\n  ax7(hs0, s2, s3)\n  ax5e(hs0, wceq(cv(s2), cv(s3)))\n  diff.hs0.s(s2)\n  diff.hs0.s(s3)\n  diff.hs0.w(wceq(cv(s2), cv(s3)))\n}","pretty":"thm aeveq(setvar s0, setvar s1, setvar s2, setvar s3) {\n  ⊢ (∀(s0, s0 = s1)→ s2 = s3)\n  ⊣ d(s0, s1)\n} = {\n  3syl(∀(s0, s0 = s1), s2 = s3, ∀(hs0, hs0 = s2), ∃(hs0, s2 = s3))\n  aevlem(s0, s1, hs0, s2)\n  mpi(∀(hs0, hs0 = s2), ∃(hs0, s2 = s3), ∃(hs0, hs0 = s3))\n  ax6ev(hs0, s3)\n  aleximi(hs0, hs0 = s2, hs0 = s3, s2 = s3)\n  ax7(hs0, s2, s3)\n  ax5e(hs0, s2 = s3)\n  diff.hs0.s(s2)\n  diff.hs0.s(s3)\n  diff.hs0.w(s2 = s3)\n}","parent":["3syl","aevlem","mpi","ax6ev","aleximi","ax7","ax5e","diff.hs0.s","diff.hs0.w"],"children":["aev","2ax6e","aevdemo","wl-moteq","wl-spae"]},{"name":"aev","content":"A \"distinctor elimination\" lemma with no restrictions on variables in the consequent. (Contributed by NM, 8-Nov-2006.) Remove dependency on ~ ax-11 . (Revised by Wolf Lammen, 7-Sep-2018.) Remove dependency on ~ ax-13 , inspired by an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 19-Mar-2021.)","origin":"thm aev(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s3), cv(s4))))\n  -| diffss(s0, s1)\n} = {\n  syl(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wceq(cv(s3), cv(s4))), wal(hs0, wceq(cv(hs0), cv(hs1))))\n  aevlem(s0, s1, hs0, hs1)\n  alrimiv(s2, wal(hs0, wceq(cv(hs0), cv(hs1))), wceq(cv(s3), cv(s4)))\n  aeveq(hs0, hs1, s3, s4)\n  diff.hs0.s(hs1)\n  diff.wal.s(s2, hs0, wceq(cv(hs0), cv(hs1)))\n  diff.wceq.s(s2, cv(hs0), cv(hs1))\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n}","pretty":"thm aev(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, s3 = s4))\n  ⊣ d(s0, s1)\n} = {\n  syl(∀(s0, s0 = s1), ∀(s2, s3 = s4), ∀(hs0, hs0 = hs1))\n  aevlem(s0, s1, hs0, hs1)\n  alrimiv(s2, ∀(hs0, hs0 = hs1), s3 = s4)\n  aeveq(hs0, hs1, s3, s4)\n  diff.hs0.s(hs1)\n  diff.wal.s(s2, hs0, hs0 = hs1)\n  diff.wceq.s(s2, hs0, hs1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n}","parent":["syl","aevlem","alrimiv","aeveq","diff.hs0.s","diff.wal.s","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs1.s"],"children":["hbnaevg","aev2","aev2ALT","axc11n","axc16gALT","aevdemo","axc11n11r","wl-naev","wl-ax11-lem2"]},{"name":"hbaevg","content":"Generalization of ~ hbaev , proved at no extra cost. Instance of ~ aev2 . (Contributed by Wolf Lammen, 22-Mar-2021.) (Revised by BJ, 29-Mar-2021.)","origin":"thm hbaevg(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wal(s3, wceq(cv(s3), cv(s4)))))\n  -| diffss(s0, s1)\n  -| diffss(s3, s4)\n} = {\n  syl(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wal(s3, wceq(cv(s3), cv(s4)))), wal(hs0, wceq(cv(hs0), cv(hs1))))\n  aevlem(s0, s1, hs0, hs1)\n  alrimiv(s2, wal(hs0, wceq(cv(hs0), cv(hs1))), wal(s3, wceq(cv(s3), cv(s4))))\n  aevlem(hs0, hs1, s3, s4)\n  diff.hs0.s(hs1)\n  diff.wal.s(s2, hs0, wceq(cv(hs0), cv(hs1)))\n  diff.wceq.s(s2, cv(hs0), cv(hs1))\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n}","pretty":"thm hbaevg(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, ∀(s3, s3 = s4)))\n  ⊣ d(s0, s1)\n  ⊣ d(s3, s4)\n} = {\n  syl(∀(s0, s0 = s1), ∀(s2, ∀(s3, s3 = s4)), ∀(hs0, hs0 = hs1))\n  aevlem(s0, s1, hs0, hs1)\n  alrimiv(s2, ∀(hs0, hs0 = hs1), ∀(s3, s3 = s4))\n  aevlem(hs0, hs1, s3, s4)\n  diff.hs0.s(hs1)\n  diff.wal.s(s2, hs0, hs0 = hs1)\n  diff.wceq.s(s2, hs0, hs1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n}","parent":["syl","aevlem","alrimiv","diff.hs0.s","diff.wal.s","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs1.s"],"children":["hbaev","aev2"]},{"name":"hbaev","content":"Version of ~ hbae with a disjoint variable condition, requiring fewer axioms. Instance of ~ hbaevg and ~ aev2 . (Contributed by Wolf Lammen, 22-Mar-2021.)","origin":"thm hbaev(setvar s0, setvar s1, setvar s2) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wal(s0, wceq(cv(s0), cv(s1)))))\n  -| diffss(s0, s1)\n} = {\n  hbaevg(s0, s1, s2, s0, s1)\n}","pretty":"thm hbaev(setvar s0, setvar s1, setvar s2) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, ∀(s0, s0 = s1)))\n  ⊣ d(s0, s1)\n} = {\n  hbaevg(s0, s1, s2, s0, s1)\n}","parent":["hbaevg"],"children":["euae","wl-moae"]},{"name":"hbnaevg","content":"Generalization of ~ hbnaev . (Contributed by Wolf Lammen, 9-Apr-2021.)","origin":"thm hbnaevg(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4) {\n  |- wi(wn(wal(s0, wceq(cv(s0), cv(s1)))), wal(s2, wn(wal(s3, wceq(cv(s3), cv(s4))))))\n  -| diffss(s0, s1)\n  -| diffss(s3, s4)\n} = {\n  a1ii(wi(wn(wal(s0, wceq(cv(s0), cv(s1)))), wal(s2, wn(wal(s3, wceq(cv(s3), cv(s4)))))), diffss(s0, s1))\n  3syl(wn(wal(s0, wceq(cv(s0), cv(s1)))), wal(s2, wn(wal(s3, wceq(cv(s3), cv(s4))))), wn(wal(hs0, wceq(cv(hs0), cv(hs1)))), wal(s2, wn(wal(hs0, wceq(cv(hs0), cv(hs1))))))\n  con3i(wal(s0, wceq(cv(s0), cv(s1))), wal(hs0, wceq(cv(hs0), cv(hs1))))\n  aev(hs0, hs1, s0, s0, s1)\n  ax-5(s2, wn(wal(hs0, wceq(cv(hs0), cv(hs1)))))\n  alimi(s2, wn(wal(hs0, wceq(cv(hs0), cv(hs1)))), wn(wal(s3, wceq(cv(s3), cv(s4)))))\n  con3i(wal(hs0, wceq(cv(hs0), cv(hs1))), wal(s3, wceq(cv(s3), cv(s4))))\n  aev(s3, s4, hs0, hs0, hs1)\n  diff.hs0.s(hs1)\n  diff.wn.s(s2, wal(hs0, wceq(cv(hs0), cv(hs1))))\n  diff.wal.s(s2, hs0, wceq(cv(hs0), cv(hs1)))\n  diff.wceq.s(s2, cv(hs0), cv(hs1))\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n}","pretty":"thm hbnaevg(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4) {\n  ⊢ (¬ ∀(s0, s0 = s1)→ ∀(s2, ¬ ∀(s3, s3 = s4)))\n  ⊣ d(s0, s1)\n  ⊣ d(s3, s4)\n} = {\n  a1ii((¬ ∀(s0, s0 = s1)→ ∀(s2, ¬ ∀(s3, s3 = s4))), d(s0, s1))\n  3syl(¬ ∀(s0, s0 = s1), ∀(s2, ¬ ∀(s3, s3 = s4)), ¬ ∀(hs0, hs0 = hs1), ∀(s2, ¬ ∀(hs0, hs0 = hs1)))\n  con3i(∀(s0, s0 = s1), ∀(hs0, hs0 = hs1))\n  aev(hs0, hs1, s0, s0, s1)\n  ax-5(s2, ¬ ∀(hs0, hs0 = hs1))\n  alimi(s2, ¬ ∀(hs0, hs0 = hs1), ¬ ∀(s3, s3 = s4))\n  con3i(∀(hs0, hs0 = hs1), ∀(s3, s3 = s4))\n  aev(s3, s4, hs0, hs0, hs1)\n  diff.hs0.s(hs1)\n  diff.wn.s(s2, ∀(hs0, hs0 = hs1))\n  diff.wal.s(s2, hs0, hs0 = hs1)\n  diff.wceq.s(s2, hs0, hs1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n}","parent":["a1ii","3syl","con3i","aev","ax-5","alimi","diff.hs0.s","diff.wn.s","diff.wal.s","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs1.s"],"children":["hbnaev"]},{"name":"hbnaev","content":"Any variable is free in ` -. A. x x = y ` , if ` x ` and ` y ` are distinct. This condition is dropped in ~ hbnae , at the expense of more axiom dependencies. Instance of ~ hbnaevg . (Contributed by Wolf Lammen, 9-Apr-2021.)","origin":"thm hbnaev(setvar s0, setvar s1, setvar s2) {\n  |- wi(wn(wal(s0, wceq(cv(s0), cv(s1)))), wal(s2, wn(wal(s0, wceq(cv(s0), cv(s1))))))\n  -| diffss(s0, s1)\n} = {\n  hbnaevg(s0, s1, s2, s0, s1)\n}","pretty":"thm hbnaev(setvar s0, setvar s1, setvar s2) {\n  ⊢ (¬ ∀(s0, s0 = s1)→ ∀(s2, ¬ ∀(s0, s0 = s1)))\n  ⊣ d(s0, s1)\n} = {\n  hbnaevg(s0, s1, s2, s0, s1)\n}","parent":["hbnaevg"],"children":["euae"]},{"name":"aev2","content":"A version of ~ aev with two universal quantifiers in the consequent, and a generalization of ~ hbaevg . One can prove similar statements with arbitrary numbers of universal quantifiers in the consequent (the series begins with ~ aeveq , ~ aev , ~ aev2 ). Using ~ aev and ~ alrimiv (as in ~ aev2ALT ), one can actually prove (with no more axioms) any scheme of the form ` ( A. x x = y -> ` PHI) , DV ` ( x , y ) ` where PHI involves only setvar variables and the connectors ` -> ` , ` <-> ` , ` /\\ ` , ` \\/ ` , ` T. ` , ` = ` , ` A. ` , ` E. ` , ` E* ` , ` E! ` , ` F/ ` . An example is given by ~ aevdemo . This list cannot be extended to ` -. ` or ` F. ` since the scheme ` A. x x = y ` is consistent with ~ ax-mp , ~ ax-gen , ~ ax-1 -- ~ ax-13 (as the one-element universe shows). (Contributed by BJ, 29-Mar-2021.)","origin":"thm aev2(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4, setvar s5) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wal(s3, wceq(cv(s4), cv(s5)))))\n  -| diffss(s0, s1)\n} = {\n  sylg(s2, wal(s0, wceq(cv(s0), cv(s1))), wal(s3, wceq(cv(s4), cv(s5))), wal(hs0, wceq(cv(hs0), cv(hs1))))\n  hbaevg(s0, s1, s2, hs0, hs1)\n  aev(hs0, hs1, s3, s4, s5)\n  diff.hs0.s(hs1)\n}","pretty":"thm aev2(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4, setvar s5) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, ∀(s3, s4 = s5)))\n  ⊣ d(s0, s1)\n} = {\n  sylg(s2, ∀(s0, s0 = s1), ∀(s3, s4 = s5), ∀(hs0, hs0 = hs1))\n  hbaevg(s0, s1, s2, hs0, hs1)\n  aev(hs0, hs1, s3, s4, s5)\n  diff.hs0.s(hs1)\n}","parent":["sylg","hbaevg","aev","diff.hs0.s"],"children":[]},{"name":"aev2ALT","content":"Alternate proof of ~ aev2 , bypassing ~ hbaevg . (Contributed by BJ, 23-Mar-2021.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm aev2ALT(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4, setvar s5) {\n  |- wi(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wal(s3, wceq(cv(s4), cv(s5)))))\n  -| diffss(s0, s1)\n} = {\n  syl(wal(s0, wceq(cv(s0), cv(s1))), wal(s2, wal(s3, wceq(cv(s4), cv(s5)))), wal(hs0, wceq(cv(hs0), cv(hs1))))\n  aev(s0, s1, hs0, hs0, hs1)\n  alrimiv(s2, wal(hs0, wceq(cv(hs0), cv(hs1))), wal(s3, wceq(cv(s4), cv(s5))))\n  aev(hs0, hs1, s3, s4, s5)\n  diff.wal.s(s2, hs0, wceq(cv(hs0), cv(hs1)))\n  diff.wceq.s(s2, cv(hs0), cv(hs1))\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n  diff.hs0.s(hs1)\n}","pretty":"thm aev2ALT(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4, setvar s5) {\n  ⊢ (∀(s0, s0 = s1)→ ∀(s2, ∀(s3, s4 = s5)))\n  ⊣ d(s0, s1)\n} = {\n  syl(∀(s0, s0 = s1), ∀(s2, ∀(s3, s4 = s5)), ∀(hs0, hs0 = hs1))\n  aev(s0, s1, hs0, hs0, hs1)\n  alrimiv(s2, ∀(hs0, hs0 = hs1), ∀(s3, s4 = s5))\n  aev(hs0, hs1, s3, s4, s5)\n  diff.wal.s(s2, hs0, hs0 = hs1)\n  diff.wceq.s(s2, hs0, hs1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n  diff.hs0.s(hs1)\n}","parent":["syl","aev","alrimiv","diff.wal.s","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.hs1.s"],"children":[]}]}