{"index":54,"title":"Axiom scheme ax-6 (Existence)","content":"","blocks":[{"name":"ax-6","content":"Axiom of Existence. One of the equality and substitution axioms of predicate calculus with equality. This axiom tells us is that at least one thing exists. In this form (not requiring that ` x ` and ` y ` be distinct) it was used in an axiom system of Tarski (see Axiom B7' in footnote 1 of [KalishMontague] p. 81.) It is equivalent to axiom scheme C10' in [Megill] p. 448 (p. 16 of the preprint); the equivalence is established by ~ axc10 and ~ ax6fromc10 . A more convenient form of this axiom is ~ ax6e , which has additional remarks. Raph Levien proved the independence of this axiom from the other logical axioms on 12-Apr-2005. See item 16 at ~ http://us.metamath.org/award2003.html . ~ ax-6 can be proved from the weaker version ~ ax6v requiring that the variables be distinct; see theorem ~ ax6 . ~ ax-6 can also be proved from the Axiom of Separation (in the form that we use that axiom, where free variables are not universally quantified). See theorem ~ ax6vsep . Except by ~ ax6v , this axiom should not be referenced directly. Instead, use theorem ~ ax6 . (Contributed by NM, 10-Jan-1993.) (New usage is discouraged.)","origin":"axiom ax-6(setvar s0, setvar s1) {\n  |- wn(wal(s0, wn(wceq(cv(s0), cv(s1)))))\n}","pretty":"axiom ax-6(setvar s0, setvar s1) {\n  ⊢ ¬ ∀(s0, ¬ s0 = s1)\n}","parent":[],"children":["ax6v"]},{"name":"ax6v","content":"Axiom B7 of [Tarski] p. 75, which requires that ` x ` and ` y ` be distinct. This trivial proof is intended merely to weaken axiom ~ ax-6 by adding a distinct variable restriction ($d). From here on, ~ ax-6 should not be referenced directly by any other proof, so that theorem ~ ax6 will show that we can recover ~ ax-6 from this weaker version if it were an axiom (as it is in the case of Tarski). Note: Introducing ` x , y ` as a distinct variable group \"out of the blue\" with no apparent justification has puzzled some people, but it is perfectly sound. All we are doing is adding an additional prerequisite, similar to adding an unnecessary logical hypothesis, that results in a weakening of the theorem. This means that any _future_ theorem that references ~ ax6v must have a $d specified for the two variables that get substituted for ` x ` and ` y ` . The $d does not propagate \"backwards\", i.e., it does not impose a requirement on ~ ax-6 . When possible, use of this theorem rather than ~ ax6 is preferred since its derivation is much shorter and requires fewer axioms. (Contributed by NM, 7-Aug-2015.)","origin":"thm ax6v(setvar s0, setvar s1) {\n  |- wn(wal(s0, wn(wceq(cv(s0), cv(s1)))))\n  -| diffss(s0, s1)\n} = {\n  a1ii(wn(wal(s0, wn(wceq(cv(s0), cv(s1))))), diffss(s0, s1))\n  ax-6(s0, s1)\n}","pretty":"thm ax6v(setvar s0, setvar s1) {\n  ⊢ ¬ ∀(s0, ¬ s0 = s1)\n  ⊣ d(s0, s1)\n} = {\n  a1ii(¬ ∀(s0, ¬ s0 = s1), d(s0, s1))\n  ax-6(s0, s1)\n}","parent":["a1ii","ax-6"],"children":["ax6ev","spimw","bj-denot","bj-axc10v","axc5c4c711toc5"]},{"name":"ax6ev","content":"At least one individual exists. Weaker version of ~ ax6e . When possible, use of this theorem rather than ~ ax6e is preferred since its derivation is much shorter and requires fewer axioms. (Contributed by NM, 3-Aug-2017.)","origin":"thm ax6ev(setvar s0, setvar s1) {\n  |- wex(s0, wceq(cv(s0), cv(s1)))\n  -| diffss(s0, s1)\n} = {\n  mpbir(wex(s0, wceq(cv(s0), cv(s1))), wn(wal(s0, wn(wceq(cv(s0), cv(s1))))))\n  ax6v(s0, s1)\n  df-ex(s0, wceq(cv(s0), cv(s1)))\n}","pretty":"thm ax6ev(setvar s0, setvar s1) {\n  ⊢ ∃(s0, s0 = s1)\n  ⊣ d(s0, s1)\n} = {\n  mpbir(∃(s0, s0 = s1), ¬ ∀(s0, ¬ s0 = s1))\n  ax6v(s0, s1)\n  df-ex(s0, s0 = s1)\n}","parent":["mpbir","ax6v","df-ex"],"children":["exgen","spimeh","exsbim","equs4v","equsv","equsexvw","equid","ax6evr","aeveq","spsbe","spsbeOLD","19.8a","spimv1","equsalv","equsexv","ax6e","axc15","axc15OLD","sbcom2","sbcom2OLD","sb4b","equsb1vOLDOLD","sbtvOLD","euequ","euexOLD","axext3","dfdif3","dmi","1st2val","2nd2val","bnj1468","bj-ssbeq","bj-ax12","bj-equsexval","bj-ssbid2ALT","bj-ax6elem2","bj-alequexv","bj-eqs","bj-spimtv","bj-spimedv","bj-spimvv","bj-speiv","bj-dtrucor2v","bj-sbievw1","bj-sbievw","bj-cleljustab","wl-equsalvw","wl-sbcom2d","wl-euequf","wl-dfclab","axc11n-16","ax12eq","ax12el","ax12inda","ax12v2-o","relexp0eq","ax6e2eq","relopabVD","ax6e2eqVD"]},{"name":"exgen","content":"Rule of existential generalization, similar to universal generalization ~ ax-gen , but valid only if an individual exists. Its proof requires ~ ax-6 in our axiomatization but the equality predicate does not occur in its statement. Some fundamental theorems of predicate calculus can be proven from ~ ax-gen , ~ ax-4 and this theorem alone, not requiring ~ ax-7 or excessive distinct variable conditions. (Contributed by Wolf Lammen, 12-Nov-2017.) (Proof shortened by Wolf Lammen, 9-Dec-2017.)","origin":"thm exgen(setvar s0, wff w0) {\n  |- wex(s0, w0)\n  -| w0\n} = {\n  eximii(s0, w0, wceq(cv(s0), cv(hs0)))\n  ax6ev(s0, hs0)\n  a1i(wceq(cv(s0), cv(hs0)), w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm exgen(setvar s0, wff w0) {\n  ⊢ ∃(s0, w0)\n  ⊣ w0\n} = {\n  eximii(s0, w0, s0 = hs0)\n  ax6ev(s0, hs0)\n  a1i(s0 = hs0, w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["eximii","ax6ev","a1i","diffss.ex","diff.hs0.s"],"children":["extru","19.2","ac6s6"]},{"name":"extru","content":"There exists a variable such that ` T. ` holds; that is, there exists a variable. This corresponds under the standard translation to one of the formulations of the modal axiom (D), the other being ~ 19.2 . (Contributed by Anthony Hart, 13-Sep-2011.) (Proof shortened by BJ, 12-May-2019.)","origin":"thm extru(setvar s0) {\n  |- wex(s0, wtru)\n} = {\n  exgen(s0, wtru)\n  tru()\n}","pretty":"thm extru(setvar s0) {\n  ⊢ ∃(s0, T)\n} = {\n  exgen(s0, wtru)\n  tru()\n}","parent":["exgen","tru"],"children":["euae","nmotru","wl-euae"]},{"name":"19.2","content":"Theorem 19.2 of [Margaris] p. 89. This corresponds to the axiom (D) of modal logic (the other standard formulation being ~ extru ). Note: This proof is very different from Margaris' because we only have Tarski's FOL axiom schemes available at this point. See the later ~ 19.2g for a more conventional proof of a more general result, which uses additional axioms. The reverse implication is the defining property of effective nonfreeness (see ~ df-nf ). (Contributed by NM, 2-Aug-2017.) Remove dependency on ~ ax-7 . (Revised by Wolf Lammen, 4-Dec-2017.)","origin":"thm 19.2(setvar s0, wff w0) {\n  |- wi(wal(s0, w0), wex(s0, w0))\n} = {\n  19.35i(s0, w0, w0)\n  exgen(s0, wi(w0, w0))\n  id(w0)\n}","pretty":"thm 19.2(setvar s0, wff w0) {\n  ⊢ (∀(s0, w0)→ ∃(s0, w0))\n} = {\n  19.35i(s0, w0, w0)\n  exgen(s0, (w0 → w0))\n  id(w0)\n}","parent":["19.35i","exgen","id"],"children":["19.2d","19.39","19.24","19.34","eusv2i","bj-ax6e","bj-spnfw","bj-modald","wl-speqv","wl-19.8eqv","pm10.251","ax6e2eq","ax6e2eqVD"]},{"name":"19.2d","content":"Deduction associated with ~ 19.2 . (Contributed by BJ, 12-May-2019.)","origin":"thm 19.2d(setvar s0, wff w0, wff w1) {\n  |- wi(w0, wex(s0, w1))\n  -| wi(w0, wal(s0, w1))\n} = {\n  syl(w0, wex(s0, w1), wal(s0, w1))\n  19.2(s0, w1)\n}","pretty":"thm 19.2d(setvar s0, wff w0, wff w1) {\n  ⊢ (w0 → ∃(s0, w1))\n  ⊣ (w0 → ∀(s0, w1))\n} = {\n  syl(w0, ∃(s0, w1), ∀(s0, w1))\n  19.2(s0, w1)\n}","parent":["syl","19.2"],"children":["19.8w","nexmo","nexmoOLD","aevdemo"]},{"name":"19.8w","content":"Weak version of ~ 19.8a and instance of ~ 19.2d . (Contributed by NM, 1-Aug-2017.) (Proof shortened by Wolf Lammen, 4-Dec-2017.) (Revised by BJ, 31-Mar-2021.)","origin":"thm 19.8w(setvar s0, wff w0) {\n  |- wi(w0, wex(s0, w0))\n  -| wi(w0, wal(s0, w0))\n} = {\n  19.2d(s0, w0, w0)\n}","pretty":"thm 19.8w(setvar s0, wff w0) {\n  ⊢ (w0 → ∃(s0, w0))\n  ⊣ (w0 → ∀(s0, w0))\n} = {\n  19.2d(s0, w0, w0)\n}","parent":["19.2d"],"children":["19.8v","euae","wl-moae"]},{"name":"19.8v","content":"Version of ~ 19.8a with a disjoint variable condition, requiring fewer axioms. Converse of ~ ax5e . (Contributed by BJ, 12-Mar-2020.)","origin":"thm 19.8v(setvar s0, wff w0) {\n  |- wi(w0, wex(s0, w0))\n  -| diffsw(s0, w0)\n} = {\n  19.8w(s0, w0)\n  ax-5(s0, w0)\n}","pretty":"thm 19.8v(setvar s0, wff w0) {\n  ⊢ (w0 → ∃(s0, w0))\n  ⊣ d(s0, w0)\n} = {\n  19.8w(s0, w0)\n  ax-5(s0, w0)\n}","parent":["19.8w","ax-5"],"children":["19.9v"]},{"name":"19.9v","content":"Version of ~ 19.9 with a disjoint variable condition, requiring fewer axioms. Any formula can be existentially quantified using a variable which it does not contain. See also ~ 19.3v . (Contributed by NM, 28-May-1995.) Remove dependency on ~ ax-7 . (Revised by Wolf Lammen, 4-Dec-2017.)","origin":"thm 19.9v(setvar s0, wff w0) {\n  |- wb(wex(s0, w0), w0)\n  -| diffsw(s0, w0)\n} = {\n  impbii(wex(s0, w0), w0)\n  ax5e(s0, w0)\n  19.8v(s0, w0)\n}","pretty":"thm 19.9v(setvar s0, wff w0) {\n  ⊢ (∃(s0, w0)↔ w0)\n  ⊣ d(s0, w0)\n} = {\n  impbii(∃(s0, w0), w0)\n  ax5e(s0, w0)\n  19.8v(s0, w0)\n}","parent":["impbii","ax5e","19.8v"],"children":["19.3v","19.36v","19.44v","19.45v","zfcndpow","iunrnmptss","volfiniune","bnj937","bnj594","bnj907","bnj1128","bnj1145","coss0","prter2","relopabVD","rfcnnnub"]},{"name":"19.3v","content":"Version of ~ 19.3 with a disjoint variable condition, requiring fewer axioms. Any formula can be universally quantified using a variable which it does not contain. See also ~ 19.9v . (Contributed by Anthony Hart, 13-Sep-2011.) Remove dependency on ~ ax-7 . (Revised by Wolf Lammen, 4-Dec-2017.)","origin":"thm 19.3v(setvar s0, wff w0) {\n  |- wb(wal(s0, w0), w0)\n  -| diffsw(s0, w0)\n} = {\n  bitr4i(wal(s0, w0), w0, wn(wex(s0, wn(w0))))\n  alex(s0, w0)\n  con2bii(w0, wex(s0, wn(w0)))\n  19.9v(s0, wn(w0))\n  diff.wn.s(s0, w0)\n}","pretty":"thm 19.3v(setvar s0, wff w0) {\n  ⊢ (∀(s0, w0)↔ w0)\n  ⊣ d(s0, w0)\n} = {\n  bitr4i(∀(s0, w0), w0, ¬ ∃(s0, ¬ w0))\n  alex(s0, w0)\n  con2bii(w0, ∃(s0, ¬ w0))\n  19.9v(s0, ¬ w0)\n  diff.wn.s(s0, w0)\n}","parent":["bitr4i","alex","con2bii","19.9v","diff.wn.s"],"children":["spvw","19.27v","19.28v","19.37v","axrep1","kmlem14","zfcndrep","zfcndpow","zfcndac","bj-axrep1","bj-snsetex","iooelexlt","dford4","relexp0eq"]},{"name":"spvw","content":"Version of ~ sp when ` x ` does not occur in ` ph ` . Converse of ~ ax-5 . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 10-Apr-2017.) (Proof shortened by Wolf Lammen, 4-Dec-2017.)","origin":"thm spvw(setvar s0, wff w0) {\n  |- wi(wal(s0, w0), w0)\n  -| diffsw(s0, w0)\n} = {\n  biimpi(wal(s0, w0), w0)\n  19.3v(s0, w0)\n}","pretty":"thm spvw(setvar s0, wff w0) {\n  ⊢ (∀(s0, w0)→ w0)\n  ⊣ d(s0, w0)\n} = {\n  biimpi(∀(s0, w0), w0)\n  19.3v(s0, w0)\n}","parent":["biimpi","19.3v"],"children":[]},{"name":"19.39","content":"Theorem 19.39 of [Margaris] p. 90. (Contributed by NM, 12-Mar-1993.)","origin":"thm 19.39(setvar s0, wff w0, wff w1) {\n  |- wi(wi(wex(s0, w0), wex(s0, w1)), wex(s0, wi(w0, w1)))\n} = {\n  sylibr(wi(wex(s0, w0), wex(s0, w1)), wex(s0, wi(w0, w1)), wi(wal(s0, w0), wex(s0, w1)))\n  imim1i(wex(s0, w0), wex(s0, w1), wal(s0, w0))\n  19.2(s0, w0)\n  19.35(s0, w0, w1)\n}","pretty":"thm 19.39(setvar s0, wff w0, wff w1) {\n  ⊢ ((∃(s0, w0)→ ∃(s0, w1))→ ∃(s0,(w0 → w1)))\n} = {\n  sylibr((∃(s0, w0)→ ∃(s0, w1)), ∃(s0,(w0 → w1)), (∀(s0, w0)→ ∃(s0, w1)))\n  imim1i(∃(s0, w0), ∃(s0, w1), ∀(s0, w0))\n  19.2(s0, w0)\n  19.35(s0, w0, w1)\n}","parent":["sylibr","imim1i","19.2","19.35"],"children":[]},{"name":"19.24","content":"Theorem 19.24 of [Margaris] p. 90. (Contributed by NM, 12-Mar-1993.)","origin":"thm 19.24(setvar s0, wff w0, wff w1) {\n  |- wi(wi(wal(s0, w0), wal(s0, w1)), wex(s0, wi(w0, w1)))\n} = {\n  sylibr(wi(wal(s0, w0), wal(s0, w1)), wex(s0, wi(w0, w1)), wi(wal(s0, w0), wex(s0, w1)))\n  imim2i(wal(s0, w0), wal(s0, w1), wex(s0, w1))\n  19.2(s0, w1)\n  19.35(s0, w0, w1)\n}","pretty":"thm 19.24(setvar s0, wff w0, wff w1) {\n  ⊢ ((∀(s0, w0)→ ∀(s0, w1))→ ∃(s0,(w0 → w1)))\n} = {\n  sylibr((∀(s0, w0)→ ∀(s0, w1)), ∃(s0,(w0 → w1)), (∀(s0, w0)→ ∃(s0, w1)))\n  imim2i(∀(s0, w0), ∀(s0, w1), ∃(s0, w1))\n  19.2(s0, w1)\n  19.35(s0, w0, w1)\n}","parent":["sylibr","imim2i","19.2","19.35"],"children":[]},{"name":"19.34","content":"Theorem 19.34 of [Margaris] p. 90. (Contributed by NM, 12-Mar-1993.)","origin":"thm 19.34(setvar s0, wff w0, wff w1) {\n  |- wi(wo(wal(s0, w0), wex(s0, w1)), wex(s0, wo(w0, w1)))\n} = {\n  sylibr(wo(wal(s0, w0), wex(s0, w1)), wex(s0, wo(w0, w1)), wo(wex(s0, w0), wex(s0, w1)))\n  orim1i(wal(s0, w0), wex(s0, w1), wex(s0, w0))\n  19.2(s0, w0)\n  19.43(s0, w0, w1)\n}","pretty":"thm 19.34(setvar s0, wff w0, wff w1) {\n  ⊢ ((∀(s0, w0)∨ ∃(s0, w1))→ ∃(s0,(w0 ∨ w1)))\n} = {\n  sylibr((∀(s0, w0)∨ ∃(s0, w1)), ∃(s0,(w0 ∨ w1)), (∃(s0, w0)∨ ∃(s0, w1)))\n  orim1i(∀(s0, w0), ∃(s0, w1), ∃(s0, w0))\n  19.2(s0, w0)\n  19.43(s0, w0, w1)\n}","parent":["sylibr","orim1i","19.2","19.43"],"children":[]},{"name":"19.36v","content":"Version of ~ 19.36 with a disjoint variable condition instead of a non-freeness hypothesis. (Contributed by NM, 18-Aug-1993.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 17-Jan-2020.)","origin":"thm 19.36v(setvar s0, wff w0, wff w1) {\n  |- wb(wex(s0, wi(w0, w1)), wi(wal(s0, w0), w1))\n  -| diffsw(s0, w1)\n} = {\n  bitri(wex(s0, wi(w0, w1)), wi(wal(s0, w0), w1), wi(wal(s0, w0), wex(s0, w1)))\n  19.35(s0, w0, w1)\n  imbi2i(wal(s0, w0), wex(s0, w1), w1)\n  19.9v(s0, w1)\n}","pretty":"thm 19.36v(setvar s0, wff w0, wff w1) {\n  ⊢ (∃(s0,(w0 → w1))↔(∀(s0, w0)→ w1))\n  ⊣ d(s0, w1)\n} = {\n  bitri(∃(s0,(w0 → w1)), (∀(s0, w0)→ w1), (∀(s0, w0)→ ∃(s0, w1)))\n  19.35(s0, w0, w1)\n  imbi2i(∀(s0, w0), ∃(s0, w1), w1)\n  19.9v(s0, w1)\n}","parent":["bitri","19.35","imbi2i","19.9v"],"children":["19.12vvv","19.12vv","ax13lem2","axext2","vtocl2","vtocl3","bnj1090","bj-spimvwt","bj-spcimdv","bj-spcimdvv","19.36vv"]},{"name":"19.12vvv","content":"Version of ~ 19.12vv with a disjoint variable condition, requiring fewer axioms. See also ~ 19.12 . (Contributed by BJ, 18-Mar-2020.)","origin":"thm 19.12vvv(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wex(s0, wal(s1, wi(w0, w1))), wal(s1, wex(s0, wi(w0, w1))))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  3bitri(wex(s0, wal(s1, wi(w0, w1))), wal(s1, wex(s0, wi(w0, w1))), wex(s0, wi(w0, wal(s1, w1))), wi(wal(s0, w0), wal(s1, w1)))\n  exbii(s0, wal(s1, wi(w0, w1)), wi(w0, wal(s1, w1)))\n  19.21v(s1, w0, w1)\n  19.36v(s0, w0, wal(s1, w1))\n  bitr2i(wi(wal(s0, w0), wal(s1, w1)), wal(s1, wex(s0, wi(w0, w1))), wal(s1, wi(wal(s0, w0), w1)))\n  albii(s1, wex(s0, wi(w0, w1)), wi(wal(s0, w0), w1))\n  19.36v(s0, w0, w1)\n  19.21v(s1, wal(s0, w0), w1)\n  diff.wal.s(s0, s1, w1)\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","pretty":"thm 19.12vvv(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∃(s0, ∀(s1,(w0 → w1)))↔ ∀(s1, ∃(s0,(w0 → w1))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  3bitri(∃(s0, ∀(s1,(w0 → w1))), ∀(s1, ∃(s0,(w0 → w1))), ∃(s0,(w0 → ∀(s1, w1))), (∀(s0, w0)→ ∀(s1, w1)))\n  exbii(s0, ∀(s1,(w0 → w1)), (w0 → ∀(s1, w1)))\n  19.21v(s1, w0, w1)\n  19.36v(s0, w0, ∀(s1, w1))\n  bitr2i((∀(s0, w0)→ ∀(s1, w1)), ∀(s1, ∃(s0,(w0 → w1))), ∀(s1,(∀(s0, w0)→ w1)))\n  albii(s1, ∃(s0,(w0 → w1)), (∀(s0, w0)→ w1))\n  19.36v(s0, w0, w1)\n  19.21v(s1, ∀(s0, w0), w1)\n  diff.wal.s(s0, s1, w1)\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","parent":["3bitri","exbii","19.21v","19.36v","bitr2i","albii","diff.wal.s","diffss.ex"],"children":[]},{"name":"19.27v","content":"Version of ~ 19.27 with a disjoint variable condition, requiring fewer axioms. (Contributed by NM, 3-Jun-2004.)","origin":"thm 19.27v(setvar s0, wff w0, wff w1) {\n  |- wb(wal(s0, wa(w0, w1)), wa(wal(s0, w0), w1))\n  -| diffsw(s0, w1)\n} = {\n  bitri(wal(s0, wa(w0, w1)), wa(wal(s0, w0), w1), wa(wal(s0, w0), wal(s0, w1)))\n  19.26(s0, w0, w1)\n  anbi2i(wal(s0, w0), wal(s0, w1), w1)\n  19.3v(s0, w1)\n}","pretty":"thm 19.27v(setvar s0, wff w0, wff w1) {\n  ⊢ (∀(s0,(w0 ∧ w1))↔(∀(s0, w0)∧ w1))\n  ⊣ d(s0, w1)\n} = {\n  bitri(∀(s0,(w0 ∧ w1)), (∀(s0, w0)∧ w1), (∀(s0, w0)∧ ∀(s0, w1)))\n  19.26(s0, w0, w1)\n  anbi2i(∀(s0, w0), ∀(s0, w1), w1)\n  19.3v(s0, w1)\n}","parent":["bitri","19.26","anbi2i","19.3v"],"children":["rexrsb"]},{"name":"19.28v","content":"Version of ~ 19.28 with a disjoint variable condition, requiring fewer axioms. (Contributed by NM, 25-Mar-2004.)","origin":"thm 19.28v(setvar s0, wff w0, wff w1) {\n  |- wb(wal(s0, wa(w0, w1)), wa(w0, wal(s0, w1)))\n  -| diffsw(s0, w0)\n} = {\n  bitri(wal(s0, wa(w0, w1)), wa(w0, wal(s0, w1)), wa(wal(s0, w0), wal(s0, w1)))\n  19.26(s0, w0, w1)\n  anbi1i(wal(s0, w0), wal(s0, w1), w0)\n  19.3v(s0, w0)\n}","pretty":"thm 19.28v(setvar s0, wff w0, wff w1) {\n  ⊢ (∀(s0,(w0 ∧ w1))↔(w0 ∧ ∀(s0, w1)))\n  ⊣ d(s0, w0)\n} = {\n  bitri(∀(s0,(w0 ∧ w1)), (w0 ∧ ∀(s0, w1)), (∀(s0, w0)∧ ∀(s0, w1)))\n  19.26(s0, w0, w1)\n  anbi1i(∀(s0, w0), ∀(s0, w1), w0)\n  19.3v(s0, w0)\n}","parent":["bitri","19.26","anbi1i","19.3v"],"children":["reu6","dfer2","kmlem14","kmlem15","bnj1176","bnj1186","19.28vv"]},{"name":"19.37v","content":"Version of ~ 19.37 with a disjoint variable condition, requiring fewer axioms. (Contributed by NM, 21-Jun-1993.)","origin":"thm 19.37v(setvar s0, wff w0, wff w1) {\n  |- wb(wex(s0, wi(w0, w1)), wi(w0, wex(s0, w1)))\n  -| diffsw(s0, w0)\n} = {\n  bitri(wex(s0, wi(w0, w1)), wi(w0, wex(s0, w1)), wi(wal(s0, w0), wex(s0, w1)))\n  19.35(s0, w0, w1)\n  imbi1i(wal(s0, w0), wex(s0, w1), w0)\n  19.3v(s0, w0)\n}","pretty":"thm 19.37v(setvar s0, wff w0, wff w1) {\n  ⊢ (∃(s0,(w0 → w1))↔(w0 → ∃(s0, w1)))\n  ⊣ d(s0, w0)\n} = {\n  bitri(∃(s0,(w0 → w1)), (w0 → ∃(s0, w1)), (∀(s0, w0)→ ∃(s0, w1)))\n  19.35(s0, w0, w1)\n  imbi1i(∀(s0, w0), ∃(s0, w1), w0)\n  19.3v(s0, w0)\n}","parent":["bitri","19.35","imbi1i","19.3v"],"children":["eqvincg","rmoanim","axrep5","fvn0ssdmfun","kmlem14","kmlem15","bnj132","bnj1098","bnj150","bnj865","bnj996","bnj1021","bnj1090","bnj1176","bj-axrep5","cnvssco","refimssco","19.37vv","pm11.61","relopabVD"]},{"name":"19.44v","content":"Version of ~ 19.44 with a disjoint variable condition, requiring fewer axioms. (Contributed by NM, 12-Mar-1993.)","origin":"thm 19.44v(setvar s0, wff w0, wff w1) {\n  |- wb(wex(s0, wo(w0, w1)), wo(wex(s0, w0), w1))\n  -| diffsw(s0, w1)\n} = {\n  bitri(wex(s0, wo(w0, w1)), wo(wex(s0, w0), w1), wo(wex(s0, w0), wex(s0, w1)))\n  19.43(s0, w0, w1)\n  orbi2i(wex(s0, w0), wex(s0, w1), w1)\n  19.9v(s0, w1)\n}","pretty":"thm 19.44v(setvar s0, wff w0, wff w1) {\n  ⊢ (∃(s0,(w0 ∨ w1))↔(∃(s0, w0)∨ w1))\n  ⊣ d(s0, w1)\n} = {\n  bitri(∃(s0,(w0 ∨ w1)), (∃(s0, w0)∨ w1), (∃(s0, w0)∨ ∃(s0, w1)))\n  19.43(s0, w0, w1)\n  orbi2i(∃(s0, w0), ∃(s0, w1), w1)\n  19.9v(s0, w1)\n}","parent":["bitri","19.43","orbi2i","19.9v"],"children":["grothprim"]},{"name":"19.45v","content":"Version of ~ 19.45 with a disjoint variable condition, requiring fewer axioms. (Contributed by NM, 12-Mar-1993.)","origin":"thm 19.45v(setvar s0, wff w0, wff w1) {\n  |- wb(wex(s0, wo(w0, w1)), wo(w0, wex(s0, w1)))\n  -| diffsw(s0, w0)\n} = {\n  bitri(wex(s0, wo(w0, w1)), wo(w0, wex(s0, w1)), wo(wex(s0, w0), wex(s0, w1)))\n  19.43(s0, w0, w1)\n  orbi1i(wex(s0, w0), wex(s0, w1), w0)\n  19.9v(s0, w0)\n}","pretty":"thm 19.45v(setvar s0, wff w0, wff w1) {\n  ⊢ (∃(s0,(w0 ∨ w1))↔(w0 ∨ ∃(s0, w1)))\n  ⊣ d(s0, w0)\n} = {\n  bitri(∃(s0,(w0 ∨ w1)), (w0 ∨ ∃(s0, w1)), (∃(s0, w0)∨ ∃(s0, w1)))\n  19.43(s0, w0, w1)\n  orbi1i(∃(s0, w0), ∃(s0, w1), w0)\n  19.9v(s0, w0)\n}","parent":["bitri","19.43","orbi1i","19.9v"],"children":[]},{"name":"spimeh","content":"Existential introduction, using implicit substitution. Compare Lemma 14 of [Tarski] p. 70. (Contributed by NM, 7-Aug-1994.) (Proof shortened by Wolf Lammen, 10-Dec-2017.)","origin":"thm spimeh(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(w0, wex(s0, w1))\n  -| wi(w0, wal(s0, w0))\n  -| wi(wceq(cv(s0), cv(s1)), wi(w0, w1))\n  -| diffss(s0, s1)\n} = {\n  syl(w0, wex(s0, w1), wal(s0, w0))\n  19.35i(s0, w0, w1)\n  eximii(s0, wi(w0, w1), wceq(cv(s0), cv(s1)))\n  ax6ev(s0, s1)\n}","pretty":"thm spimeh(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (w0 → ∃(s0, w1))\n  ⊣ (w0 → ∀(s0, w0))\n  ⊣ (s0 = s1 →(w0 → w1))\n  ⊣ d(s0, s1)\n} = {\n  syl(w0, ∃(s0, w1), ∀(s0, w0))\n  19.35i(s0, w0, w1)\n  eximii(s0, (w0 → w1), s0 = s1)\n  ax6ev(s0, s1)\n}","parent":["syl","19.35i","eximii","ax6ev"],"children":["bj-spimevw","bj-cbvexiw"]},{"name":"spimw","content":"Specialization. Lemma 8 of [KalishMontague] p. 87. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 19-Apr-2017.) (Proof shortened by Wolf Lammen, 7-Aug-2017.)","origin":"thm spimw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), w1)\n  -| wi(wn(w1), wal(s0, wn(w1)))\n  -| wi(wceq(cv(s0), cv(s1)), wi(w0, w1))\n  -| diffss(s0, s1)\n} = {\n  ax-mp(wi(wal(s0, w0), w1), wn(wal(s0, wn(wceq(cv(s0), cv(s1))))))\n  ax6v(s0, s1)\n  spimfw(s0, s1, w0, w1)\n}","pretty":"thm spimw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ w1)\n  ⊣ (¬ w1 → ∀(s0, ¬ w1))\n  ⊣ (s0 = s1 →(w0 → w1))\n  ⊣ d(s0, s1)\n} = {\n  ax-mp((∀(s0, w0)→ w1), ¬ ∀(s0, ¬ s0 = s1))\n  ax6v(s0, s1)\n  spimfw(s0, s1, w0, w1)\n}","parent":["ax-mp","ax6v","spimfw"],"children":["spimvw","spnfw","cbvaliw","spfw"]},{"name":"spimvw","content":"Specialization. Lemma 8 of [KalishMontague] p. 87. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 9-Apr-2017.)","origin":"thm spimvw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), w1)\n  -| wi(wceq(cv(s0), cv(s1)), wi(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n} = {\n  spimw(s0, s1, w0, w1)\n  ax-5(s0, wn(w1))\n  diff.wn.s(s0, w1)\n}","pretty":"thm spimvw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ w1)\n  ⊣ (s0 = s1 →(w0 → w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n} = {\n  spimw(s0, s1, w0, w1)\n  ax-5(s0, ¬ w1)\n  diff.wn.s(s0, w1)\n}","parent":["spimw","ax-5","diff.wn.s"],"children":["spvv","cbvalivw","alcomiw","axc16i","reu6","el","fvn0ssdmfun","bj-el","bj-ax9-2","aev-o","axc11next","funressnvmo","funressnvmoOLD"]},{"name":"spvv","content":"Version of ~ spv with a disjoint variable condition, which does not require ~ ax-7 , ~ ax-12 , ~ ax-13 . (Contributed by BJ, 31-May-2019.)","origin":"thm spvv(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), w1)\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n} = {\n  spimvw(s0, s1, w0, w1)\n  biimpd(wceq(cv(s0), cv(s1)), w0, w1)\n}","pretty":"thm spvv(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ w1)\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n} = {\n  spimvw(s0, s1, w0, w1)\n  biimpd(s0 = s1, w0, w1)\n}","parent":["spimvw","biimpd"],"children":["ru","nalset","bj-chvarvv","bj-ru0"]},{"name":"spnfw","content":"Weak version of ~ sp . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 1-Aug-2017.) (Proof shortened by Wolf Lammen, 13-Aug-2017.)","origin":"thm spnfw(setvar s0, wff w0) {\n  |- wi(wal(s0, w0), w0)\n  -| wi(wn(w0), wal(s0, wn(w0)))\n} = {\n  spimw(s0, hs0, w0, w0)\n  idd(wceq(cv(s0), cv(hs0)), w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm spnfw(setvar s0, wff w0) {\n  ⊢ (∀(s0, w0)→ w0)\n  ⊣ (¬ w0 → ∀(s0, ¬ w0))\n} = {\n  spimw(s0, hs0, w0, w0)\n  idd(s0 = hs0, w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["spimw","idd","diffss.ex","diff.hs0.s"],"children":["spfalw"]},{"name":"spfalw","content":"Version of ~ sp when ` ph ` is false. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 23-Apr-2017.) (Proof shortened by Wolf Lammen, 25-Dec-2017.)","origin":"thm spfalw(setvar s0, wff w0) {\n  |- wi(wal(s0, w0), w0)\n  -| wn(w0)\n} = {\n  spnfw(s0, w0)\n  hbth(s0, wn(w0))\n}","pretty":"thm spfalw(setvar s0, wff w0) {\n  ⊢ (∀(s0, w0)→ w0)\n  ⊣ ¬ w0\n} = {\n  spnfw(s0, w0)\n  hbth(s0, ¬ w0)\n}","parent":["spnfw","hbth"],"children":["ax6dgen"]},{"name":"exsbim","content":"One direction of the equivalence in ~ exsb is based on fewer axioms. (Contributed by Wolf Lammen, 2-Mar-2023.)","origin":"thm exsbim(setvar s0, setvar s1, wff w0) {\n  |- wi(wex(s0, wal(s1, wi(wceq(cv(s1), cv(s0)), w0))), wex(s1, w0))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w0)\n} = {\n  exlimiv(s0, wal(s1, wi(wceq(cv(s1), cv(s0)), w0)), wex(s1, w0))\n  mpi(wal(s1, wi(wceq(cv(s1), cv(s0)), w0)), wex(s1, w0), wex(s1, wceq(cv(s1), cv(s0))))\n  ax6ev(s1, s0)\n  exim(s1, wceq(cv(s1), cv(s0)), w0)\n  diff.wex.s(s0, s1, w0)\n  diffss.ex(s1, s0)\n}","pretty":"thm exsbim(setvar s0, setvar s1, wff w0) {\n  ⊢ (∃(s0, ∀(s1,(s1 = s0 → w0)))→ ∃(s1, w0))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w0)\n} = {\n  exlimiv(s0, ∀(s1,(s1 = s0 → w0)), ∃(s1, w0))\n  mpi(∀(s1,(s1 = s0 → w0)), ∃(s1, w0), ∃(s1, s1 = s0))\n  ax6ev(s1, s0)\n  exim(s1, s1 = s0, w0)\n  diff.wex.s(s0, s1, w0)\n  diffss.ex(s1, s0)\n}","parent":["exlimiv","mpi","ax6ev","exim","diff.wex.s","diffss.ex"],"children":["spsbe","eu6im"]},{"name":"equs4v","content":"Version of ~ equs4 with a disjoint variable condition, which requires fewer axioms. (Contributed by BJ, 31-May-2019.)","origin":"thm equs4v(setvar s0, setvar s1, wff w0) {\n  |- wi(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), wex(s0, wa(wceq(cv(s0), cv(s1)), w0)))\n  -| diffss(s0, s1)\n} = {\n  mpi(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), wex(s0, wa(wceq(cv(s0), cv(s1)), w0)), wex(s0, wceq(cv(s0), cv(s1))))\n  ax6ev(s0, s1)\n  exintr(s0, wceq(cv(s0), cv(s1)), w0)\n}","pretty":"thm equs4v(setvar s0, setvar s1, wff w0) {\n  ⊢ (∀(s0,(s0 = s1 → w0))→ ∃(s0,(s0 = s1 ∧ w0)))\n  ⊣ d(s0, s1)\n} = {\n  mpi(∀(s0,(s0 = s1 → w0)), ∃(s0,(s0 = s1 ∧ w0)), ∃(s0, s0 = s1))\n  ax6ev(s0, s1)\n  exintr(s0, s0 = s1, w0)\n}","parent":["mpi","ax6ev","exintr"],"children":["sb2vOLDOLD","sb2vOLDALT","bj-sb56","bj-equs45fv"]},{"name":"equsv","content":"If a formula does not contain a variable ` x ` , then it is equivalent to the corresponding prototype of substitution with a fresh variable (see ~ sb6 ). (Contributed by BJ, 23-Jul-2023.)","origin":"thm equsv(setvar s0, setvar s1, wff w0) {\n  |- wb(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), w0)\n  -| diffss(s0, s1)\n  -| diffsw(s0, w0)\n} = {\n  bitr4i(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), w0, wi(wex(s0, wceq(cv(s0), cv(s1))), w0))\n  19.23v(s0, wceq(cv(s0), cv(s1)), w0)\n  a1bi(w0, wex(s0, wceq(cv(s0), cv(s1))))\n  ax6ev(s0, s1)\n}","pretty":"thm equsv(setvar s0, setvar s1, wff w0) {\n  ⊢ (∀(s0,(s0 = s1 → w0))↔ w0)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w0)\n} = {\n  bitr4i(∀(s0,(s0 = s1 → w0)), w0, (∃(s0, s0 = s1)→ w0))\n  19.23v(s0, s0 = s1, w0)\n  a1bi(w0, ∃(s0, s0 = s1))\n  ax6ev(s0, s1)\n}","parent":["bitr4i","19.23v","a1bi","ax6ev"],"children":["equsalvw"]},{"name":"equsalvw","content":"Version of ~ equsalv with a disjoint variable condition, and of ~ equsal with two disjoint variable conditions, which requires fewer axioms. See also the dual form ~ equsexvw . (Contributed by BJ, 31-May-2019.)","origin":"thm equsalvw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), w1)\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n} = {\n  bitri(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), w1, wal(s0, wi(wceq(cv(s0), cv(s1)), w1)))\n  albii(s0, wi(wceq(cv(s0), cv(s1)), w0), wi(wceq(cv(s0), cv(s1)), w1))\n  pm5.74i(wceq(cv(s0), cv(s1)), w0, w1)\n  equsv(s0, s1, w1)\n}","pretty":"thm equsalvw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0,(s0 = s1 → w0))↔ w1)\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n} = {\n  bitri(∀(s0,(s0 = s1 → w0)), w1, ∀(s0,(s0 = s1 → w1)))\n  albii(s0, (s0 = s1 → w0), (s0 = s1 → w1))\n  pm5.74i(s0 = s1, w0, w1)\n  equsv(s0, s1, w1)\n}","parent":["bitri","albii","pm5.74i","equsv"],"children":["equvelv","sb6","sbievw","ax13lem2","reu8","asymref2","intirr","fun11","fv3","fpwwe2lem12","bj-dvelimdv","bj-dvelimdv1","wl-dfralflem","undmrnresiss","pm13.192"]},{"name":"equsexvw","content":"Version of ~ equsexv with a disjoint variable condition, and of ~ equsex with two disjoint variable conditions, which requires fewer axioms. See also the dual form ~ equsalvw . (Contributed by BJ, 31-May-2019.)","origin":"thm equsexvw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wex(s0, wa(wceq(cv(s0), cv(s1)), w0)), w1)\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n} = {\n  bitri(wex(s0, wa(wceq(cv(s0), cv(s1)), w0)), w1, wex(s0, wa(wceq(cv(s0), cv(s1)), w1)))\n  exbii(s0, wa(wceq(cv(s0), cv(s1)), w0), wa(wceq(cv(s0), cv(s1)), w1))\n  pm5.32i(wceq(cv(s0), cv(s1)), w0, w1)\n  mpbiran(wex(s0, wa(wceq(cv(s0), cv(s1)), w1)), w1, wex(s0, wceq(cv(s0), cv(s1))))\n  ax6ev(s0, s1)\n  19.41v(s0, wceq(cv(s0), cv(s1)), w1)\n}","pretty":"thm equsexvw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∃(s0,(s0 = s1 ∧ w0))↔ w1)\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n} = {\n  bitri(∃(s0,(s0 = s1 ∧ w0)), w1, ∃(s0,(s0 = s1 ∧ w1)))\n  exbii(s0, (s0 = s1 ∧ w0), (s0 = s1 ∧ w1))\n  pm5.32i(s0 = s1, w0, w1)\n  mpbiran(∃(s0,(s0 = s1 ∧ w1)), w1, ∃(s0, s0 = s1))\n  ax6ev(s0, s1)\n  19.41v(s0, s0 = s1, w1)\n}","parent":["bitri","exbii","pm5.32i","mpbiran","ax6ev","19.41v"],"children":["equvinv","cleljust","sbhypf","axsep","dfid3","opeliunxp","imai","coi1","opabex3d","opabex3","fsplit","mapsnend","dfac5lem1","dfac5lem3","elfuns","bj-axsep","cleljust2"]},{"name":"cbvaliw","content":"Change bound variable. Uses only Tarski's FOL axiom schemes. Part of Lemma 7 of [KalishMontague] p. 86. (Contributed by NM, 19-Apr-2017.)","origin":"thm cbvaliw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), wal(s1, w1))\n  -| wi(wal(s0, w0), wal(s1, wal(s0, w0)))\n  -| wi(wn(w1), wal(s0, wn(w1)))\n  -| wi(wceq(cv(s0), cv(s1)), wi(w0, w1))\n  -| diffss(s0, s1)\n} = {\n  alrimih(s1, wal(s0, w0), w1)\n  spimw(s0, s1, w0, w1)\n}","pretty":"thm cbvaliw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ ∀(s1, w1))\n  ⊣ (∀(s0, w0)→ ∀(s1, ∀(s0, w0)))\n  ⊣ (¬ w1 → ∀(s0, ¬ w1))\n  ⊣ (s0 = s1 →(w0 → w1))\n  ⊣ d(s0, s1)\n} = {\n  alrimih(s1, ∀(s0, w0), w1)\n  spimw(s0, s1, w0, w1)\n}","parent":["alrimih","spimw"],"children":["spfw","cbvalw"]},{"name":"cbvalivw","content":"Change bound variable. Uses only Tarski's FOL axiom schemes. Part of Lemma 7 of [KalishMontague] p. 86. (Contributed by NM, 9-Apr-2017.)","origin":"thm cbvalivw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, w0), wal(s1, w1))\n  -| wi(wceq(cv(s0), cv(s1)), wi(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  alrimiv(s1, wal(s0, w0), w1)\n  spimvw(s0, s1, w0, w1)\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","pretty":"thm cbvalivw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0, w0)→ ∀(s1, w1))\n  ⊣ (s0 = s1 →(w0 → w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  alrimiv(s1, ∀(s0, w0), w1)\n  spimvw(s0, s1, w0, w1)\n  diff.wal.s(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","parent":["alrimiv","spimvw","diff.wal.s","diffss.ex"],"children":["alcomiw","cbvaev","wl-cbvmotv","axc11next"]}]}