{"index":1153,"title":"Set theory: miscellaneous","content":"Miscellaneous theorems of set theory.","blocks":[{"name":"bj-disj2r","content":"Relative version of ~ ssdifin0 , allowing a biconditional, and of ~ disj2 . This proof does not rely, even indirectly, on ~ ssdifin0 nor ~ disj2 . (Contributed by BJ, 11-Nov-2021.)","origin":"thm bj-disj2r(class c0, class c1, class c2) {\n  |- wb(wss(cin(c0, c1), cdif(c1, c2)), wceq(cin(cin(c0, c2), c1), emptycls))\n} = {\n  3bitr2i(wss(cin(c0, c1), cdif(c1, c2)), wceq(cin(cin(c0, c2), c1), emptycls), wceq(cin(c0, c1), cdif(cin(c0, c1), c2)), wceq(cin(cin(c0, c1), c2), emptycls))\n  3bitri(wss(cin(c0, c1), cdif(c1, c2)), wceq(cin(c0, c1), cdif(cin(c0, c1), c2)), wceq(cin(cin(c0, c1), cdif(c1, c2)), cin(c0, c1)), wceq(cdif(cin(c0, c1), c2), cin(c0, c1)))\n  df-ss(cin(c0, c1), cdif(c1, c2))\n  eqeq1i(cin(cin(c0, c1), cdif(c1, c2)), cin(c0, c1), cdif(cin(c0, c1), c2))\n  eqtri(cin(cin(c0, c1), cdif(c1, c2)), cdif(cin(c0, c1), c2), cdif(cin(cin(c0, c1), c1), c2))\n  indif2(cin(c0, c1), c1, c2)\n  difeq1i(cin(cin(c0, c1), c1), c2, cin(c0, c1))\n  eqssi(cin(cin(c0, c1), c1), cin(c0, c1))\n  inss1(cin(c0, c1), c1)\n  ssini(cin(c0, c1), cin(c0, c1), c1)\n  ssid(cin(c0, c1))\n  inss2(c0, c1)\n  eqcom(cdif(cin(c0, c1), c2), cin(c0, c1))\n  disj3(cin(c0, c1), c2)\n  eqeq1i(cin(cin(c0, c1), c2), emptycls, cin(cin(c0, c2), c1))\n  in32(c0, c1, c2)\n}","pretty":"thm bj-disj2r(class c0, class c1, class c2) {\n  âŠ¢ ((c0 â‹‚ c1)âŠ†(c1 \\ c2)â†”((c0 â‹‚ c2)â‹‚ c1)= âˆ…)\n} = {\n  3bitr2i((c0 â‹‚ c1)âŠ†(c1 \\ c2), ((c0 â‹‚ c2)â‹‚ c1)= âˆ…, (c0 â‹‚ c1)=((c0 â‹‚ c1)\\ c2), ((c0 â‹‚ c1)â‹‚ c2)= âˆ…)\n  3bitri((c0 â‹‚ c1)âŠ†(c1 \\ c2), (c0 â‹‚ c1)=((c0 â‹‚ c1)\\ c2), ((c0 â‹‚ c1)â‹‚(c1 \\ c2))=(c0 â‹‚ c1), ((c0 â‹‚ c1)\\ c2)=(c0 â‹‚ c1))\n  df-ss((c0 â‹‚ c1), (c1 \\ c2))\n  eqeq1i(((c0 â‹‚ c1)â‹‚(c1 \\ c2)), (c0 â‹‚ c1), ((c0 â‹‚ c1)\\ c2))\n  eqtri(((c0 â‹‚ c1)â‹‚(c1 \\ c2)), ((c0 â‹‚ c1)\\ c2), (((c0 â‹‚ c1)â‹‚ c1)\\ c2))\n  indif2((c0 â‹‚ c1), c1, c2)\n  difeq1i(((c0 â‹‚ c1)â‹‚ c1), c2, (c0 â‹‚ c1))\n  eqssi(((c0 â‹‚ c1)â‹‚ c1), (c0 â‹‚ c1))\n  inss1((c0 â‹‚ c1), c1)\n  ssini((c0 â‹‚ c1), (c0 â‹‚ c1), c1)\n  ssid((c0 â‹‚ c1))\n  inss2(c0, c1)\n  eqcom(((c0 â‹‚ c1)\\ c2), (c0 â‹‚ c1))\n  disj3((c0 â‹‚ c1), c2)\n  eqeq1i(((c0 â‹‚ c1)â‹‚ c2), emptycls, ((c0 â‹‚ c2)â‹‚ c1))\n  in32(c0, c1, c2)\n}","parent":["3bitr2i","3bitri","df-ss","eqeq1i","eqtri","indif2","difeq1i","eqssi","inss1","ssini","ssid","inss2","eqcom","disj3","in32"],"children":["bj-sscon"]},{"name":"bj-sscon","content":"Contraposition law for relative subsets. Relative and generalized version of ~ ssconb , which it can shorten, as well as ~ conss2 . (Contributed by BJ, 11-Nov-2021.)","origin":"thm bj-sscon(class c0, class c1, class c2) {\n  |- wb(wss(cin(c0, c1), cdif(c1, c2)), wss(cin(c2, c1), cdif(c1, c0)))\n} = {\n  3bitr4i(wss(cin(c0, c1), cdif(c1, c2)), wss(cin(c2, c1), cdif(c1, c0)), wceq(cin(cin(c0, c2), c1), emptycls), wceq(cin(cin(c2, c0), c1), emptycls))\n  eqeq1i(cin(cin(c0, c2), c1), emptycls, cin(cin(c2, c0), c1))\n  ineq1i(cin(c0, c2), c1, cin(c2, c0))\n  incom(c0, c2)\n  bj-disj2r(c0, c1, c2)\n  bj-disj2r(c2, c1, c0)\n}","pretty":"thm bj-sscon(class c0, class c1, class c2) {\n  âŠ¢ ((c0 â‹‚ c1)âŠ†(c1 \\ c2)â†”(c2 â‹‚ c1)âŠ†(c1 \\ c0))\n} = {\n  3bitr4i((c0 â‹‚ c1)âŠ†(c1 \\ c2), (c2 â‹‚ c1)âŠ†(c1 \\ c0), ((c0 â‹‚ c2)â‹‚ c1)= âˆ…, ((c2 â‹‚ c0)â‹‚ c1)= âˆ…)\n  eqeq1i(((c0 â‹‚ c2)â‹‚ c1), emptycls, ((c2 â‹‚ c0)â‹‚ c1))\n  ineq1i((c0 â‹‚ c2), c1, (c2 â‹‚ c0))\n  incom(c0, c2)\n  bj-disj2r(c0, c1, c2)\n  bj-disj2r(c2, c1, c0)\n}","parent":["3bitr4i","eqeq1i","ineq1i","incom","bj-disj2r"],"children":[]},{"name":"bj-vjust","content":"Justification theorem for ~ bj-df-v . See also ~ vjust . (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-vjust(setvar s0, setvar s1) {\n  |- wceq(cab(s0, wtru), cab(s1, wtru))\n} = {\n  eqriv(hs0, cab(s0, wtru), cab(s1, wtru))\n  bitri(wcel(cv(hs0), cab(s0, wtru)), wcel(cv(hs0), cab(s1, wtru)), wsb(hs0, s0, wtru))\n  df-clab(hs0, s0, wtru)\n  3bitr4ri(wsb(hs0, s0, wtru), wcel(cv(hs0), cab(s1, wtru)), wsb(hs0, s1, wtru), wtru)\n  sbv(hs0, s1, wtru)\n  df-clab(hs0, s1, wtru)\n  sbv(hs0, s0, wtru)\n  diff.hs0.c(cab(s0, wtru))\n  diff.hs0.c(cab(s1, wtru))\n  diff.wtru.s(s1)\n  diff.wtru.s(s0)\n}","pretty":"thm bj-vjust(setvar s0, setvar s1) {\n  âŠ¢ { s0 | T } = { s1 | T }\n} = {\n  eqriv(hs0, { s0 | T }, { s1 | T })\n  bitri(hs0 âˆˆ { s0 | T }, hs0 âˆˆ { s1 | T }, [hs0 / s0]T)\n  df-clab(hs0, s0, wtru)\n  3bitr4ri([hs0 / s0]T, hs0 âˆˆ { s1 | T }, [hs0 / s1]T, wtru)\n  sbv(hs0, s1, wtru)\n  df-clab(hs0, s1, wtru)\n  sbv(hs0, s0, wtru)\n  diff.hs0.c({ s0 | T })\n  diff.hs0.c({ s1 | T })\n  diff.wtru.s(s1)\n  diff.wtru.s(s0)\n}","parent":["eqriv","bitri","df-clab","3bitr4ri","sbv","diff.hs0.c","diff.wtru.s"],"children":[]},{"name":"bj-df-v","content":"Alternate definition of the universal class. Actually, the current definition ~ df-v should be proved from this one, and ~ vex should be proved from this proposed definition together with ~ bj-vexw , which would remove from ~ vex dependency on ~ ax-13 (see also comment of ~ bj-vexw ). (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-df-v(setvar s0) {\n  |- wceq(universe, cab(s0, wtru))\n} = {\n  mpgbir(hs0, wceq(universe, cab(s0, wtru)), wb(wcel(cv(hs0), universe), wcel(cv(hs0), cab(s0, wtru))))\n  dfcleq(hs0, universe, cab(s0, wtru))\n  2th(wcel(cv(hs0), universe), wcel(cv(hs0), cab(s0, wtru)))\n  vex(hs0)\n  bj-vexw(hs0, s0, wtru)\n  tru()\n  diff.hs0.c(universe)\n  diff.hs0.c(cab(s0, wtru))\n}","pretty":"thm bj-df-v(setvar s0) {\n  âŠ¢ ğ•Œ = { s0 | T }\n} = {\n  mpgbir(hs0, ğ•Œ = { s0 | T }, (hs0 âˆˆ ğ•Œ â†” hs0 âˆˆ { s0 | T }))\n  dfcleq(hs0, universe, { s0 | T })\n  2th(hs0 âˆˆ ğ•Œ, hs0 âˆˆ { s0 | T })\n  vex(hs0)\n  bj-vexw(hs0, s0, wtru)\n  tru()\n  diff.hs0.c(universe)\n  diff.hs0.c({ s0 | T })\n}","parent":["mpgbir","dfcleq","2th","vex","bj-vexw","tru","diff.hs0.c"],"children":[]},{"name":"bj-df-nul","content":"Alternate definition of the empty class/set. (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-df-nul(setvar s0) {\n  |- wceq(emptycls, cab(s0, wfal))\n} = {\n  bj-abbi2i(s0, emptycls, wfal)\n  bifal(wcel(cv(s0), emptycls))\n  noel(cv(s0))\n  diff.emptycls.s(s0)\n}","pretty":"thm bj-df-nul(setvar s0) {\n  âŠ¢ âˆ… = { s0 | F }\n} = {\n  bj-abbi2i(s0, emptycls, wfal)\n  bifal(s0 âˆˆ âˆ…)\n  noel(s0)\n  diff.emptycls.s(s0)\n}","parent":["bj-abbi2i","bifal","noel","diff.emptycls.s"],"children":[]},{"name":"bj-nul","content":"Two formulations of the axiom of the empty set ~ ax-nul . Proposal: place it right before ~ ax-nul . (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-nul(setvar s0, setvar s1) {\n  |- wb(wcel(emptycls, universe), wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  -| diffss(s0, s1)\n} = {\n  bitri(wcel(emptycls, universe), wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), wex(s0, wceq(cv(s0), emptycls)))\n  isset(s0, emptycls)\n  exbii(s0, wceq(cv(s0), emptycls), wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  eq0(s1, cv(s0))\n  diff.emptycls.s(s0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm bj-nul(setvar s0, setvar s1) {\n  âŠ¢ (âˆ… âˆˆ ğ•Œ â†” âˆƒ(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)))\n  âŠ£ d(s0, s1)\n} = {\n  bitri(âˆ… âˆˆ ğ•Œ, âˆƒ(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)), âˆƒ(s0, s0 = âˆ…))\n  isset(s0, emptycls)\n  exbii(s0, s0 = âˆ…, âˆ€(s1, Â¬ s1 âˆˆ s0))\n  eq0(s1, s0)\n  diff.emptycls.s(s0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["bitri","isset","exbii","eq0","diff.emptycls.s","diff.cv.s","diffss.ex"],"children":[]},{"name":"bj-nuliota","content":"Definition of the empty set using the definite description binder. See also ~ bj-nuliotaALT . (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-nuliota(setvar s0, setvar s1) {\n  |- wceq(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  -| diffss(s0, s1)\n} = {\n  eqcomi(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  mpgbi(s1, wceq(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), emptycls), wn(wcel(cv(s1), emptycls)))\n  mp2an(wb(wal(s1, wn(wcel(cv(s1), emptycls))), wceq(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), emptycls)), wcel(emptycls, universe), weu(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  mpbi(weu(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), weu(s0, wceq(cv(s0), emptycls)))\n  eueqi(s0, emptycls)\n  0ex()\n  eubii(s0, wceq(cv(s0), emptycls), wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  eq0(s1, cv(s0))\n  iota2(s0, emptycls, universe, wal(s1, wn(wcel(cv(s1), cv(s0)))), wal(s1, wn(wcel(cv(s1), emptycls))))\n  albidv(s1, wceq(cv(s0), emptycls), wn(wcel(cv(s1), cv(s0))), wn(wcel(cv(s1), emptycls)))\n  notbid(wceq(cv(s0), emptycls), wcel(cv(s1), cv(s0)), wcel(cv(s1), emptycls))\n  eleq2(cv(s0), emptycls, cv(s1))\n  noel(cv(s1))\n  diff.wal.s(s0, s1, wn(wcel(cv(s1), emptycls)))\n  diff.wn.s(s0, wcel(cv(s1), emptycls))\n  diff.wcel.s(s0, cv(s1), emptycls)\n  diff.cv.s(s0, s1)\n  diff.emptycls.s(s0)\n  diff.wceq.s(s1, cv(s0), emptycls)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s1)\n}","pretty":"thm bj-nuliota(setvar s0, setvar s1) {\n  âŠ¢ âˆ… = iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0))\n  âŠ£ d(s0, s1)\n} = {\n  eqcomi(emptycls, iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)))\n  mpgbi(s1, iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0))= âˆ…, Â¬ s1 âˆˆ âˆ…)\n  mp2an((âˆ€(s1, Â¬ s1 âˆˆ âˆ…)â†” iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0))= âˆ…), âˆ… âˆˆ ğ•Œ, âˆƒ!(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)))\n  mpbi(âˆƒ!(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)), âˆƒ!(s0, s0 = âˆ…))\n  eueqi(s0, emptycls)\n  0ex()\n  eubii(s0, s0 = âˆ…, âˆ€(s1, Â¬ s1 âˆˆ s0))\n  eq0(s1, s0)\n  iota2(s0, emptycls, universe, âˆ€(s1, Â¬ s1 âˆˆ s0), âˆ€(s1, Â¬ s1 âˆˆ âˆ…))\n  albidv(s1, s0 = âˆ…, Â¬ s1 âˆˆ s0, Â¬ s1 âˆˆ âˆ…)\n  notbid(s0 = âˆ…, s1 âˆˆ s0, s1 âˆˆ âˆ…)\n  eleq2(s0, emptycls, s1)\n  noel(s1)\n  diff.wal.s(s0, s1, Â¬ s1 âˆˆ âˆ…)\n  diff.wn.s(s0, s1 âˆˆ âˆ…)\n  diff.wcel.s(s0, s1, emptycls)\n  diff.cv.s(s0, s1)\n  diff.emptycls.s(s0)\n  diff.wceq.s(s1, s0, emptycls)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s1)\n}","parent":["eqcomi","mpgbi","mp2an","mpbi","eueqi","0ex","eubii","eq0","iota2","albidv","notbid","eleq2","noel","diff.wal.s","diff.wn.s","diff.wcel.s","diff.cv.s","diff.emptycls.s","diff.wceq.s","diffss.ex"],"children":[]},{"name":"bj-nuliotaALT","content":"Alternate proof of ~ bj-nuliota . Note that this alternate proof uses the fact that ` iota x ph ` evaluates to ` (/) ` when there is no ` x ` satisfying ` ph ` ( ~ iotanul ). This is an implementation detail of the encoding currently used in set.mm and should be avoided. (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-nuliotaALT(setvar s0, setvar s1) {\n  |- wceq(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  -| diffss(s0, s1)\n} = {\n  eqssi(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  0ss(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  sseqtri(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), emptycls, cuni(cab(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))))\n  iotassuni(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  3eqtri(cuni(cab(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))), emptycls, cuni(cab(s0, wceq(cv(s0), emptycls))), cuni(csn(emptycls)))\n  unieqi(cab(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), cab(s0, wceq(cv(s0), emptycls)))\n  abbii(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))), wceq(cv(s0), emptycls))\n  bicomi(wal(s1, wn(wcel(cv(s1), cv(s0)))), wceq(cv(s0), emptycls))\n  eq0(s1, cv(s0))\n  unieqi(cab(s0, wceq(cv(s0), emptycls)), csn(emptycls))\n  eqcomi(cab(s0, wceq(cv(s0), emptycls)), csn(emptycls))\n  df-sn(s0, emptycls)\n  unisn(emptycls)\n  0ex()\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s0)\n}","pretty":"thm bj-nuliotaALT(setvar s0, setvar s1) {\n  âŠ¢ âˆ… = iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0))\n  âŠ£ d(s0, s1)\n} = {\n  eqssi(emptycls, iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)))\n  0ss(iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)))\n  sseqtri(iota(s0, âˆ€(s1, Â¬ s1 âˆˆ s0)), emptycls, â‹ƒ { s0 | âˆ€(s1, Â¬ s1 âˆˆ s0)})\n  iotassuni(s0, âˆ€(s1, Â¬ s1 âˆˆ s0))\n  3eqtri(â‹ƒ { s0 | âˆ€(s1, Â¬ s1 âˆˆ s0)}, emptycls, â‹ƒ { s0 | s0 = âˆ… }, â‹ƒ { âˆ… })\n  unieqi({ s0 | âˆ€(s1, Â¬ s1 âˆˆ s0)}, { s0 | s0 = âˆ… })\n  abbii(s0, âˆ€(s1, Â¬ s1 âˆˆ s0), s0 = âˆ…)\n  bicomi(âˆ€(s1, Â¬ s1 âˆˆ s0), s0 = âˆ…)\n  eq0(s1, s0)\n  unieqi({ s0 | s0 = âˆ… }, { âˆ… })\n  eqcomi({ s0 | s0 = âˆ… }, { âˆ… })\n  df-sn(s0, emptycls)\n  unisn(emptycls)\n  0ex()\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s0)\n}","parent":["eqssi","0ss","sseqtri","iotassuni","3eqtri","unieqi","abbii","bicomi","eq0","eqcomi","df-sn","unisn","0ex","diff.cv.s","diffss.ex","diff.emptycls.s"],"children":[]},{"name":"bj-vtoclgfALT","content":"Alternate proof of ~ vtoclgf . Proof from ~ vtoclgft . (This may have been the original proof before shortening.) (Contributed by BJ, 30-Sep-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-vtoclgfALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(wcel(c0, c1), w0)\n  -| wnfc(s0, c0)\n  -| wnf(s0, w0)\n  -| wi(wceq(cv(s0), c0), wb(w1, w0))\n  -| w1\n} = {\n  mp3an12(wcel(c0, c1), w0, wa(wnfc(s0, c0), wnf(s0, w0)), wa(wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wal(s0, w1)))\n  pm3.2i(wnfc(s0, c0), wnf(s0, w0))\n  pm3.2i(wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wal(s0, w1))\n  ax-gen(s0, wi(wceq(cv(s0), c0), wb(w1, w0)))\n  ax-gen(s0, w1)\n  vtoclgft(s0, c0, c1, w0, w1)\n}","pretty":"thm bj-vtoclgfALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  âŠ¢ (c0 âˆˆ c1 â†’ w0)\n  âŠ£ F/(s0, c0)\n  âŠ£ F/(s0, w0)\n  âŠ£ (s0 = c0 â†’(w1 â†” w0))\n  âŠ£ w1\n} = {\n  mp3an12(c0 âˆˆ c1, w0, (F/(s0, c0)âˆ§ F/(s0, w0)), (âˆ€(s0,(s0 = c0 â†’(w1 â†” w0)))âˆ§ âˆ€(s0, w1)))\n  pm3.2i(F/(s0, c0), F/(s0, w0))\n  pm3.2i(âˆ€(s0,(s0 = c0 â†’(w1 â†” w0))), âˆ€(s0, w1))\n  ax-gen(s0, (s0 = c0 â†’(w1 â†” w0)))\n  ax-gen(s0, w1)\n  vtoclgft(s0, c0, c1, w0, w1)\n}","parent":["mp3an12","pm3.2i","ax-gen","vtoclgft"],"children":[]},{"name":"bj-pwcfsdom","content":"Remove hypothesis from ~ pwcfsdom . Illustration of how to remove a \"proof-facilitating hypothesis\". (Can use it to shorten theorems using ~ pwcfsdom .) (Contributed by BJ, 14-Sep-2019.)","origin":"thm bj-pwcfsdom(class c0) {\n  |- wbr(cfv(cale, c0), csdm, co(cfv(cale, c0), cmap, cfv(ccf, cfv(cale, c0))))\n} = {\n  pwcfsdom(hs0, hs1, c0, cmpt(hs0, cfv(ccf, cfv(cale, c0)), cfv(char, cfv(cv(hs1), cv(hs0)))))\n  eqid(cmpt(hs0, cfv(ccf, cfv(cale, c0)), cfv(char, cfv(cv(hs1), cv(hs0)))))\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n}","pretty":"thm bj-pwcfsdom(class c0) {\n  âŠ¢ (aleph ` c0)[â‰º]((aleph ` c0)[â†¦](cf `(aleph ` c0)))\n} = {\n  pwcfsdom(hs0, hs1, c0, (hs0 âˆˆ(cf `(aleph ` c0))â†¦(har `(hs1 ` hs0))))\n  eqid((hs0 âˆˆ(cf `(aleph ` c0))â†¦(har `(hs1 ` hs0))))\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n}","parent":["pwcfsdom","eqid","diff.hs0.s","diff.hs0.c","diff.hs1.c"],"children":[]},{"name":"bj-grur1","content":"Remove hypothesis from ~ grur1 . Illustration of how to remove a \"definitional hypothesis\". This makes its uses longer, but the theorem feels more self-contained. It looks preferable when the defined term appears only once in the conclusion. (Contributed by BJ, 14-Sep-2019.)","origin":"thm bj-grur1(class c0) {\n  |- wi(wa(wcel(c0, cgru), wcel(c0, cuni(cima(cr1, con0)))), wceq(c0, cfv(cr1, cin(c0, con0))))\n} = {\n  grur1(c0, cin(c0, con0))\n  eqid(cin(c0, con0))\n}","pretty":"thm bj-grur1(class c0) {\n  âŠ¢ ((c0 âˆˆ Univ âˆ§ c0 âˆˆ â‹ƒ(R1 \" On))â†’ c0 =(R1 `(c0 â‹‚ On)))\n} = {\n  grur1(c0, (c0 â‹‚ On))\n  eqid((c0 â‹‚ On))\n}","parent":["grur1","eqid"],"children":[]},{"name":"bj-bm1.3ii","content":"The extension of a predicate is included in a set if and only if it is a set. Sufficiency is obvious, and necessity is the content of the axiom of separation ~ ax-sep . Similar to Theorem 1.3(ii) of [BellMachover] p. 463. (Contributed by NM, 21-Jun-1993.) Generalized to a closed form biconditional with existential quantifications using two different setvars (which need not be disjoint). (Revised by BJ, 8-Aug-2022.) TODO: move in place of ~ bm1.3ii .","origin":"thm bj-bm1.3ii(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wex(s0, wal(s1, wi(w0, wcel(cv(s1), cv(s0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n  -| diffsw(s0, w0)\n  -| diffsw(s2, w0)\n} = {\n  bitri(wex(s0, wal(s1, wi(w0, wcel(cv(s1), cv(s0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0))))))\n  cbvexvw(s0, hs0, wal(s1, wi(w0, wcel(cv(s1), cv(s0)))), wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))))\n  albidv(s1, wceq(cv(s0), cv(hs0)), wi(w0, wcel(cv(s1), cv(s0))), wi(w0, wcel(cv(s1), cv(hs0))))\n  imbi2d(wceq(cv(s0), cv(hs0)), w0, wcel(cv(s1), cv(s0)), wcel(cv(s1), cv(hs0)))\n  elequ2(s0, hs0, s1)\n  impbii(wex(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  exlimiv(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  mpan2(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0)))))\n  ax-sep(s2, s1, hs0, w0)\n  sylbir(wa(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(s2, wa(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0))))))\n  19.42v(s2, wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0))))\n  eximi(s2, wa(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), w0)))\n  alanimi(s1, wi(w0, wcel(cv(s1), cv(hs0))), wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0)), wb(wcel(cv(s1), cv(s2)), w0))\n  bimsc1(w0, wcel(cv(s1), cv(hs0)), wcel(cv(s1), cv(s2)))\n  sylbi(wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0))))), wex(hs0, wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))))\n  cbvexvw(s2, hs0, wal(s1, wb(wcel(cv(s1), cv(s2)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0)))\n  albidv(s1, wceq(cv(s2), cv(hs0)), wb(wcel(cv(s1), cv(s2)), w0), wb(wcel(cv(s1), cv(hs0)), w0))\n  bibi1d(wceq(cv(s2), cv(hs0)), wcel(cv(s1), cv(s2)), w0, wcel(cv(s1), cv(hs0)))\n  elequ2(s2, hs0, s1)\n  eximi(hs0, wal(s1, wb(wcel(cv(s1), cv(hs0)), w0)), wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))))\n  alimi(s1, wb(wcel(cv(s1), cv(hs0)), w0), wi(w0, wcel(cv(s1), cv(hs0))))\n  biimpr(wcel(cv(s1), cv(hs0)), w0)\n  diff.wal.s(s0, s1, wi(w0, wcel(cv(s1), cv(hs0))))\n  diff.wi.s(s0, w0, wcel(cv(s1), cv(hs0)))\n  diff.wcel.s(s0, cv(s1), cv(hs0))\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(wal(s1, wi(w0, wcel(cv(s1), cv(s0)))))\n  diff.wceq.s(s1, cv(s0), cv(hs0))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.hs0.w(wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  diff.hs0.w(w0)\n  diff.wal.s(s2, s1, wi(w0, wcel(cv(s1), cv(hs0))))\n  diff.wi.s(s2, w0, wcel(cv(s1), cv(hs0)))\n  diff.wal.s(s2, s1, wb(wcel(cv(s1), cv(hs0)), w0))\n  diff.wb.s(s2, wcel(cv(s1), cv(hs0)), w0)\n  diff.wcel.s(s2, cv(s1), cv(hs0))\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.hs0.w(wal(s1, wb(wcel(cv(s1), cv(s2)), w0)))\n  diff.wceq.s(s1, cv(s2), cv(hs0))\n  diff.cv.s(s1, s2)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","pretty":"thm bj-bm1.3ii(setvar s0, setvar s1, setvar s2, wff w0) {\n  âŠ¢ (âˆƒ(s0, âˆ€(s1,(w0 â†’ s1 âˆˆ s0)))â†” âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))))\n  âŠ£ d(s0, s1)\n  âŠ£ d(s1, s2)\n  âŠ£ d(s0, w0)\n  âŠ£ d(s2, w0)\n} = {\n  bitri(âˆƒ(s0, âˆ€(s1,(w0 â†’ s1 âˆˆ s0))), âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))), âˆƒ(hs0, âˆ€(s1,(w0 â†’ s1 âˆˆ hs0))))\n  cbvexvw(s0, hs0, âˆ€(s1,(w0 â†’ s1 âˆˆ s0)), âˆ€(s1,(w0 â†’ s1 âˆˆ hs0)))\n  albidv(s1, s0 = hs0, (w0 â†’ s1 âˆˆ s0), (w0 â†’ s1 âˆˆ hs0))\n  imbi2d(s0 = hs0, w0, s1 âˆˆ s0, s1 âˆˆ hs0)\n  elequ2(s0, hs0, s1)\n  impbii(âˆƒ(hs0, âˆ€(s1,(w0 â†’ s1 âˆˆ hs0))), âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))))\n  exlimiv(hs0, âˆ€(s1,(w0 â†’ s1 âˆˆ hs0)), âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))))\n  mpan2(âˆ€(s1,(w0 â†’ s1 âˆˆ hs0)), âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))), âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†”(s1 âˆˆ hs0 âˆ§ w0)))))\n  ax-sep(s2, s1, hs0, w0)\n  sylbir((âˆ€(s1,(w0 â†’ s1 âˆˆ hs0))âˆ§ âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†”(s1 âˆˆ hs0 âˆ§ w0))))), âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))), âˆƒ(s2,(âˆ€(s1,(w0 â†’ s1 âˆˆ hs0))âˆ§ âˆ€(s1,(s1 âˆˆ s2 â†”(s1 âˆˆ hs0 âˆ§ w0))))))\n  19.42v(s2, âˆ€(s1,(w0 â†’ s1 âˆˆ hs0)), âˆ€(s1,(s1 âˆˆ s2 â†”(s1 âˆˆ hs0 âˆ§ w0))))\n  eximi(s2, (âˆ€(s1,(w0 â†’ s1 âˆˆ hs0))âˆ§ âˆ€(s1,(s1 âˆˆ s2 â†”(s1 âˆˆ hs0 âˆ§ w0)))), âˆ€(s1,(s1 âˆˆ s2 â†” w0)))\n  alanimi(s1, (w0 â†’ s1 âˆˆ hs0), (s1 âˆˆ s2 â†”(s1 âˆˆ hs0 âˆ§ w0)), (s1 âˆˆ s2 â†” w0))\n  bimsc1(w0, s1 âˆˆ hs0, s1 âˆˆ s2)\n  sylbi(âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))), âˆƒ(hs0, âˆ€(s1,(w0 â†’ s1 âˆˆ hs0))), âˆƒ(hs0, âˆ€(s1,(s1 âˆˆ hs0 â†” w0))))\n  cbvexvw(s2, hs0, âˆ€(s1,(s1 âˆˆ s2 â†” w0)), âˆ€(s1,(s1 âˆˆ hs0 â†” w0)))\n  albidv(s1, s2 = hs0, (s1 âˆˆ s2 â†” w0), (s1 âˆˆ hs0 â†” w0))\n  bibi1d(s2 = hs0, s1 âˆˆ s2, w0, s1 âˆˆ hs0)\n  elequ2(s2, hs0, s1)\n  eximi(hs0, âˆ€(s1,(s1 âˆˆ hs0 â†” w0)), âˆ€(s1,(w0 â†’ s1 âˆˆ hs0)))\n  alimi(s1, (s1 âˆˆ hs0 â†” w0), (w0 â†’ s1 âˆˆ hs0))\n  biimpr(s1 âˆˆ hs0, w0)\n  diff.wal.s(s0, s1, (w0 â†’ s1 âˆˆ hs0))\n  diff.wi.s(s0, w0, s1 âˆˆ hs0)\n  diff.wcel.s(s0, s1, hs0)\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(âˆ€(s1,(w0 â†’ s1 âˆˆ s0)))\n  diff.wceq.s(s1, s0, hs0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.hs0.w(âˆƒ(s2, âˆ€(s1,(s1 âˆˆ s2 â†” w0))))\n  diff.hs0.w(w0)\n  diff.wal.s(s2, s1, (w0 â†’ s1 âˆˆ hs0))\n  diff.wi.s(s2, w0, s1 âˆˆ hs0)\n  diff.wal.s(s2, s1, (s1 âˆˆ hs0 â†” w0))\n  diff.wb.s(s2, s1 âˆˆ hs0, w0)\n  diff.wcel.s(s2, s1, hs0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.hs0.w(âˆ€(s1,(s1 âˆˆ s2 â†” w0)))\n  diff.wceq.s(s1, s2, hs0)\n  diff.cv.s(s1, s2)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","parent":["bitri","cbvexvw","albidv","imbi2d","elequ2","impbii","exlimiv","mpan2","ax-sep","sylbir","19.42v","eximi","alanimi","bimsc1","sylbi","bibi1d","alimi","biimpr","diff.wal.s","diff.wi.s","diff.wcel.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.hs0.w","diff.wceq.s","diff.wb.s"],"children":[]},{"name":"bj-0nelopab","content":"The empty set is never an element in an ordered-pair class abstraction. (Contributed by Alexander van der Vekens, 5-Nov-2017.) (Proof shortened by BJ, 22-Jul-2023.) TODO: move to Main when one can reorder sections so that we can use ~ relopab (this is a very limited reordering).","origin":"thm bj-0nelopab(setvar s0, setvar s1, wff w0) {\n  |- wn(wcel(emptycls, copab(s0, s1, w0)))\n} = {\n  ax-mp(wn(wcel(emptycls, copab(s0, s1, w0))), wrel(copab(s0, s1, w0)))\n  relopab(s0, s1, w0)\n  0nelrel0(copab(s0, s1, w0))\n}","pretty":"thm bj-0nelopab(setvar s0, setvar s1, wff w0) {\n  âŠ¢ Â¬ âˆ… âˆˆ { < s0, s1 > | w0 }\n} = {\n  ax-mp(Â¬ âˆ… âˆˆ { < s0, s1 > | w0 }, Rel({ < s0, s1 > | w0 }))\n  relopab(s0, s1, w0)\n  0nelrel0({ < s0, s1 > | w0 })\n}","parent":["ax-mp","relopab","0nelrel0"],"children":[]},{"name":"bj-brrelex12ALT","content":"Two classes related by a binary relation are both sets. Alternate proof of ~ brrelex12 . (Contributed by BJ, 14-Jul-2023.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-brrelex12ALT(class c0, class c1, class c2) {\n  |- wi(wa(wrel(c0), wbr(c1, c0, c2)), wa(wcel(c1, universe), wcel(c2, universe)))\n} = {\n  sylan(wrel(c0), wbr(c1, c0, c2), wa(wcel(c1, universe), wcel(c2, universe)), wn(wcel(emptycls, c0)))\n  0nelrel0(c0)\n  nsyl2(wa(wn(wcel(emptycls, c0)), wbr(c1, c0, c2)), wa(wcel(c1, universe), wcel(c2, universe)), wi(wbr(c1, c0, c2), wcel(emptycls, c0)))\n  impcom(wn(wcel(emptycls, c0)), wbr(c1, c0, c2), wn(wi(wbr(c1, c0, c2), wcel(emptycls, c0))))\n  mth8(wbr(c1, c0, c2), wcel(emptycls, c0))\n  syl(wn(wa(wcel(c1, universe), wcel(c2, universe))), wi(wbr(c1, c0, c2), wcel(emptycls, c0)), wceq(cop(c1, c2), emptycls))\n  opprc(c1, c2)\n  syl5ib(wceq(cop(c1, c2), emptycls), wbr(c1, c0, c2), wcel(emptycls, c0), wcel(cop(c1, c2), c0))\n  biimpi(wbr(c1, c0, c2), wcel(cop(c1, c2), c0))\n  df-br(c1, c0, c2)\n  eleq1(cop(c1, c2), emptycls, c0)\n}","pretty":"thm bj-brrelex12ALT(class c0, class c1, class c2) {\n  âŠ¢ ((Rel(c0)âˆ§ c1[c0]c2)â†’(c1 âˆˆ ğ•Œ âˆ§ c2 âˆˆ ğ•Œ))\n} = {\n  sylan(Rel(c0), c1[c0]c2, (c1 âˆˆ ğ•Œ âˆ§ c2 âˆˆ ğ•Œ), Â¬ âˆ… âˆˆ c0)\n  0nelrel0(c0)\n  nsyl2((Â¬ âˆ… âˆˆ c0 âˆ§ c1[c0]c2), (c1 âˆˆ ğ•Œ âˆ§ c2 âˆˆ ğ•Œ), (c1[c0]c2 â†’ âˆ… âˆˆ c0))\n  impcom(Â¬ âˆ… âˆˆ c0, c1[c0]c2, Â¬(c1[c0]c2 â†’ âˆ… âˆˆ c0))\n  mth8(c1[c0]c2, âˆ… âˆˆ c0)\n  syl(Â¬(c1 âˆˆ ğ•Œ âˆ§ c2 âˆˆ ğ•Œ), (c1[c0]c2 â†’ âˆ… âˆˆ c0), < c1, c2 > = âˆ…)\n  opprc(c1, c2)\n  syl5ib(< c1, c2 > = âˆ…, c1[c0]c2, âˆ… âˆˆ c0, < c1, c2 > âˆˆ c0)\n  biimpi(c1[c0]c2, < c1, c2 > âˆˆ c0)\n  df-br(c1, c0, c2)\n  eleq1(< c1, c2 >, emptycls, c0)\n}","parent":["sylan","0nelrel0","nsyl2","impcom","mth8","syl","opprc","syl5ib","biimpi","df-br","eleq1"],"children":[]},{"name":"bj-elep","content":"Two classes are related by the membership relation if and only if the first is an element of the second and the second is a set. Can be moved to Main when some parts have been reordered. (Contributed by BJ, 14-Jul-2023.)","origin":"thm bj-elep(class c0, class c1) {\n  |- wb(wbr(c0, cep, c1), wa(wcel(c0, c1), wcel(c1, universe)))\n} = {\n  impbii(wbr(c0, cep, c1), wa(wcel(c0, c1), wcel(c1, universe)))\n  jca(wbr(c0, cep, c1), wcel(c0, c1), wcel(c1, universe))\n  mpcom(wbr(c0, cep, c1), wcel(c0, c1), wa(wcel(c0, universe), wcel(c1, universe)))\n  mpan(wbr(c0, cep, c1), wa(wcel(c0, universe), wcel(c1, universe)), wrel(cep))\n  biimpd(wa(wcel(c0, universe), wcel(c1, universe)), wbr(c0, cep, c1), wcel(c0, c1))\n  brabga(hs0, hs1, c0, universe, c1, universe, cep, wcel(c0, c1), wcel(cv(hs0), cv(hs1)))\n  mpan(wbr(c0, cep, c1), wcel(c1, universe), wrel(cep))\n  rele()\n  simprd(wa(wrel(cep), wbr(c0, cep, c1)), wcel(c1, universe), wcel(c0, universe))\n  brrelex12(cep, c0, c1)\n  mpbird(wa(wcel(c0, c1), wcel(c1, universe)), wbr(c0, cep, c1), wcel(c0, c1))\n  simpl(wcel(c0, c1), wcel(c1, universe))\n  brabga(hs0, hs1, c0, c1, c1, universe, cep, wcel(c0, c1), wcel(cv(hs0), cv(hs1)))\n  eleq12(cv(hs0), c0, cv(hs1), c1)\n  df-eprel(hs0, hs1)\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c0)\n  diff.hs1.c(c1)\n  diff.hs0.w(wcel(c0, c1))\n  diff.hs1.w(wcel(c0, c1))\n}","pretty":"thm bj-elep(class c0, class c1) {\n  âŠ¢ (c0[âˆˆ]c1 â†”(c0 âˆˆ c1 âˆ§ c1 âˆˆ ğ•Œ))\n} = {\n  impbii(c0[âˆˆ]c1, (c0 âˆˆ c1 âˆ§ c1 âˆˆ ğ•Œ))\n  jca(c0[âˆˆ]c1, c0 âˆˆ c1, c1 âˆˆ ğ•Œ)\n  mpcom(c0[âˆˆ]c1, c0 âˆˆ c1, (c0 âˆˆ ğ•Œ âˆ§ c1 âˆˆ ğ•Œ))\n  mpan(c0[âˆˆ]c1, (c0 âˆˆ ğ•Œ âˆ§ c1 âˆˆ ğ•Œ), Rel(âˆˆ))\n  biimpd((c0 âˆˆ ğ•Œ âˆ§ c1 âˆˆ ğ•Œ), c0[âˆˆ]c1, c0 âˆˆ c1)\n  brabga(hs0, hs1, c0, universe, c1, universe, cep, c0 âˆˆ c1, hs0 âˆˆ hs1)\n  mpan(c0[âˆˆ]c1, c1 âˆˆ ğ•Œ, Rel(âˆˆ))\n  rele()\n  simprd((Rel(âˆˆ)âˆ§ c0[âˆˆ]c1), c1 âˆˆ ğ•Œ, c0 âˆˆ ğ•Œ)\n  brrelex12(cep, c0, c1)\n  mpbird((c0 âˆˆ c1 âˆ§ c1 âˆˆ ğ•Œ), c0[âˆˆ]c1, c0 âˆˆ c1)\n  simpl(c0 âˆˆ c1, c1 âˆˆ ğ•Œ)\n  brabga(hs0, hs1, c0, c1, c1, universe, cep, c0 âˆˆ c1, hs0 âˆˆ hs1)\n  eleq12(hs0, c0, hs1, c1)\n  df-eprel(hs0, hs1)\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c0)\n  diff.hs1.c(c1)\n  diff.hs0.w(c0 âˆˆ c1)\n  diff.hs1.w(c0 âˆˆ c1)\n}","parent":["impbii","jca","mpcom","mpan","biimpd","brabga","rele","simprd","brrelex12","mpbird","simpl","eleq12","df-eprel","diff.hs0.s","diff.hs0.c","diff.hs1.c","diff.hs0.w","diff.hs1.w"],"children":["bj-epelg"]},{"name":"bj-epelg","content":"The membership relation and the membership predicate agree when the \"containing\" class is a set. General version of ~ epel and closed form of ~ epeli . (Contributed by Scott Fenton, 27-Mar-2011.) (Revised by Mario Carneiro, 28-Apr-2015.) (Revised by BJ, 14-Jul-2023.)","origin":"thm bj-epelg(class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wb(wbr(c2, cep, c0), wcel(c2, c0)))\n} = {\n  impbid2(wcel(c0, c1), wbr(c2, cep, c0), wcel(c2, c0))\n  simplbi(wbr(c2, cep, c0), wcel(c2, c0), wcel(c0, universe))\n  syl5com(wcel(c0, c1), wcel(c2, c0), wbr(c2, cep, c0), wcel(c0, universe))\n  elex(c0, c1)\n  simplbi2(wcel(c2, c0), wcel(c0, universe), wbr(c2, cep, c0))\n  bj-elep(c2, c0)\n}","pretty":"thm bj-epelg(class c0, class c1, class c2) {\n  âŠ¢ (c0 âˆˆ c1 â†’(c2[âˆˆ]c0 â†” c2 âˆˆ c0))\n} = {\n  impbid2(c0 âˆˆ c1, c2[âˆˆ]c0, c2 âˆˆ c0)\n  simplbi(c2[âˆˆ]c0, c2 âˆˆ c0, c0 âˆˆ ğ•Œ)\n  syl5com(c0 âˆˆ c1, c2 âˆˆ c0, c2[âˆˆ]c0, c0 âˆˆ ğ•Œ)\n  elex(c0, c1)\n  simplbi2(c2 âˆˆ c0, c0 âˆˆ ğ•Œ, c2[âˆˆ]c0)\n  bj-elep(c2, c0)\n}","parent":["impbid2","simplbi","syl5com","elex","simplbi2","bj-elep"],"children":[]},{"name":"bj-nsnid","content":"A set does not contain the singleton formed on it. More precisely, one can prove that a class contains the singleton formed on it if and only if it is proper and contains the \"singleton formed on it\", which is the empty set: ` |- -. ( { A } e. A <-> ( (/) e. A -> A e. _V ) ) ` . (Contributed by BJ, 4-Feb-2023.)","origin":"thm bj-nsnid(class c0, class c1) {\n  |- wi(wcel(c0, c1), wn(wcel(csn(c0), c0)))\n} = {\n  mtoi(wcel(c0, c1), wcel(csn(c0), c0), wa(wcel(c0, csn(c0)), wcel(csn(c0), c0)))\n  en2lp(c0, csn(c0))\n  ex(wcel(c0, c1), wcel(csn(c0), c0), wa(wcel(c0, csn(c0)), wcel(csn(c0), c0)))\n  anim1i(wcel(c0, c1), wcel(csn(c0), c0), wcel(c0, csn(c0)))\n  snidg(c0, c1)\n}","pretty":"thm bj-nsnid(class c0, class c1) {\n  âŠ¢ (c0 âˆˆ c1 â†’ Â¬ { c0 } âˆˆ c0)\n} = {\n  mtoi(c0 âˆˆ c1, { c0 } âˆˆ c0, (c0 âˆˆ { c0 } âˆ§ { c0 } âˆˆ c0))\n  en2lp(c0, { c0 })\n  ex(c0 âˆˆ c1, { c0 } âˆˆ c0, (c0 âˆˆ { c0 } âˆ§ { c0 } âˆˆ c0))\n  anim1i(c0 âˆˆ c1, { c0 } âˆˆ c0, c0 âˆˆ { c0 })\n  snidg(c0, c1)\n}","parent":["mtoi","en2lp","ex","anim1i","snidg"],"children":["bj-inftyexpitaudisj"]}]}