{"index":1153,"title":"Set theory: miscellaneous","content":"Miscellaneous theorems of set theory.","blocks":[{"name":"bj-disj2r","content":"Relative version of ~ ssdifin0 , allowing a biconditional, and of ~ disj2 . This proof does not rely, even indirectly, on ~ ssdifin0 nor ~ disj2 . (Contributed by BJ, 11-Nov-2021.)","origin":"thm bj-disj2r(class c0, class c1, class c2) {\n  |- wb(wss(cin(c0, c1), cdif(c1, c2)), wceq(cin(cin(c0, c2), c1), emptycls))\n} = {\n  3bitr2i(wss(cin(c0, c1), cdif(c1, c2)), wceq(cin(cin(c0, c2), c1), emptycls), wceq(cin(c0, c1), cdif(cin(c0, c1), c2)), wceq(cin(cin(c0, c1), c2), emptycls))\n  3bitri(wss(cin(c0, c1), cdif(c1, c2)), wceq(cin(c0, c1), cdif(cin(c0, c1), c2)), wceq(cin(cin(c0, c1), cdif(c1, c2)), cin(c0, c1)), wceq(cdif(cin(c0, c1), c2), cin(c0, c1)))\n  df-ss(cin(c0, c1), cdif(c1, c2))\n  eqeq1i(cin(cin(c0, c1), cdif(c1, c2)), cin(c0, c1), cdif(cin(c0, c1), c2))\n  eqtri(cin(cin(c0, c1), cdif(c1, c2)), cdif(cin(c0, c1), c2), cdif(cin(cin(c0, c1), c1), c2))\n  indif2(cin(c0, c1), c1, c2)\n  difeq1i(cin(cin(c0, c1), c1), c2, cin(c0, c1))\n  eqssi(cin(cin(c0, c1), c1), cin(c0, c1))\n  inss1(cin(c0, c1), c1)\n  ssini(cin(c0, c1), cin(c0, c1), c1)\n  ssid(cin(c0, c1))\n  inss2(c0, c1)\n  eqcom(cdif(cin(c0, c1), c2), cin(c0, c1))\n  disj3(cin(c0, c1), c2)\n  eqeq1i(cin(cin(c0, c1), c2), emptycls, cin(cin(c0, c2), c1))\n  in32(c0, c1, c2)\n}","pretty":"thm bj-disj2r(class c0, class c1, class c2) {\n  ⊢ ((c0 ⋂ c1)⊆(c1 \\ c2)↔((c0 ⋂ c2)⋂ c1)= ∅)\n} = {\n  3bitr2i((c0 ⋂ c1)⊆(c1 \\ c2), ((c0 ⋂ c2)⋂ c1)= ∅, (c0 ⋂ c1)=((c0 ⋂ c1)\\ c2), ((c0 ⋂ c1)⋂ c2)= ∅)\n  3bitri((c0 ⋂ c1)⊆(c1 \\ c2), (c0 ⋂ c1)=((c0 ⋂ c1)\\ c2), ((c0 ⋂ c1)⋂(c1 \\ c2))=(c0 ⋂ c1), ((c0 ⋂ c1)\\ c2)=(c0 ⋂ c1))\n  df-ss((c0 ⋂ c1), (c1 \\ c2))\n  eqeq1i(((c0 ⋂ c1)⋂(c1 \\ c2)), (c0 ⋂ c1), ((c0 ⋂ c1)\\ c2))\n  eqtri(((c0 ⋂ c1)⋂(c1 \\ c2)), ((c0 ⋂ c1)\\ c2), (((c0 ⋂ c1)⋂ c1)\\ c2))\n  indif2((c0 ⋂ c1), c1, c2)\n  difeq1i(((c0 ⋂ c1)⋂ c1), c2, (c0 ⋂ c1))\n  eqssi(((c0 ⋂ c1)⋂ c1), (c0 ⋂ c1))\n  inss1((c0 ⋂ c1), c1)\n  ssini((c0 ⋂ c1), (c0 ⋂ c1), c1)\n  ssid((c0 ⋂ c1))\n  inss2(c0, c1)\n  eqcom(((c0 ⋂ c1)\\ c2), (c0 ⋂ c1))\n  disj3((c0 ⋂ c1), c2)\n  eqeq1i(((c0 ⋂ c1)⋂ c2), emptycls, ((c0 ⋂ c2)⋂ c1))\n  in32(c0, c1, c2)\n}","parent":["3bitr2i","3bitri","df-ss","eqeq1i","eqtri","indif2","difeq1i","eqssi","inss1","ssini","ssid","inss2","eqcom","disj3","in32"],"children":["bj-sscon"]},{"name":"bj-sscon","content":"Contraposition law for relative subsets. Relative and generalized version of ~ ssconb , which it can shorten, as well as ~ conss2 . (Contributed by BJ, 11-Nov-2021.)","origin":"thm bj-sscon(class c0, class c1, class c2) {\n  |- wb(wss(cin(c0, c1), cdif(c1, c2)), wss(cin(c2, c1), cdif(c1, c0)))\n} = {\n  3bitr4i(wss(cin(c0, c1), cdif(c1, c2)), wss(cin(c2, c1), cdif(c1, c0)), wceq(cin(cin(c0, c2), c1), emptycls), wceq(cin(cin(c2, c0), c1), emptycls))\n  eqeq1i(cin(cin(c0, c2), c1), emptycls, cin(cin(c2, c0), c1))\n  ineq1i(cin(c0, c2), c1, cin(c2, c0))\n  incom(c0, c2)\n  bj-disj2r(c0, c1, c2)\n  bj-disj2r(c2, c1, c0)\n}","pretty":"thm bj-sscon(class c0, class c1, class c2) {\n  ⊢ ((c0 ⋂ c1)⊆(c1 \\ c2)↔(c2 ⋂ c1)⊆(c1 \\ c0))\n} = {\n  3bitr4i((c0 ⋂ c1)⊆(c1 \\ c2), (c2 ⋂ c1)⊆(c1 \\ c0), ((c0 ⋂ c2)⋂ c1)= ∅, ((c2 ⋂ c0)⋂ c1)= ∅)\n  eqeq1i(((c0 ⋂ c2)⋂ c1), emptycls, ((c2 ⋂ c0)⋂ c1))\n  ineq1i((c0 ⋂ c2), c1, (c2 ⋂ c0))\n  incom(c0, c2)\n  bj-disj2r(c0, c1, c2)\n  bj-disj2r(c2, c1, c0)\n}","parent":["3bitr4i","eqeq1i","ineq1i","incom","bj-disj2r"],"children":[]},{"name":"bj-vjust","content":"Justification theorem for ~ bj-df-v . See also ~ vjust . (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-vjust(setvar s0, setvar s1) {\n  |- wceq(cab(s0, wtru), cab(s1, wtru))\n} = {\n  eqriv(hs0, cab(s0, wtru), cab(s1, wtru))\n  bitri(wcel(cv(hs0), cab(s0, wtru)), wcel(cv(hs0), cab(s1, wtru)), wsb(hs0, s0, wtru))\n  df-clab(hs0, s0, wtru)\n  3bitr4ri(wsb(hs0, s0, wtru), wcel(cv(hs0), cab(s1, wtru)), wsb(hs0, s1, wtru), wtru)\n  sbv(hs0, s1, wtru)\n  df-clab(hs0, s1, wtru)\n  sbv(hs0, s0, wtru)\n  diff.hs0.c(cab(s0, wtru))\n  diff.hs0.c(cab(s1, wtru))\n  diff.wtru.s(s1)\n  diff.wtru.s(s0)\n}","pretty":"thm bj-vjust(setvar s0, setvar s1) {\n  ⊢ { s0 | T } = { s1 | T }\n} = {\n  eqriv(hs0, { s0 | T }, { s1 | T })\n  bitri(hs0 ∈ { s0 | T }, hs0 ∈ { s1 | T }, [hs0 / s0]T)\n  df-clab(hs0, s0, wtru)\n  3bitr4ri([hs0 / s0]T, hs0 ∈ { s1 | T }, [hs0 / s1]T, wtru)\n  sbv(hs0, s1, wtru)\n  df-clab(hs0, s1, wtru)\n  sbv(hs0, s0, wtru)\n  diff.hs0.c({ s0 | T })\n  diff.hs0.c({ s1 | T })\n  diff.wtru.s(s1)\n  diff.wtru.s(s0)\n}","parent":["eqriv","bitri","df-clab","3bitr4ri","sbv","diff.hs0.c","diff.wtru.s"],"children":[]},{"name":"bj-df-v","content":"Alternate definition of the universal class. Actually, the current definition ~ df-v should be proved from this one, and ~ vex should be proved from this proposed definition together with ~ bj-vexw , which would remove from ~ vex dependency on ~ ax-13 (see also comment of ~ bj-vexw ). (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-df-v(setvar s0) {\n  |- wceq(universe, cab(s0, wtru))\n} = {\n  mpgbir(hs0, wceq(universe, cab(s0, wtru)), wb(wcel(cv(hs0), universe), wcel(cv(hs0), cab(s0, wtru))))\n  dfcleq(hs0, universe, cab(s0, wtru))\n  2th(wcel(cv(hs0), universe), wcel(cv(hs0), cab(s0, wtru)))\n  vex(hs0)\n  bj-vexw(hs0, s0, wtru)\n  tru()\n  diff.hs0.c(universe)\n  diff.hs0.c(cab(s0, wtru))\n}","pretty":"thm bj-df-v(setvar s0) {\n  ⊢ 𝕌 = { s0 | T }\n} = {\n  mpgbir(hs0, 𝕌 = { s0 | T }, (hs0 ∈ 𝕌 ↔ hs0 ∈ { s0 | T }))\n  dfcleq(hs0, universe, { s0 | T })\n  2th(hs0 ∈ 𝕌, hs0 ∈ { s0 | T })\n  vex(hs0)\n  bj-vexw(hs0, s0, wtru)\n  tru()\n  diff.hs0.c(universe)\n  diff.hs0.c({ s0 | T })\n}","parent":["mpgbir","dfcleq","2th","vex","bj-vexw","tru","diff.hs0.c"],"children":[]},{"name":"bj-df-nul","content":"Alternate definition of the empty class/set. (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-df-nul(setvar s0) {\n  |- wceq(emptycls, cab(s0, wfal))\n} = {\n  bj-abbi2i(s0, emptycls, wfal)\n  bifal(wcel(cv(s0), emptycls))\n  noel(cv(s0))\n  diff.emptycls.s(s0)\n}","pretty":"thm bj-df-nul(setvar s0) {\n  ⊢ ∅ = { s0 | F }\n} = {\n  bj-abbi2i(s0, emptycls, wfal)\n  bifal(s0 ∈ ∅)\n  noel(s0)\n  diff.emptycls.s(s0)\n}","parent":["bj-abbi2i","bifal","noel","diff.emptycls.s"],"children":[]},{"name":"bj-nul","content":"Two formulations of the axiom of the empty set ~ ax-nul . Proposal: place it right before ~ ax-nul . (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-nul(setvar s0, setvar s1) {\n  |- wb(wcel(emptycls, universe), wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  -| diffss(s0, s1)\n} = {\n  bitri(wcel(emptycls, universe), wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), wex(s0, wceq(cv(s0), emptycls)))\n  isset(s0, emptycls)\n  exbii(s0, wceq(cv(s0), emptycls), wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  eq0(s1, cv(s0))\n  diff.emptycls.s(s0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm bj-nul(setvar s0, setvar s1) {\n  ⊢ (∅ ∈ 𝕌 ↔ ∃(s0, ∀(s1, ¬ s1 ∈ s0)))\n  ⊣ d(s0, s1)\n} = {\n  bitri(∅ ∈ 𝕌, ∃(s0, ∀(s1, ¬ s1 ∈ s0)), ∃(s0, s0 = ∅))\n  isset(s0, emptycls)\n  exbii(s0, s0 = ∅, ∀(s1, ¬ s1 ∈ s0))\n  eq0(s1, s0)\n  diff.emptycls.s(s0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["bitri","isset","exbii","eq0","diff.emptycls.s","diff.cv.s","diffss.ex"],"children":[]},{"name":"bj-nuliota","content":"Definition of the empty set using the definite description binder. See also ~ bj-nuliotaALT . (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.)","origin":"thm bj-nuliota(setvar s0, setvar s1) {\n  |- wceq(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  -| diffss(s0, s1)\n} = {\n  eqcomi(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  mpgbi(s1, wceq(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), emptycls), wn(wcel(cv(s1), emptycls)))\n  mp2an(wb(wal(s1, wn(wcel(cv(s1), emptycls))), wceq(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), emptycls)), wcel(emptycls, universe), weu(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  mpbi(weu(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), weu(s0, wceq(cv(s0), emptycls)))\n  eueqi(s0, emptycls)\n  0ex()\n  eubii(s0, wceq(cv(s0), emptycls), wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  eq0(s1, cv(s0))\n  iota2(s0, emptycls, universe, wal(s1, wn(wcel(cv(s1), cv(s0)))), wal(s1, wn(wcel(cv(s1), emptycls))))\n  albidv(s1, wceq(cv(s0), emptycls), wn(wcel(cv(s1), cv(s0))), wn(wcel(cv(s1), emptycls)))\n  notbid(wceq(cv(s0), emptycls), wcel(cv(s1), cv(s0)), wcel(cv(s1), emptycls))\n  eleq2(cv(s0), emptycls, cv(s1))\n  noel(cv(s1))\n  diff.wal.s(s0, s1, wn(wcel(cv(s1), emptycls)))\n  diff.wn.s(s0, wcel(cv(s1), emptycls))\n  diff.wcel.s(s0, cv(s1), emptycls)\n  diff.cv.s(s0, s1)\n  diff.emptycls.s(s0)\n  diff.wceq.s(s1, cv(s0), emptycls)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s1)\n}","pretty":"thm bj-nuliota(setvar s0, setvar s1) {\n  ⊢ ∅ = iota(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  eqcomi(emptycls, iota(s0, ∀(s1, ¬ s1 ∈ s0)))\n  mpgbi(s1, iota(s0, ∀(s1, ¬ s1 ∈ s0))= ∅, ¬ s1 ∈ ∅)\n  mp2an((∀(s1, ¬ s1 ∈ ∅)↔ iota(s0, ∀(s1, ¬ s1 ∈ s0))= ∅), ∅ ∈ 𝕌, ∃!(s0, ∀(s1, ¬ s1 ∈ s0)))\n  mpbi(∃!(s0, ∀(s1, ¬ s1 ∈ s0)), ∃!(s0, s0 = ∅))\n  eueqi(s0, emptycls)\n  0ex()\n  eubii(s0, s0 = ∅, ∀(s1, ¬ s1 ∈ s0))\n  eq0(s1, s0)\n  iota2(s0, emptycls, universe, ∀(s1, ¬ s1 ∈ s0), ∀(s1, ¬ s1 ∈ ∅))\n  albidv(s1, s0 = ∅, ¬ s1 ∈ s0, ¬ s1 ∈ ∅)\n  notbid(s0 = ∅, s1 ∈ s0, s1 ∈ ∅)\n  eleq2(s0, emptycls, s1)\n  noel(s1)\n  diff.wal.s(s0, s1, ¬ s1 ∈ ∅)\n  diff.wn.s(s0, s1 ∈ ∅)\n  diff.wcel.s(s0, s1, emptycls)\n  diff.cv.s(s0, s1)\n  diff.emptycls.s(s0)\n  diff.wceq.s(s1, s0, emptycls)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s1)\n}","parent":["eqcomi","mpgbi","mp2an","mpbi","eueqi","0ex","eubii","eq0","iota2","albidv","notbid","eleq2","noel","diff.wal.s","diff.wn.s","diff.wcel.s","diff.cv.s","diff.emptycls.s","diff.wceq.s","diffss.ex"],"children":[]},{"name":"bj-nuliotaALT","content":"Alternate proof of ~ bj-nuliota . Note that this alternate proof uses the fact that ` iota x ph ` evaluates to ` (/) ` when there is no ` x ` satisfying ` ph ` ( ~ iotanul ). This is an implementation detail of the encoding currently used in set.mm and should be avoided. (Contributed by BJ, 30-Nov-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-nuliotaALT(setvar s0, setvar s1) {\n  |- wceq(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  -| diffss(s0, s1)\n} = {\n  eqssi(emptycls, cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  0ss(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  sseqtri(cio(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), emptycls, cuni(cab(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))))\n  iotassuni(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  3eqtri(cuni(cab(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))), emptycls, cuni(cab(s0, wceq(cv(s0), emptycls))), cuni(csn(emptycls)))\n  unieqi(cab(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), cab(s0, wceq(cv(s0), emptycls)))\n  abbii(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))), wceq(cv(s0), emptycls))\n  bicomi(wal(s1, wn(wcel(cv(s1), cv(s0)))), wceq(cv(s0), emptycls))\n  eq0(s1, cv(s0))\n  unieqi(cab(s0, wceq(cv(s0), emptycls)), csn(emptycls))\n  eqcomi(cab(s0, wceq(cv(s0), emptycls)), csn(emptycls))\n  df-sn(s0, emptycls)\n  unisn(emptycls)\n  0ex()\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s0)\n}","pretty":"thm bj-nuliotaALT(setvar s0, setvar s1) {\n  ⊢ ∅ = iota(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  eqssi(emptycls, iota(s0, ∀(s1, ¬ s1 ∈ s0)))\n  0ss(iota(s0, ∀(s1, ¬ s1 ∈ s0)))\n  sseqtri(iota(s0, ∀(s1, ¬ s1 ∈ s0)), emptycls, ⋃ { s0 | ∀(s1, ¬ s1 ∈ s0)})\n  iotassuni(s0, ∀(s1, ¬ s1 ∈ s0))\n  3eqtri(⋃ { s0 | ∀(s1, ¬ s1 ∈ s0)}, emptycls, ⋃ { s0 | s0 = ∅ }, ⋃ { ∅ })\n  unieqi({ s0 | ∀(s1, ¬ s1 ∈ s0)}, { s0 | s0 = ∅ })\n  abbii(s0, ∀(s1, ¬ s1 ∈ s0), s0 = ∅)\n  bicomi(∀(s1, ¬ s1 ∈ s0), s0 = ∅)\n  eq0(s1, s0)\n  unieqi({ s0 | s0 = ∅ }, { ∅ })\n  eqcomi({ s0 | s0 = ∅ }, { ∅ })\n  df-sn(s0, emptycls)\n  unisn(emptycls)\n  0ex()\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.emptycls.s(s0)\n}","parent":["eqssi","0ss","sseqtri","iotassuni","3eqtri","unieqi","abbii","bicomi","eq0","eqcomi","df-sn","unisn","0ex","diff.cv.s","diffss.ex","diff.emptycls.s"],"children":[]},{"name":"bj-vtoclgfALT","content":"Alternate proof of ~ vtoclgf . Proof from ~ vtoclgft . (This may have been the original proof before shortening.) (Contributed by BJ, 30-Sep-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-vtoclgfALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(wcel(c0, c1), w0)\n  -| wnfc(s0, c0)\n  -| wnf(s0, w0)\n  -| wi(wceq(cv(s0), c0), wb(w1, w0))\n  -| w1\n} = {\n  mp3an12(wcel(c0, c1), w0, wa(wnfc(s0, c0), wnf(s0, w0)), wa(wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wal(s0, w1)))\n  pm3.2i(wnfc(s0, c0), wnf(s0, w0))\n  pm3.2i(wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wal(s0, w1))\n  ax-gen(s0, wi(wceq(cv(s0), c0), wb(w1, w0)))\n  ax-gen(s0, w1)\n  vtoclgft(s0, c0, c1, w0, w1)\n}","pretty":"thm bj-vtoclgfALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  ⊢ (c0 ∈ c1 → w0)\n  ⊣ F/(s0, c0)\n  ⊣ F/(s0, w0)\n  ⊣ (s0 = c0 →(w1 ↔ w0))\n  ⊣ w1\n} = {\n  mp3an12(c0 ∈ c1, w0, (F/(s0, c0)∧ F/(s0, w0)), (∀(s0,(s0 = c0 →(w1 ↔ w0)))∧ ∀(s0, w1)))\n  pm3.2i(F/(s0, c0), F/(s0, w0))\n  pm3.2i(∀(s0,(s0 = c0 →(w1 ↔ w0))), ∀(s0, w1))\n  ax-gen(s0, (s0 = c0 →(w1 ↔ w0)))\n  ax-gen(s0, w1)\n  vtoclgft(s0, c0, c1, w0, w1)\n}","parent":["mp3an12","pm3.2i","ax-gen","vtoclgft"],"children":[]},{"name":"bj-pwcfsdom","content":"Remove hypothesis from ~ pwcfsdom . Illustration of how to remove a \"proof-facilitating hypothesis\". (Can use it to shorten theorems using ~ pwcfsdom .) (Contributed by BJ, 14-Sep-2019.)","origin":"thm bj-pwcfsdom(class c0) {\n  |- wbr(cfv(cale, c0), csdm, co(cfv(cale, c0), cmap, cfv(ccf, cfv(cale, c0))))\n} = {\n  pwcfsdom(hs0, hs1, c0, cmpt(hs0, cfv(ccf, cfv(cale, c0)), cfv(char, cfv(cv(hs1), cv(hs0)))))\n  eqid(cmpt(hs0, cfv(ccf, cfv(cale, c0)), cfv(char, cfv(cv(hs1), cv(hs0)))))\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n}","pretty":"thm bj-pwcfsdom(class c0) {\n  ⊢ (aleph ` c0)[≺]((aleph ` c0)[↦](cf `(aleph ` c0)))\n} = {\n  pwcfsdom(hs0, hs1, c0, (hs0 ∈(cf `(aleph ` c0))↦(har `(hs1 ` hs0))))\n  eqid((hs0 ∈(cf `(aleph ` c0))↦(har `(hs1 ` hs0))))\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n}","parent":["pwcfsdom","eqid","diff.hs0.s","diff.hs0.c","diff.hs1.c"],"children":[]},{"name":"bj-grur1","content":"Remove hypothesis from ~ grur1 . Illustration of how to remove a \"definitional hypothesis\". This makes its uses longer, but the theorem feels more self-contained. It looks preferable when the defined term appears only once in the conclusion. (Contributed by BJ, 14-Sep-2019.)","origin":"thm bj-grur1(class c0) {\n  |- wi(wa(wcel(c0, cgru), wcel(c0, cuni(cima(cr1, con0)))), wceq(c0, cfv(cr1, cin(c0, con0))))\n} = {\n  grur1(c0, cin(c0, con0))\n  eqid(cin(c0, con0))\n}","pretty":"thm bj-grur1(class c0) {\n  ⊢ ((c0 ∈ Univ ∧ c0 ∈ ⋃(R1 \" On))→ c0 =(R1 `(c0 ⋂ On)))\n} = {\n  grur1(c0, (c0 ⋂ On))\n  eqid((c0 ⋂ On))\n}","parent":["grur1","eqid"],"children":[]},{"name":"bj-bm1.3ii","content":"The extension of a predicate is included in a set if and only if it is a set. Sufficiency is obvious, and necessity is the content of the axiom of separation ~ ax-sep . Similar to Theorem 1.3(ii) of [BellMachover] p. 463. (Contributed by NM, 21-Jun-1993.) Generalized to a closed form biconditional with existential quantifications using two different setvars (which need not be disjoint). (Revised by BJ, 8-Aug-2022.) TODO: move in place of ~ bm1.3ii .","origin":"thm bj-bm1.3ii(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wex(s0, wal(s1, wi(w0, wcel(cv(s1), cv(s0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n  -| diffsw(s0, w0)\n  -| diffsw(s2, w0)\n} = {\n  bitri(wex(s0, wal(s1, wi(w0, wcel(cv(s1), cv(s0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0))))))\n  cbvexvw(s0, hs0, wal(s1, wi(w0, wcel(cv(s1), cv(s0)))), wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))))\n  albidv(s1, wceq(cv(s0), cv(hs0)), wi(w0, wcel(cv(s1), cv(s0))), wi(w0, wcel(cv(s1), cv(hs0))))\n  imbi2d(wceq(cv(s0), cv(hs0)), w0, wcel(cv(s1), cv(s0)), wcel(cv(s1), cv(hs0)))\n  elequ2(s0, hs0, s1)\n  impbii(wex(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  exlimiv(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  mpan2(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0)))))\n  ax-sep(s2, s1, hs0, w0)\n  sylbir(wa(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0))))), wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(s2, wa(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0))))))\n  19.42v(s2, wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0))))\n  eximi(s2, wa(wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0)))), wal(s1, wb(wcel(cv(s1), cv(s2)), w0)))\n  alanimi(s1, wi(w0, wcel(cv(s1), cv(hs0))), wb(wcel(cv(s1), cv(s2)), wa(wcel(cv(s1), cv(hs0)), w0)), wb(wcel(cv(s1), cv(s2)), w0))\n  bimsc1(w0, wcel(cv(s1), cv(hs0)), wcel(cv(s1), cv(s2)))\n  sylbi(wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))), wex(hs0, wal(s1, wi(w0, wcel(cv(s1), cv(hs0))))), wex(hs0, wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))))\n  cbvexvw(s2, hs0, wal(s1, wb(wcel(cv(s1), cv(s2)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0)))\n  albidv(s1, wceq(cv(s2), cv(hs0)), wb(wcel(cv(s1), cv(s2)), w0), wb(wcel(cv(s1), cv(hs0)), w0))\n  bibi1d(wceq(cv(s2), cv(hs0)), wcel(cv(s1), cv(s2)), w0, wcel(cv(s1), cv(hs0)))\n  elequ2(s2, hs0, s1)\n  eximi(hs0, wal(s1, wb(wcel(cv(s1), cv(hs0)), w0)), wal(s1, wi(w0, wcel(cv(s1), cv(hs0)))))\n  alimi(s1, wb(wcel(cv(s1), cv(hs0)), w0), wi(w0, wcel(cv(s1), cv(hs0))))\n  biimpr(wcel(cv(s1), cv(hs0)), w0)\n  diff.wal.s(s0, s1, wi(w0, wcel(cv(s1), cv(hs0))))\n  diff.wi.s(s0, w0, wcel(cv(s1), cv(hs0)))\n  diff.wcel.s(s0, cv(s1), cv(hs0))\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(wal(s1, wi(w0, wcel(cv(s1), cv(s0)))))\n  diff.wceq.s(s1, cv(s0), cv(hs0))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.hs0.w(wex(s2, wal(s1, wb(wcel(cv(s1), cv(s2)), w0))))\n  diff.hs0.w(w0)\n  diff.wal.s(s2, s1, wi(w0, wcel(cv(s1), cv(hs0))))\n  diff.wi.s(s2, w0, wcel(cv(s1), cv(hs0)))\n  diff.wal.s(s2, s1, wb(wcel(cv(s1), cv(hs0)), w0))\n  diff.wb.s(s2, wcel(cv(s1), cv(hs0)), w0)\n  diff.wcel.s(s2, cv(s1), cv(hs0))\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.hs0.w(wal(s1, wb(wcel(cv(s1), cv(s2)), w0)))\n  diff.wceq.s(s1, cv(s2), cv(hs0))\n  diff.cv.s(s1, s2)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","pretty":"thm bj-bm1.3ii(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ (∃(s0, ∀(s1,(w0 → s1 ∈ s0)))↔ ∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, s2)\n  ⊣ d(s0, w0)\n  ⊣ d(s2, w0)\n} = {\n  bitri(∃(s0, ∀(s1,(w0 → s1 ∈ s0))), ∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))), ∃(hs0, ∀(s1,(w0 → s1 ∈ hs0))))\n  cbvexvw(s0, hs0, ∀(s1,(w0 → s1 ∈ s0)), ∀(s1,(w0 → s1 ∈ hs0)))\n  albidv(s1, s0 = hs0, (w0 → s1 ∈ s0), (w0 → s1 ∈ hs0))\n  imbi2d(s0 = hs0, w0, s1 ∈ s0, s1 ∈ hs0)\n  elequ2(s0, hs0, s1)\n  impbii(∃(hs0, ∀(s1,(w0 → s1 ∈ hs0))), ∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))))\n  exlimiv(hs0, ∀(s1,(w0 → s1 ∈ hs0)), ∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))))\n  mpan2(∀(s1,(w0 → s1 ∈ hs0)), ∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))), ∃(s2, ∀(s1,(s1 ∈ s2 ↔(s1 ∈ hs0 ∧ w0)))))\n  ax-sep(s2, s1, hs0, w0)\n  sylbir((∀(s1,(w0 → s1 ∈ hs0))∧ ∃(s2, ∀(s1,(s1 ∈ s2 ↔(s1 ∈ hs0 ∧ w0))))), ∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))), ∃(s2,(∀(s1,(w0 → s1 ∈ hs0))∧ ∀(s1,(s1 ∈ s2 ↔(s1 ∈ hs0 ∧ w0))))))\n  19.42v(s2, ∀(s1,(w0 → s1 ∈ hs0)), ∀(s1,(s1 ∈ s2 ↔(s1 ∈ hs0 ∧ w0))))\n  eximi(s2, (∀(s1,(w0 → s1 ∈ hs0))∧ ∀(s1,(s1 ∈ s2 ↔(s1 ∈ hs0 ∧ w0)))), ∀(s1,(s1 ∈ s2 ↔ w0)))\n  alanimi(s1, (w0 → s1 ∈ hs0), (s1 ∈ s2 ↔(s1 ∈ hs0 ∧ w0)), (s1 ∈ s2 ↔ w0))\n  bimsc1(w0, s1 ∈ hs0, s1 ∈ s2)\n  sylbi(∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))), ∃(hs0, ∀(s1,(w0 → s1 ∈ hs0))), ∃(hs0, ∀(s1,(s1 ∈ hs0 ↔ w0))))\n  cbvexvw(s2, hs0, ∀(s1,(s1 ∈ s2 ↔ w0)), ∀(s1,(s1 ∈ hs0 ↔ w0)))\n  albidv(s1, s2 = hs0, (s1 ∈ s2 ↔ w0), (s1 ∈ hs0 ↔ w0))\n  bibi1d(s2 = hs0, s1 ∈ s2, w0, s1 ∈ hs0)\n  elequ2(s2, hs0, s1)\n  eximi(hs0, ∀(s1,(s1 ∈ hs0 ↔ w0)), ∀(s1,(w0 → s1 ∈ hs0)))\n  alimi(s1, (s1 ∈ hs0 ↔ w0), (w0 → s1 ∈ hs0))\n  biimpr(s1 ∈ hs0, w0)\n  diff.wal.s(s0, s1, (w0 → s1 ∈ hs0))\n  diff.wi.s(s0, w0, s1 ∈ hs0)\n  diff.wcel.s(s0, s1, hs0)\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(∀(s1,(w0 → s1 ∈ s0)))\n  diff.wceq.s(s1, s0, hs0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.hs0.w(∃(s2, ∀(s1,(s1 ∈ s2 ↔ w0))))\n  diff.hs0.w(w0)\n  diff.wal.s(s2, s1, (w0 → s1 ∈ hs0))\n  diff.wi.s(s2, w0, s1 ∈ hs0)\n  diff.wal.s(s2, s1, (s1 ∈ hs0 ↔ w0))\n  diff.wb.s(s2, s1 ∈ hs0, w0)\n  diff.wcel.s(s2, s1, hs0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.hs0.w(∀(s1,(s1 ∈ s2 ↔ w0)))\n  diff.wceq.s(s1, s2, hs0)\n  diff.cv.s(s1, s2)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","parent":["bitri","cbvexvw","albidv","imbi2d","elequ2","impbii","exlimiv","mpan2","ax-sep","sylbir","19.42v","eximi","alanimi","bimsc1","sylbi","bibi1d","alimi","biimpr","diff.wal.s","diff.wi.s","diff.wcel.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.hs0.w","diff.wceq.s","diff.wb.s"],"children":[]},{"name":"bj-0nelopab","content":"The empty set is never an element in an ordered-pair class abstraction. (Contributed by Alexander van der Vekens, 5-Nov-2017.) (Proof shortened by BJ, 22-Jul-2023.) TODO: move to Main when one can reorder sections so that we can use ~ relopab (this is a very limited reordering).","origin":"thm bj-0nelopab(setvar s0, setvar s1, wff w0) {\n  |- wn(wcel(emptycls, copab(s0, s1, w0)))\n} = {\n  ax-mp(wn(wcel(emptycls, copab(s0, s1, w0))), wrel(copab(s0, s1, w0)))\n  relopab(s0, s1, w0)\n  0nelrel0(copab(s0, s1, w0))\n}","pretty":"thm bj-0nelopab(setvar s0, setvar s1, wff w0) {\n  ⊢ ¬ ∅ ∈ { < s0, s1 > | w0 }\n} = {\n  ax-mp(¬ ∅ ∈ { < s0, s1 > | w0 }, Rel({ < s0, s1 > | w0 }))\n  relopab(s0, s1, w0)\n  0nelrel0({ < s0, s1 > | w0 })\n}","parent":["ax-mp","relopab","0nelrel0"],"children":[]},{"name":"bj-brrelex12ALT","content":"Two classes related by a binary relation are both sets. Alternate proof of ~ brrelex12 . (Contributed by BJ, 14-Jul-2023.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-brrelex12ALT(class c0, class c1, class c2) {\n  |- wi(wa(wrel(c0), wbr(c1, c0, c2)), wa(wcel(c1, universe), wcel(c2, universe)))\n} = {\n  sylan(wrel(c0), wbr(c1, c0, c2), wa(wcel(c1, universe), wcel(c2, universe)), wn(wcel(emptycls, c0)))\n  0nelrel0(c0)\n  nsyl2(wa(wn(wcel(emptycls, c0)), wbr(c1, c0, c2)), wa(wcel(c1, universe), wcel(c2, universe)), wi(wbr(c1, c0, c2), wcel(emptycls, c0)))\n  impcom(wn(wcel(emptycls, c0)), wbr(c1, c0, c2), wn(wi(wbr(c1, c0, c2), wcel(emptycls, c0))))\n  mth8(wbr(c1, c0, c2), wcel(emptycls, c0))\n  syl(wn(wa(wcel(c1, universe), wcel(c2, universe))), wi(wbr(c1, c0, c2), wcel(emptycls, c0)), wceq(cop(c1, c2), emptycls))\n  opprc(c1, c2)\n  syl5ib(wceq(cop(c1, c2), emptycls), wbr(c1, c0, c2), wcel(emptycls, c0), wcel(cop(c1, c2), c0))\n  biimpi(wbr(c1, c0, c2), wcel(cop(c1, c2), c0))\n  df-br(c1, c0, c2)\n  eleq1(cop(c1, c2), emptycls, c0)\n}","pretty":"thm bj-brrelex12ALT(class c0, class c1, class c2) {\n  ⊢ ((Rel(c0)∧ c1[c0]c2)→(c1 ∈ 𝕌 ∧ c2 ∈ 𝕌))\n} = {\n  sylan(Rel(c0), c1[c0]c2, (c1 ∈ 𝕌 ∧ c2 ∈ 𝕌), ¬ ∅ ∈ c0)\n  0nelrel0(c0)\n  nsyl2((¬ ∅ ∈ c0 ∧ c1[c0]c2), (c1 ∈ 𝕌 ∧ c2 ∈ 𝕌), (c1[c0]c2 → ∅ ∈ c0))\n  impcom(¬ ∅ ∈ c0, c1[c0]c2, ¬(c1[c0]c2 → ∅ ∈ c0))\n  mth8(c1[c0]c2, ∅ ∈ c0)\n  syl(¬(c1 ∈ 𝕌 ∧ c2 ∈ 𝕌), (c1[c0]c2 → ∅ ∈ c0), < c1, c2 > = ∅)\n  opprc(c1, c2)\n  syl5ib(< c1, c2 > = ∅, c1[c0]c2, ∅ ∈ c0, < c1, c2 > ∈ c0)\n  biimpi(c1[c0]c2, < c1, c2 > ∈ c0)\n  df-br(c1, c0, c2)\n  eleq1(< c1, c2 >, emptycls, c0)\n}","parent":["sylan","0nelrel0","nsyl2","impcom","mth8","syl","opprc","syl5ib","biimpi","df-br","eleq1"],"children":[]},{"name":"bj-elep","content":"Two classes are related by the membership relation if and only if the first is an element of the second and the second is a set. Can be moved to Main when some parts have been reordered. (Contributed by BJ, 14-Jul-2023.)","origin":"thm bj-elep(class c0, class c1) {\n  |- wb(wbr(c0, cep, c1), wa(wcel(c0, c1), wcel(c1, universe)))\n} = {\n  impbii(wbr(c0, cep, c1), wa(wcel(c0, c1), wcel(c1, universe)))\n  jca(wbr(c0, cep, c1), wcel(c0, c1), wcel(c1, universe))\n  mpcom(wbr(c0, cep, c1), wcel(c0, c1), wa(wcel(c0, universe), wcel(c1, universe)))\n  mpan(wbr(c0, cep, c1), wa(wcel(c0, universe), wcel(c1, universe)), wrel(cep))\n  biimpd(wa(wcel(c0, universe), wcel(c1, universe)), wbr(c0, cep, c1), wcel(c0, c1))\n  brabga(hs0, hs1, c0, universe, c1, universe, cep, wcel(c0, c1), wcel(cv(hs0), cv(hs1)))\n  mpan(wbr(c0, cep, c1), wcel(c1, universe), wrel(cep))\n  rele()\n  simprd(wa(wrel(cep), wbr(c0, cep, c1)), wcel(c1, universe), wcel(c0, universe))\n  brrelex12(cep, c0, c1)\n  mpbird(wa(wcel(c0, c1), wcel(c1, universe)), wbr(c0, cep, c1), wcel(c0, c1))\n  simpl(wcel(c0, c1), wcel(c1, universe))\n  brabga(hs0, hs1, c0, c1, c1, universe, cep, wcel(c0, c1), wcel(cv(hs0), cv(hs1)))\n  eleq12(cv(hs0), c0, cv(hs1), c1)\n  df-eprel(hs0, hs1)\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c0)\n  diff.hs1.c(c1)\n  diff.hs0.w(wcel(c0, c1))\n  diff.hs1.w(wcel(c0, c1))\n}","pretty":"thm bj-elep(class c0, class c1) {\n  ⊢ (c0[∈]c1 ↔(c0 ∈ c1 ∧ c1 ∈ 𝕌))\n} = {\n  impbii(c0[∈]c1, (c0 ∈ c1 ∧ c1 ∈ 𝕌))\n  jca(c0[∈]c1, c0 ∈ c1, c1 ∈ 𝕌)\n  mpcom(c0[∈]c1, c0 ∈ c1, (c0 ∈ 𝕌 ∧ c1 ∈ 𝕌))\n  mpan(c0[∈]c1, (c0 ∈ 𝕌 ∧ c1 ∈ 𝕌), Rel(∈))\n  biimpd((c0 ∈ 𝕌 ∧ c1 ∈ 𝕌), c0[∈]c1, c0 ∈ c1)\n  brabga(hs0, hs1, c0, universe, c1, universe, cep, c0 ∈ c1, hs0 ∈ hs1)\n  mpan(c0[∈]c1, c1 ∈ 𝕌, Rel(∈))\n  rele()\n  simprd((Rel(∈)∧ c0[∈]c1), c1 ∈ 𝕌, c0 ∈ 𝕌)\n  brrelex12(cep, c0, c1)\n  mpbird((c0 ∈ c1 ∧ c1 ∈ 𝕌), c0[∈]c1, c0 ∈ c1)\n  simpl(c0 ∈ c1, c1 ∈ 𝕌)\n  brabga(hs0, hs1, c0, c1, c1, universe, cep, c0 ∈ c1, hs0 ∈ hs1)\n  eleq12(hs0, c0, hs1, c1)\n  df-eprel(hs0, hs1)\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c0)\n  diff.hs1.c(c1)\n  diff.hs0.w(c0 ∈ c1)\n  diff.hs1.w(c0 ∈ c1)\n}","parent":["impbii","jca","mpcom","mpan","biimpd","brabga","rele","simprd","brrelex12","mpbird","simpl","eleq12","df-eprel","diff.hs0.s","diff.hs0.c","diff.hs1.c","diff.hs0.w","diff.hs1.w"],"children":["bj-epelg"]},{"name":"bj-epelg","content":"The membership relation and the membership predicate agree when the \"containing\" class is a set. General version of ~ epel and closed form of ~ epeli . (Contributed by Scott Fenton, 27-Mar-2011.) (Revised by Mario Carneiro, 28-Apr-2015.) (Revised by BJ, 14-Jul-2023.)","origin":"thm bj-epelg(class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wb(wbr(c2, cep, c0), wcel(c2, c0)))\n} = {\n  impbid2(wcel(c0, c1), wbr(c2, cep, c0), wcel(c2, c0))\n  simplbi(wbr(c2, cep, c0), wcel(c2, c0), wcel(c0, universe))\n  syl5com(wcel(c0, c1), wcel(c2, c0), wbr(c2, cep, c0), wcel(c0, universe))\n  elex(c0, c1)\n  simplbi2(wcel(c2, c0), wcel(c0, universe), wbr(c2, cep, c0))\n  bj-elep(c2, c0)\n}","pretty":"thm bj-epelg(class c0, class c1, class c2) {\n  ⊢ (c0 ∈ c1 →(c2[∈]c0 ↔ c2 ∈ c0))\n} = {\n  impbid2(c0 ∈ c1, c2[∈]c0, c2 ∈ c0)\n  simplbi(c2[∈]c0, c2 ∈ c0, c0 ∈ 𝕌)\n  syl5com(c0 ∈ c1, c2 ∈ c0, c2[∈]c0, c0 ∈ 𝕌)\n  elex(c0, c1)\n  simplbi2(c2 ∈ c0, c0 ∈ 𝕌, c2[∈]c0)\n  bj-elep(c2, c0)\n}","parent":["impbid2","simplbi","syl5com","elex","simplbi2","bj-elep"],"children":[]},{"name":"bj-nsnid","content":"A set does not contain the singleton formed on it. More precisely, one can prove that a class contains the singleton formed on it if and only if it is proper and contains the \"singleton formed on it\", which is the empty set: ` |- -. ( { A } e. A <-> ( (/) e. A -> A e. _V ) ) ` . (Contributed by BJ, 4-Feb-2023.)","origin":"thm bj-nsnid(class c0, class c1) {\n  |- wi(wcel(c0, c1), wn(wcel(csn(c0), c0)))\n} = {\n  mtoi(wcel(c0, c1), wcel(csn(c0), c0), wa(wcel(c0, csn(c0)), wcel(csn(c0), c0)))\n  en2lp(c0, csn(c0))\n  ex(wcel(c0, c1), wcel(csn(c0), c0), wa(wcel(c0, csn(c0)), wcel(csn(c0), c0)))\n  anim1i(wcel(c0, c1), wcel(csn(c0), c0), wcel(c0, csn(c0)))\n  snidg(c0, c1)\n}","pretty":"thm bj-nsnid(class c0, class c1) {\n  ⊢ (c0 ∈ c1 → ¬ { c0 } ∈ c0)\n} = {\n  mtoi(c0 ∈ c1, { c0 } ∈ c0, (c0 ∈ { c0 } ∧ { c0 } ∈ c0))\n  en2lp(c0, { c0 })\n  ex(c0 ∈ c1, { c0 } ∈ c0, (c0 ∈ { c0 } ∧ { c0 } ∈ c0))\n  anim1i(c0 ∈ c1, { c0 } ∈ c0, c0 ∈ { c0 })\n  snidg(c0, c1)\n}","parent":["mtoi","en2lp","ex","anim1i","snidg"],"children":["bj-inftyexpitaudisj"]}]}