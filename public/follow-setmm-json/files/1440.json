{"index":1440,"title":"Alternative definitions of function and operation values","content":"The current definition of the value ` ( F `` A ) ` of a function ` F ` at an argument ` A ` (see ~ df-fv ) assures that this value is always a set, see ~ fex . This is because this definition can be applied to any classes ` F ` and ` A ` , and evaluates to the empty set when it is not meaningful (as shown by ~ ndmfv and ~ fvprc ). Although it is very convenient for many theorems on functions and their proofs, there are some cases in which from ` ( F `` A ) = (/) ` alone it cannot be decided/derived whether ` ( F `` A ) ` is meaningful ( ` F ` is actually a function which is defined for ` A ` and really has the function value ` (/) ` at ` A ` ) or not. Therefore, additional assumptions are required, such as ` (/) e/ ran F ` , ` (/) e. ran F ` or ` Fun F /\\ A e. dom F ` (see, for example, ~ ndmfvrcl ). To avoid such an ambiguity, an alternative definition ` ( F ''' A ) ` (see ~ df-afv ) would be possible which evaluates to the universal class ( ` ( F ''' A ) = _V ` ) if it is not meaningful (see ~ afvnfundmuv , ~ ndmafv , ~ afvprc and ~ nfunsnafv ), and which corresponds to the current definition ( ` ( F `` A ) = ( F ''' A ) ` ) if it is (see ~ afvfundmfveq ). That means ` ( F ''' A ) = _V -> ( F `` A ) = (/) ` (see ~ afvpcfv0 ), but ` ( F `` A ) = (/) -> ( F ''' A ) = _V ` is not generally valid. In the theory of partial functions, it is a common case that ` F ` is not defined at ` A ` , which also would result in ` ( F ''' A ) = _V ` . In this context we say ` ( F ''' A ) ` \"is not defined\" instead of \"is not meaningful\". With this definition the following intuitive equivalence holds: ` ( F ''' A ) e. _V ` <-> \" ` ( F ''' A ) ` is meaningful/defined\". An interesting question would be if ` ( F `` A ) ` could be replaced by ` ( F ''' A ) ` in most of the theorems based on function values. If we look at the (currently 19) proofs using the definition ~ df-fv of ` ( F `` A ) `, we see that analogues for the following 8 theorems can be proven using the alternative definition: ~ fveq1 -> ~ afveq1 , ~ fveq2 -> ~ afveq2 , ~ nffv -> ~ nfafv , ~ csbfv12 -> csbafv12g , ~ fvres -> ~ afvres , ~ rlimdm -> ~ rlimdmafv , ~ tz6.12-1 -> ~ tz6.12-1-afv , ~ fveu -> ~ afveu . Three theorems proved by directly using ~ df-fv are within a mathbox ( ~ fvsb ) or not used ( ~ isumclim3 , ~ avril1 ). However, the remaining 8 theorems proved by directly using ~ df-fv are used more or less often: * ~ fvex : used in about 1750 proofs. * ~ tz6.12-1 : root theorem of many theorems which have not a strict analogue, and which are used many times: ~ fvprc (used in about 127 proofs), ~ tz6.12i (used - indirectly via ~ fvbr0 and ~ fvrn0 - in 18 proofs, and in ~ fvclss used in ~ fvclex used in ~ fvresex , which is not used!), ~ dcomex (used in 4 proofs), ~ ndmfv (used in 86 proofs) and ~ nfunsn (used by ~ dffv2 which is not used). * ~ fv2 : only used by ~ elfv , which is only used by ~ fv3 , which is not used. * ~ dffv3 : used by ~ dffv4 (the previous \"df-fv\"), which now is only used in deprecated (usage discouraged) theorems or within mathboxes ( ~ csbfv12gALTVD ), by ~ shftval (itself used in 9 proofs), by ~ dffv5 (mathbox) and by ~ fvco2 , which has the analogue ~ afvco2 . * ~ fvopab5 : used only by ~ ajval (not used) and by ~ adjval ( used - indirectly - in 9 proofs). * ~ zsum : used (via ~ isum , ~ sum0 and ~ fsumsers ) in more than 90 proofs. * ~ isumshft : used in ~ pserdv2 and (via ~ logtayl ) 4 other proofs. * ~ ovtpos : used in 14 proofs. As a result of this analysis we can say that the current definition of a function value is crucial for Metamath and cannot be exchanged easily with an alternative definition. While ~ fv2 , ~ dffv3 , ~ fvopab5 , ~ zsum , ~ isumshft and ~ ovtpos are not critical or are, hopefully, also valid for the alternative definition, ~ fvex and ~ tz6.12-1 (and the theorems based on them) are essential for the current definition of function values. With the same arguments, an alternative definition of operation values ` (( A O B )) ` could be meaningful to avoid ambiguities, see ~ df-aov . For additional discussions/material see ~ https://groups.google.com/forum/#!topic/metamath/cteNUppB6A4 .","blocks":[{"name":"wdfat","content":"Extend the definition of a wff to include the \"defined at\" predicate. Read: \"(the function) ` F ` is defined at (the argument) ` A ` \". In a previous version, the token \"def@\" was used. However, since the @ is used (informally) as a replacement for $ in commented out sections that may be deleted some day. While there is no violation of any standard to use the @ in a token, it could make the search for such commented-out sections slightly more difficult. (See remark of Norman Megill at ~ https://groups.google.com/forum/#!topic/metamath/cteNUppB6A4 ).","origin":"prop wff wdfat(class c0, class c1) { c0[defAt]c1 }","pretty":"","parent":[],"children":[]},{"name":"diff.wdfat.s","content":"","origin":"axiom diff.wdfat.s(setvar sBase, class c0, class c1) {\n  |- diffsw(sBase, wdfat(c0, c1))\n  -| diffsc(sBase, c0)\n  -| diffsc(sBase, c1)\n}","pretty":"axiom diff.wdfat.s(setvar sBase, class c0, class c1) {\n  ⊢ d(sBase, c0[defAt]c1)\n  ⊣ d(sBase, c0)\n  ⊣ d(sBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wdfat.c","content":"","origin":"axiom diff.wdfat.c(class cBase, class c0, class c1) {\n  |- diffcw(cBase, wdfat(c0, c1))\n  -| diffcc(cBase, c0)\n  -| diffcc(cBase, c1)\n}","pretty":"axiom diff.wdfat.c(class cBase, class c0, class c1) {\n  ⊢ d(cBase, c0[defAt]c1)\n  ⊣ d(cBase, c0)\n  ⊣ d(cBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wdfat.w","content":"","origin":"axiom diff.wdfat.w(wff wBase, class c0, class c1) {\n  |- diffww(wBase, wdfat(c0, c1))\n  -| diffcw(c0, wBase)\n  -| diffcw(c1, wBase)\n}","pretty":"axiom diff.wdfat.w(wff wBase, class c0, class c1) {\n  ⊢ d(wBase, c0[defAt]c1)\n  ⊣ d(c0, wBase)\n  ⊣ d(c1, wBase)\n}","parent":[],"children":[]},{"name":"cafv","content":"Extend the definition of a class to include the value of a function. Read: \"the value of ` F ` at ` A ` \" or \" ` F ` of ` A ` \". In a previous version, the symbol \" ' \" was used. However, since the similarity with the symbol ` `` ` used for the current definition of a function's value (see ~ df-fv ), which, by the way, was intended to visualize that in many cases ` `` ` and \" ' \" are exchangeable, makes reading the theorems, especially those which uses both definitions as ~ dfafv2 , very difficult, 3 apostrophes ` ''' ` are used now so that it's easier to distinguish from ~ df-fv and ~ df-ima . And not three backticks ( three times ` `` ` ) since that would be annoying to escape in a comment. (See remark of Norman Megill and Gerard Lang at ~ https://groups.google.com/forum/#!topic/metamath/cteNUppB6A4 ).","origin":"prop class cafv(class c0, class c1) { (c0 ''' c1) }","pretty":"","parent":[],"children":[]},{"name":"diff.cafv.s","content":"","origin":"axiom diff.cafv.s(setvar sBase, class c0, class c1) {\n  |- diffsc(sBase, cafv(c0, c1))\n  -| diffsc(sBase, c0)\n  -| diffsc(sBase, c1)\n}","pretty":"axiom diff.cafv.s(setvar sBase, class c0, class c1) {\n  ⊢ d(sBase,(c0 ''' c1))\n  ⊣ d(sBase, c0)\n  ⊣ d(sBase, c1)\n}","parent":[],"children":[]},{"name":"diff.cafv.c","content":"","origin":"axiom diff.cafv.c(class cBase, class c0, class c1) {\n  |- diffcc(cBase, cafv(c0, c1))\n  -| diffcc(cBase, c0)\n  -| diffcc(cBase, c1)\n}","pretty":"axiom diff.cafv.c(class cBase, class c0, class c1) {\n  ⊢ d(cBase,(c0 ''' c1))\n  ⊣ d(cBase, c0)\n  ⊣ d(cBase, c1)\n}","parent":[],"children":[]},{"name":"diff.cafv.w","content":"","origin":"axiom diff.cafv.w(wff wBase, class c0, class c1) {\n  |- diffcw(cafv(c0, c1), wBase)\n  -| diffcw(c0, wBase)\n  -| diffcw(c1, wBase)\n}","pretty":"axiom diff.cafv.w(wff wBase, class c0, class c1) {\n  ⊢ d((c0 ''' c1), wBase)\n  ⊣ d(c0, wBase)\n  ⊣ d(c1, wBase)\n}","parent":[],"children":[]},{"name":"caov","content":"Extend class notation to include the value of an operation ` F ` (such as ` + ` ) for two arguments ` A ` and ` B ` . Note that the syntax is simply three class symbols in a row surrounded by a pair of parentheses in contrast to the current definition, see ~ df-ov .","origin":"prop class caov(class c0, class c1, class c2) { ((c0 c1 c2)) }","pretty":"","parent":[],"children":[]},{"name":"diff.caov.s","content":"","origin":"axiom diff.caov.s(setvar sBase, class c0, class c1, class c2) {\n  |- diffsc(sBase, caov(c0, c1, c2))\n  -| diffsc(sBase, c0)\n  -| diffsc(sBase, c1)\n  -| diffsc(sBase, c2)\n}","pretty":"axiom diff.caov.s(setvar sBase, class c0, class c1, class c2) {\n  ⊢ d(sBase,((c0 c1 c2)))\n  ⊣ d(sBase, c0)\n  ⊣ d(sBase, c1)\n  ⊣ d(sBase, c2)\n}","parent":[],"children":[]},{"name":"diff.caov.c","content":"","origin":"axiom diff.caov.c(class cBase, class c0, class c1, class c2) {\n  |- diffcc(cBase, caov(c0, c1, c2))\n  -| diffcc(cBase, c0)\n  -| diffcc(cBase, c1)\n  -| diffcc(cBase, c2)\n}","pretty":"axiom diff.caov.c(class cBase, class c0, class c1, class c2) {\n  ⊢ d(cBase,((c0 c1 c2)))\n  ⊣ d(cBase, c0)\n  ⊣ d(cBase, c1)\n  ⊣ d(cBase, c2)\n}","parent":[],"children":[]},{"name":"diff.caov.w","content":"","origin":"axiom diff.caov.w(wff wBase, class c0, class c1, class c2) {\n  |- diffcw(caov(c0, c1, c2), wBase)\n  -| diffcw(c0, wBase)\n  -| diffcw(c1, wBase)\n  -| diffcw(c2, wBase)\n}","pretty":"axiom diff.caov.w(wff wBase, class c0, class c1, class c2) {\n  ⊢ d(((c0 c1 c2)), wBase)\n  ⊣ d(c0, wBase)\n  ⊣ d(c1, wBase)\n  ⊣ d(c2, wBase)\n}","parent":[],"children":[]},{"name":"df-dfat","content":"Definition of the predicate that determines if some class ` F ` is defined as function for an argument ` A ` or, in other words, if the function value for some class ` F ` for an argument ` A ` is defined. We say that ` F ` is defined at ` A ` if a ` F ` is a function restricted to the member ` A ` of its domain. (Contributed by Alexander van der Vekens, 25-May-2017.)","origin":"axiom df-dfat(class c0, class c1) {\n  |- wb(wdfat(c0, c1), wa(wcel(c1, cdm(c0)), wfun(cres(c0, csn(c1)))))\n}","pretty":"axiom df-dfat(class c0, class c1) {\n  ⊢ (c0[defAt]c1 ↔(c1 ∈ dom(c0)∧ Fun((c0 |` { c1 }))))\n}","parent":[],"children":["dfateq12d","nfdfat","dfdfat2","fundmdfat","dfatprc","dfatelrn","ndmafv","nfunsnafv","afvpcfv0","afvfvn0fveq","afv0nbfvbi","fnbrafvb","afvelrn","afvres","tz6.12-afv","dmfcoafv","afvco2","aovmpt4g","ndmafv2nrn","funressndmafv2rn","nfunsnafv2","dmafv2rnb","afv2res","tz6.12-afv2","dfatbrafv2b","dfatdmfcoafv2","dfatcolem","dfatco","afv2ndeffv0","afv2fvn0fveq"]},{"name":"df-afv","content":"Alternative definition of the value of a function, ` ( F ''' A ) ` , also known as function application. In contrast to ` ( F `` A ) = (/) ` (see ~ df-fv and ~ ndmfv ), ` ( F ''' A ) = _V ` if F is not defined for A! (Contributed by Alexander van der Vekens, 25-May-2017.) (Revised by BJ/AV, 25-Aug-2022.)","origin":"axiom df-afv(setvar s0, class c0, class c1) {\n  |- wceq(cafv(c0, c1), caiota(s0, wbr(c1, c0, cv(s0))))\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c0)\n}","pretty":"axiom df-afv(setvar s0, class c0, class c1) {\n  ⊢ (c0 ''' c1)= iota'(s0, c1[c0]s0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c0)\n}","parent":[],"children":["dfafv2"]},{"name":"df-aov","content":"Define the value of an operation. In contrast to ~ df-ov , the alternative definition for a function value (see ~ df-afv ) is used. By this, the value of the operation applied to two arguments is the universal class if the operation is not defined for these two arguments. There are still no restrictions of any kind on what those class expressions may be, although only certain kinds of class expressions - a binary operation ` F ` and its arguments ` A ` and ` B ` - will be useful for proving meaningful theorems. (Contributed by Alexander van der Vekens, 26-May-2017.)","origin":"axiom df-aov(class c0, class c1, class c2) {\n  |- wceq(caov(c0, c1, c2), cafv(c1, cop(c0, c2)))\n}","pretty":"axiom df-aov(class c0, class c1, class c2) {\n  ⊢ ((c0 c1 c2))=(c1 ''' < c0, c2 >)\n}","parent":[],"children":["aoveq123d","nfaov","aovfundmoveq","aovnfundmuv","ndmaov","aovvdm","nfunsnaov","aovvfunressn","aovprc","aovrcl","aovpcov0","aovnuoveq","aovvoveq","aov0ov0","aovovn0oveq","aov0nbovbi","aovov0bi","fnotaovb","ffnaov","aoprssdm"]}]}