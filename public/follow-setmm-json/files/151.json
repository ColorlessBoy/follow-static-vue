{"index":151,"title":"Undefined values","content":"","blocks":[{"name":"cund","content":"Extend class notation with undefined value function.","origin":"const class cund { Undef }","pretty":"","parent":[],"children":[]},{"name":"diff.cund.s","content":"","origin":"axiom diff.cund.s(setvar s0) {\n  |- diffsc(s0, cund)\n}","pretty":"axiom diff.cund.s(setvar s0) {\n  ⊢ d(s0, Undef)\n}","parent":[],"children":[]},{"name":"diff.cund.c","content":"","origin":"axiom diff.cund.c(class c0) {\n  |- diffcc(cund, c0)\n}","pretty":"axiom diff.cund.c(class c0) {\n  ⊢ d(Undef, c0)\n}","parent":[],"children":[]},{"name":"diff.cund.w","content":"","origin":"axiom diff.cund.w(wff w0) {\n  |- diffcw(cund, w0)\n}","pretty":"axiom diff.cund.w(wff w0) {\n  ⊢ d(Undef, w0)\n}","parent":[],"children":[]},{"name":"df-undef","content":"Define the undefined value function, whose value at set ` s ` is guaranteed not to be a member of ` s ` (see ~ pwuninel ). (Contributed by NM, 15-Sep-2011.)","origin":"axiom df-undef(setvar s0) {\n  |- wceq(cund, cmpt(s0, universe, cpw(cuni(cv(s0)))))\n}","pretty":"axiom df-undef(setvar s0) {\n  ⊢ Undef =(s0 ∈ 𝕌 ↦ P(⋃ s0))\n}","parent":[],"children":["undefval"]},{"name":"pwuninel2","content":"Direct proof of ~ pwuninel avoiding functions and thus several ZF axioms. (Contributed by Stefan O'Rear, 22-Feb-2015.)","origin":"thm pwuninel2(class c0, class c1) {\n  |- wi(wcel(cuni(c0), c1), wn(wcel(cpw(cuni(c0)), c0)))\n} = {\n  nsyl(wcel(cuni(c0), c1), wcel(cpw(cuni(c0)), c0), wss(cpw(cuni(c0)), cuni(c0)))\n  pwnss(cuni(c0), c1)\n  elssuni(cpw(cuni(c0)), c0)\n}","pretty":"thm pwuninel2(class c0, class c1) {\n  ⊢ (⋃ c0 ∈ c1 → ¬ P(⋃ c0)∈ c0)\n} = {\n  nsyl(⋃ c0 ∈ c1, P(⋃ c0)∈ c0, P(⋃ c0)⊆ ⋃ c0)\n  pwnss(⋃ c0, c1)\n  elssuni(P(⋃ c0), c0)\n}","parent":["nsyl","pwnss","elssuni"],"children":["pwuninel"]},{"name":"pwuninel","content":"The power set of the union of a set does not belong to the set. This theorem provides a way of constructing a new set that doesn't belong to a given set. See also ~ pwuninel2 . (Contributed by NM, 27-Jun-2008.) (Proof shortened by Mario Carneiro, 23-Dec-2016.)","origin":"thm pwuninel(class c0) {\n  |- wn(wcel(cpw(cuni(c0)), c0))\n} = {\n  pm2.61i(wn(wcel(cpw(cuni(c0)), c0)), wcel(cpw(cuni(c0)), c0))\n  syl(wcel(cpw(cuni(c0)), c0), wn(wcel(cpw(cuni(c0)), c0)), wcel(cuni(c0), universe))\n  pwexr(cuni(c0), c0)\n  pwuninel2(c0, universe)\n  id(wn(wcel(cpw(cuni(c0)), c0)))\n}","pretty":"thm pwuninel(class c0) {\n  ⊢ ¬ P(⋃ c0)∈ c0\n} = {\n  pm2.61i(¬ P(⋃ c0)∈ c0, P(⋃ c0)∈ c0)\n  syl(P(⋃ c0)∈ c0, ¬ P(⋃ c0)∈ c0, ⋃ c0 ∈ 𝕌)\n  pwexr(⋃ c0, c0)\n  pwuninel2(c0, universe)\n  id(¬ P(⋃ c0)∈ c0)\n}","parent":["pm2.61i","syl","pwexr","pwuninel2","id"],"children":["undefnel2","disjen","pnfnre","kelac2lem","kelac2","ndfatafv2nrn","afv2ndefb"]},{"name":"undefval","content":"Value of the undefined value function. Normally we will not reference the explicit value but will use ~ undefnel instead. (Contributed by NM, 15-Sep-2011.) (Revised by Mario Carneiro, 24-Dec-2016.)","origin":"thm undefval(class c0, class c1) {\n  |- wi(wcel(c0, c1), wceq(cfv(cund, c0), cpw(cuni(c0))))\n} = {\n  fvmptd3(hs0, cund, c0, cpw(cuni(c0)), universe, cpw(cuni(cv(hs0))), universe, wcel(c0, c1))\n  df-undef(hs0)\n  pweqd(cuni(cv(hs0)), cuni(c0), wceq(cv(hs0), c0))\n  unieq(cv(hs0), c0)\n  elex(c0, c1)\n  pwexd(cuni(c0), universe, wcel(c0, c1))\n  uniexg(c0, c1)\n  diff.hs0.c(c0)\n  diff.hs0.c(cpw(cuni(c0)))\n  diff.hs0.c(universe)\n}","pretty":"thm undefval(class c0, class c1) {\n  ⊢ (c0 ∈ c1 →(Undef ` c0)= P(⋃ c0))\n} = {\n  fvmptd3(hs0, cund, c0, P(⋃ c0), universe, P(⋃ hs0), universe, c0 ∈ c1)\n  df-undef(hs0)\n  pweqd(⋃ hs0, ⋃ c0, hs0 = c0)\n  unieq(hs0, c0)\n  elex(c0, c1)\n  pwexd(⋃ c0, universe, c0 ∈ c1)\n  uniexg(c0, c1)\n  diff.hs0.c(c0)\n  diff.hs0.c(P(⋃ c0))\n  diff.hs0.c(universe)\n}","parent":["fvmptd3","df-undef","pweqd","unieq","elex","pwexd","uniexg","diff.hs0.c"],"children":["undefnel2","undefne0","ndfatafv2undef"]},{"name":"undefnel2","content":"The undefined value generated from a set is not a member of the set. (Contributed by NM, 15-Sep-2011.)","origin":"thm undefnel2(class c0, class c1) {\n  |- wi(wcel(c0, c1), wn(wcel(cfv(cund, c0), c0)))\n} = {\n  mtbiri(wcel(c0, c1), wcel(cfv(cund, c0), c0), wcel(cpw(cuni(c0)), c0))\n  pwuninel(c0)\n  eleq1d(cfv(cund, c0), c0, cpw(cuni(c0)), wcel(c0, c1))\n  undefval(c0, c1)\n}","pretty":"thm undefnel2(class c0, class c1) {\n  ⊢ (c0 ∈ c1 → ¬(Undef ` c0)∈ c0)\n} = {\n  mtbiri(c0 ∈ c1, (Undef ` c0)∈ c0, P(⋃ c0)∈ c0)\n  pwuninel(c0)\n  eleq1d((Undef ` c0), c0, P(⋃ c0), c0 ∈ c1)\n  undefval(c0, c1)\n}","parent":["mtbiri","pwuninel","eleq1d","undefval"],"children":["undefnel","riotaclbgBAD"]},{"name":"undefnel","content":"The undefined value generated from a set is not a member of the set. (Contributed by NM, 15-Sep-2011.)","origin":"thm undefnel(class c0, class c1) {\n  |- wi(wcel(c0, c1), wnel(cfv(cund, c0), c0))\n} = {\n  sylibr(wcel(c0, c1), wnel(cfv(cund, c0), c0), wn(wcel(cfv(cund, c0), c0)))\n  undefnel2(c0, c1)\n  df-nel(cfv(cund, c0), c0)\n}","pretty":"thm undefnel(class c0, class c1) {\n  ⊢ (c0 ∈ c1 →(Undef ` c0)∉ c0)\n} = {\n  sylibr(c0 ∈ c1, (Undef ` c0)∉ c0, ¬(Undef ` c0)∈ c0)\n  undefnel2(c0, c1)\n  df-nel((Undef ` c0), c0)\n}","parent":["sylibr","undefnel2","df-nel"],"children":[]},{"name":"undefne0","content":"The undefined value generated from a set is not empty. (Contributed by NM, 3-Sep-2018.)","origin":"thm undefne0(class c0, class c1) {\n  |- wi(wcel(c0, c1), wne(cfv(cund, c0), emptycls))\n} = {\n  eqnetrd(cfv(cund, c0), emptycls, cpw(cuni(c0)), wcel(c0, c1))\n  undefval(c0, c1)\n  a1i(wcel(c0, c1), wne(cpw(cuni(c0)), emptycls))\n  pwne0(cuni(c0))\n}","pretty":"thm undefne0(class c0, class c1) {\n  ⊢ (c0 ∈ c1 →(Undef ` c0)≠ ∅)\n} = {\n  eqnetrd((Undef ` c0), emptycls, P(⋃ c0), c0 ∈ c1)\n  undefval(c0, c1)\n  a1i(c0 ∈ c1, P(⋃ c0)≠ ∅)\n  pwne0(⋃ c0)\n}","parent":["eqnetrd","undefval","a1i","pwne0"],"children":[]}]}