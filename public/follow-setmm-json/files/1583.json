{"index":1583,"title":"Allsome quantifier","content":"These are definitions and proofs involving an experimental \"allsome\" quantifier (aka \"all some\"). In informal language, statements like \"All Martians are green\" imply that there is at least one Martian. But it's easy to mistranslate informal language into formal notations because similar statements like ` A. x ph -> ps ` do _not_ imply that ` ph ` is ever true, leading to vacuous truths. See ~ alimp-surprise and ~ empty-surprise as examples of the problem. Some systems include a mechanism to counter this, e.g., PVS allows types to be appended with \"+\" to declare that they are nonempty. This section presents a different solution to the same problem. The \"allsome\" quantifier expressly includes the notion of both \"all\" and \"there exists at least one\" (aka some), and is defined to make it easier to more directly express both notions. The hope is that if a quantifier more directly expresses this concept, it will be used instead and reduce the risk of creating formal expressions that look okay but in fact are mistranslations. The term \"allsome\" was chosen because it's short, easy to say, and clearly hints at the two concepts it combines. I do not expect this to be used much in Metamath, because in Metamath there's a general policy of avoiding the use of new definitions unless there are very strong reasons to do so. Instead, my goal is to rigorously define this quantifier and demonstrate a few basic properties of it. The syntax allows two forms that look like they would be problematic, but they are fine. When applied to a top-level implication we allow ` A! x ( ph -> ps ) ` , and when restricted (applied to a class) we allow ` A! x e. A ph ` . The first symbol after the setvar variable must always be ` e. ` if it is the form applied to a class, and since ` e. ` cannot begin a wff, it is unambiguous. The ` -> ` looks like it would be a problem because ` ph ` or ` ps ` might include implications, but any implication arrow ` -> ` within any wff must be surrounded by parentheses, so only the implication arrow of ` A! ` can follow the wff. The implication syntax would work fine without the parentheses, but I added the parentheses because it makes things clearer inside larger complex expressions, and it's also more consistent with the rest of the syntax. For more, see \"The Allsome Quantifier\" by David A. Wheeler at ~ https://dwheeler.com/essays/allsome.html I hope that others will eventually agree that allsome is awesome.","blocks":[{"name":"walsi","content":"Extend wff definition to include \"all some\" applied to a top-level implication, which means ` ps ` is true whenever ` ph ` is true, and there is at least least one ` x ` where ` ph ` is true. (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"prop wff walsi(setvar s0, wff w0, wff w1) { ∀!(s0, w0 → w1) }","pretty":"","parent":[],"children":[]},{"name":"diff.walsi.s","content":"","origin":"axiom diff.walsi.s(setvar sBase, setvar s0, wff w0, wff w1) {\n  |- diffsw(sBase, walsi(s0, w0, w1))\n  -| diffss(sBase, s0)\n  -| diffsw(sBase, w0)\n  -| diffsw(sBase, w1)\n}","pretty":"axiom diff.walsi.s(setvar sBase, setvar s0, wff w0, wff w1) {\n  ⊢ d(sBase, ∀!(s0, w0 → w1))\n  ⊣ d(sBase, s0)\n  ⊣ d(sBase, w0)\n  ⊣ d(sBase, w1)\n}","parent":[],"children":[]},{"name":"diff.walsi.c","content":"","origin":"axiom diff.walsi.c(class cBase, setvar s0, wff w0, wff w1) {\n  |- diffcw(cBase, walsi(s0, w0, w1))\n  -| diffsc(s0, cBase)\n  -| diffcw(cBase, w0)\n  -| diffcw(cBase, w1)\n}","pretty":"axiom diff.walsi.c(class cBase, setvar s0, wff w0, wff w1) {\n  ⊢ d(cBase, ∀!(s0, w0 → w1))\n  ⊣ d(s0, cBase)\n  ⊣ d(cBase, w0)\n  ⊣ d(cBase, w1)\n}","parent":[],"children":[]},{"name":"diff.walsi.w","content":"","origin":"axiom diff.walsi.w(wff wBase, setvar s0, wff w0, wff w1) {\n  |- diffww(wBase, walsi(s0, w0, w1))\n  -| diffsw(s0, wBase)\n  -| diffww(wBase, w0)\n  -| diffww(wBase, w1)\n}","pretty":"axiom diff.walsi.w(wff wBase, setvar s0, wff w0, wff w1) {\n  ⊢ d(wBase, ∀!(s0, w0 → w1))\n  ⊣ d(s0, wBase)\n  ⊣ d(wBase, w0)\n  ⊣ d(wBase, w1)\n}","parent":[],"children":[]},{"name":"walsc","content":"Extend wff definition to include \"all some\" applied to a class, which means ` ph ` is true for all ` x ` in ` A ` , and there is at least one ` x ` in ` A ` . (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"prop wff walsc(setvar s0, class c0, wff w0) { ∀!(s0 ∈ c0, w0) }","pretty":"","parent":[],"children":[]},{"name":"diff.walsc.s","content":"","origin":"axiom diff.walsc.s(setvar sBase, setvar s0, class c0, wff w0) {\n  |- diffsw(sBase, walsc(s0, c0, w0))\n  -| diffss(sBase, s0)\n  -| diffsc(sBase, c0)\n  -| diffsw(sBase, w0)\n}","pretty":"axiom diff.walsc.s(setvar sBase, setvar s0, class c0, wff w0) {\n  ⊢ d(sBase, ∀!(s0 ∈ c0, w0))\n  ⊣ d(sBase, s0)\n  ⊣ d(sBase, c0)\n  ⊣ d(sBase, w0)\n}","parent":[],"children":[]},{"name":"diff.walsc.c","content":"","origin":"axiom diff.walsc.c(class cBase, setvar s0, class c0, wff w0) {\n  |- diffcw(cBase, walsc(s0, c0, w0))\n  -| diffsc(s0, cBase)\n  -| diffcc(cBase, c0)\n  -| diffcw(cBase, w0)\n}","pretty":"axiom diff.walsc.c(class cBase, setvar s0, class c0, wff w0) {\n  ⊢ d(cBase, ∀!(s0 ∈ c0, w0))\n  ⊣ d(s0, cBase)\n  ⊣ d(cBase, c0)\n  ⊣ d(cBase, w0)\n}","parent":[],"children":[]},{"name":"diff.walsc.w","content":"","origin":"axiom diff.walsc.w(wff wBase, setvar s0, class c0, wff w0) {\n  |- diffww(wBase, walsc(s0, c0, w0))\n  -| diffsw(s0, wBase)\n  -| diffcw(c0, wBase)\n  -| diffww(wBase, w0)\n}","pretty":"axiom diff.walsc.w(wff wBase, setvar s0, class c0, wff w0) {\n  ⊢ d(wBase, ∀!(s0 ∈ c0, w0))\n  ⊣ d(s0, wBase)\n  ⊣ d(c0, wBase)\n  ⊣ d(wBase, w0)\n}","parent":[],"children":[]},{"name":"df-alsi","content":"Define \"all some\" applied to a top-level implication, which means ` ps ` is true whenever ` ph ` is true and there is at least one ` x ` where ` ph ` is true. (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"axiom df-alsi(setvar s0, wff w0, wff w1) {\n  |- wb(walsi(s0, w0, w1), wa(wal(s0, wi(w0, w1)), wex(s0, w0)))\n}","pretty":"axiom df-alsi(setvar s0, wff w0, wff w1) {\n  ⊢ (∀!(s0, w0 → w1)↔(∀(s0,(w0 → w1))∧ ∃(s0, w0)))\n}","parent":[],"children":["alsconv","alsi1d","alsi2d","alsi-no-surprise"]},{"name":"df-alsc","content":"Define \"all some\" applied to a class, which means ` ph ` is true for all ` x ` in ` A ` and there is at least one ` x ` in ` A ` . (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"axiom df-alsc(setvar s0, class c0, wff w0) {\n  |- wb(walsc(s0, c0, w0), wa(wral(s0, c0, w0), wex(s0, wcel(cv(s0), c0))))\n}","pretty":"axiom df-alsc(setvar s0, class c0, wff w0) {\n  ⊢ (∀!(s0 ∈ c0, w0)↔(∀(s0 ∈ c0, w0)∧ ∃(s0, s0 ∈ c0)))\n}","parent":[],"children":["alsconv","alsc1d","alsc2d"]},{"name":"alsconv","content":"There is an equivalence between the two \"all some\" forms. (Contributed by David A. Wheeler, 22-Oct-2018.)","origin":"thm alsconv(setvar s0, class c0, wff w0) {\n  |- wb(walsi(s0, wcel(cv(s0), c0), w0), walsc(s0, c0, w0))\n} = {\n  3bitr4ri(walsi(s0, wcel(cv(s0), c0), w0), walsc(s0, c0, w0), wa(wral(s0, c0, w0), wex(s0, wcel(cv(s0), c0))), wa(wal(s0, wi(wcel(cv(s0), c0), w0)), wex(s0, wcel(cv(s0), c0))))\n  anbi1i(wral(s0, c0, w0), wex(s0, wcel(cv(s0), c0)), wal(s0, wi(wcel(cv(s0), c0), w0)))\n  df-ral(s0, c0, w0)\n  df-alsc(s0, c0, w0)\n  df-alsi(s0, wcel(cv(s0), c0), w0)\n}","pretty":"thm alsconv(setvar s0, class c0, wff w0) {\n  ⊢ (∀!(s0, s0 ∈ c0 → w0)↔ ∀!(s0 ∈ c0, w0))\n} = {\n  3bitr4ri(∀!(s0, s0 ∈ c0 → w0), ∀!(s0 ∈ c0, w0), (∀(s0 ∈ c0, w0)∧ ∃(s0, s0 ∈ c0)), (∀(s0,(s0 ∈ c0 → w0))∧ ∃(s0, s0 ∈ c0)))\n  anbi1i(∀(s0 ∈ c0, w0), ∃(s0, s0 ∈ c0), ∀(s0,(s0 ∈ c0 → w0)))\n  df-ral(s0, c0, w0)\n  df-alsc(s0, c0, w0)\n  df-alsi(s0, s0 ∈ c0, w0)\n}","parent":["3bitr4ri","anbi1i","df-ral","df-alsc","df-alsi"],"children":[]},{"name":"alsi1d","content":"Deduction rule: Given \"all some\" applied to a top-level inference, you can extract the \"for all\" part. (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"thm alsi1d(setvar s0, wff w0, wff w1, wff w2) {\n  |- wi(w0, wal(s0, wi(w1, w2)))\n  -| wi(w0, walsi(s0, w1, w2))\n} = {\n  simpld(w0, wal(s0, wi(w1, w2)), wex(s0, w1))\n  sylib(w0, wa(wal(s0, wi(w1, w2)), wex(s0, w1)), walsi(s0, w1, w2))\n  df-alsi(s0, w1, w2)\n}","pretty":"thm alsi1d(setvar s0, wff w0, wff w1, wff w2) {\n  ⊢ (w0 → ∀(s0,(w1 → w2)))\n  ⊣ (w0 → ∀!(s0, w1 → w2))\n} = {\n  simpld(w0, ∀(s0,(w1 → w2)), ∃(s0, w1))\n  sylib(w0, (∀(s0,(w1 → w2))∧ ∃(s0, w1)), ∀!(s0, w1 → w2))\n  df-alsi(s0, w1, w2)\n}","parent":["simpld","sylib","df-alsi"],"children":[]},{"name":"alsi2d","content":"Deduction rule: Given \"all some\" applied to a top-level inference, you can extract the \"exists\" part. (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"thm alsi2d(setvar s0, wff w0, wff w1, wff w2) {\n  |- wi(w0, wex(s0, w1))\n  -| wi(w0, walsi(s0, w1, w2))\n} = {\n  simprd(w0, wex(s0, w1), wal(s0, wi(w1, w2)))\n  sylib(w0, wa(wal(s0, wi(w1, w2)), wex(s0, w1)), walsi(s0, w1, w2))\n  df-alsi(s0, w1, w2)\n}","pretty":"thm alsi2d(setvar s0, wff w0, wff w1, wff w2) {\n  ⊢ (w0 → ∃(s0, w1))\n  ⊣ (w0 → ∀!(s0, w1 → w2))\n} = {\n  simprd(w0, ∃(s0, w1), ∀(s0,(w1 → w2)))\n  sylib(w0, (∀(s0,(w1 → w2))∧ ∃(s0, w1)), ∀!(s0, w1 → w2))\n  df-alsi(s0, w1, w2)\n}","parent":["simprd","sylib","df-alsi"],"children":[]},{"name":"alsc1d","content":"Deduction rule: Given \"all some\" applied to a class, you can extract the \"for all\" part. (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"thm alsc1d(setvar s0, class c0, wff w0, wff w1) {\n  |- wi(w0, wral(s0, c0, w1))\n  -| wi(w0, walsc(s0, c0, w1))\n} = {\n  simpld(w0, wral(s0, c0, w1), wex(s0, wcel(cv(s0), c0)))\n  sylib(w0, wa(wral(s0, c0, w1), wex(s0, wcel(cv(s0), c0))), walsc(s0, c0, w1))\n  df-alsc(s0, c0, w1)\n}","pretty":"thm alsc1d(setvar s0, class c0, wff w0, wff w1) {\n  ⊢ (w0 → ∀(s0 ∈ c0, w1))\n  ⊣ (w0 → ∀!(s0 ∈ c0, w1))\n} = {\n  simpld(w0, ∀(s0 ∈ c0, w1), ∃(s0, s0 ∈ c0))\n  sylib(w0, (∀(s0 ∈ c0, w1)∧ ∃(s0, s0 ∈ c0)), ∀!(s0 ∈ c0, w1))\n  df-alsc(s0, c0, w1)\n}","parent":["simpld","sylib","df-alsc"],"children":[]},{"name":"alsc2d","content":"Deduction rule: Given \"all some\" applied to a class, you can extract the \"there exists\" part. (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"thm alsc2d(setvar s0, class c0, wff w0, wff w1) {\n  |- wi(w0, wex(s0, wcel(cv(s0), c0)))\n  -| wi(w0, walsc(s0, c0, w1))\n} = {\n  simprd(w0, wex(s0, wcel(cv(s0), c0)), wral(s0, c0, w1))\n  sylib(w0, wa(wral(s0, c0, w1), wex(s0, wcel(cv(s0), c0))), walsc(s0, c0, w1))\n  df-alsc(s0, c0, w1)\n}","pretty":"thm alsc2d(setvar s0, class c0, wff w0, wff w1) {\n  ⊢ (w0 → ∃(s0, s0 ∈ c0))\n  ⊣ (w0 → ∀!(s0 ∈ c0, w1))\n} = {\n  simprd(w0, ∃(s0, s0 ∈ c0), ∀(s0 ∈ c0, w1))\n  sylib(w0, (∀(s0 ∈ c0, w1)∧ ∃(s0, s0 ∈ c0)), ∀!(s0 ∈ c0, w1))\n  df-alsc(s0, c0, w1)\n}","parent":["simprd","sylib","df-alsc"],"children":["alscn0d"]},{"name":"alscn0d","content":"Deduction rule: Given \"all some\" applied to a class, the class is not the empty set. (Contributed by David A. Wheeler, 23-Oct-2018.)","origin":"thm alscn0d(setvar s0, class c0, wff w0, wff w1) {\n  |- wi(w0, wne(c0, emptycls))\n  -| wi(w0, walsc(s0, c0, w1))\n  -| diffsc(s0, c0)\n} = {\n  sylibr(w0, wne(c0, emptycls), wex(s0, wcel(cv(s0), c0)))\n  alsc2d(s0, c0, w0, w1)\n  n0(s0, c0)\n}","pretty":"thm alscn0d(setvar s0, class c0, wff w0, wff w1) {\n  ⊢ (w0 → c0 ≠ ∅)\n  ⊣ (w0 → ∀!(s0 ∈ c0, w1))\n  ⊣ d(s0, c0)\n} = {\n  sylibr(w0, c0 ≠ ∅, ∃(s0, s0 ∈ c0))\n  alsc2d(s0, c0, w0, w1)\n  n0(s0, c0)\n}","parent":["sylibr","alsc2d","n0"],"children":[]},{"name":"alsi-no-surprise","content":"Demonstrate that there is never a \"surprise\" when using the allsome quantifier, that is, it is never possible for the consequent to be both always true and always false. This uses the definition of ~ df-alsi ; the proof itself builds on ~ alimp-no-surprise . For a contrast, see ~ alimp-surprise . (Contributed by David A. Wheeler, 27-Oct-2018.)","origin":"thm alsi-no-surprise(setvar s0, wff w0, wff w1) {\n  |- wn(wa(walsi(s0, w0, w1), walsi(s0, w0, wn(w1))))\n} = {\n  mtbir(wa(walsi(s0, w0, w1), walsi(s0, w0, wn(w1))), w3a(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))), wex(s0, w0)))\n  alimp-no-surprise(s0, w0, w1)\n  3bitr2i(wa(walsi(s0, w0, w1), walsi(s0, w0, wn(w1))), w3a(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))), wex(s0, w0)), wa(wa(wal(s0, wi(w0, w1)), wex(s0, w0)), wa(wal(s0, wi(w0, wn(w1))), wex(s0, w0))), w3a(wal(s0, wi(w0, w1)), wex(s0, w0), wal(s0, wi(w0, wn(w1)))))\n  anbi12i(walsi(s0, w0, w1), walsi(s0, w0, wn(w1)), wa(wal(s0, wi(w0, w1)), wex(s0, w0)), wa(wal(s0, wi(w0, wn(w1))), wex(s0, w0)))\n  df-alsi(s0, w0, w1)\n  df-alsi(s0, w0, wn(w1))\n  anandi3r(wal(s0, wi(w0, w1)), wex(s0, w0), wal(s0, wi(w0, wn(w1))))\n  3ancomb(wal(s0, wi(w0, w1)), wex(s0, w0), wal(s0, wi(w0, wn(w1))))\n}","pretty":"thm alsi-no-surprise(setvar s0, wff w0, wff w1) {\n  ⊢ ¬(∀!(s0, w0 → w1)∧ ∀!(s0, w0 → ¬ w1))\n} = {\n  mtbir((∀!(s0, w0 → w1)∧ ∀!(s0, w0 → ¬ w1)), (∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1))∧ ∃(s0, w0)))\n  alimp-no-surprise(s0, w0, w1)\n  3bitr2i((∀!(s0, w0 → w1)∧ ∀!(s0, w0 → ¬ w1)), (∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1))∧ ∃(s0, w0)), ((∀(s0,(w0 → w1))∧ ∃(s0, w0))∧(∀(s0,(w0 → ¬ w1))∧ ∃(s0, w0))), (∀(s0,(w0 → w1))∧ ∃(s0, w0)∧ ∀(s0,(w0 → ¬ w1))))\n  anbi12i(∀!(s0, w0 → w1), ∀!(s0, w0 → ¬ w1), (∀(s0,(w0 → w1))∧ ∃(s0, w0)), (∀(s0,(w0 → ¬ w1))∧ ∃(s0, w0)))\n  df-alsi(s0, w0, w1)\n  df-alsi(s0, w0, ¬ w1)\n  anandi3r(∀(s0,(w0 → w1)), ∃(s0, w0), ∀(s0,(w0 → ¬ w1)))\n  3ancomb(∀(s0,(w0 → w1)), ∃(s0, w0), ∀(s0,(w0 → ¬ w1)))\n}","parent":["mtbir","alimp-no-surprise","3bitr2i","anbi12i","df-alsi","anandi3r","3ancomb"],"children":[]}]}