{"index":114,"title":"Derive the Null Set Axiom","content":"","blocks":[{"name":"zfnuleuOLD","content":"Obsolete version of ~ nulmo as of 17-Sep-2022. (Contributed by NM, 22-Dec-2007.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm zfnuleuOLD(setvar s0, setvar s1) {\n  |- weu(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  -| wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  -| diffss(s0, s1)\n} = {\n  mpbir(weu(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), weu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))))\n  ax-mp(weu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))), wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))))\n  mpbi(wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))), wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))))\n  exbii(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))), wal(s1, wb(wcel(cv(s1), cv(s0)), wfal)))\n  mpbi(wi(wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))), weu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal)))), wmo(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))))\n  axextmo(s0, s1, wfal)\n  nfv(s0, wfal)\n  moeu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal)))\n  eubii(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))), wal(s1, wb(wcel(cv(s1), cv(s0)), wfal)))\n  albii(s1, wn(wcel(cv(s1), cv(s0))), wb(wcel(cv(s1), cv(s0)), wfal))\n  nbfal(wcel(cv(s1), cv(s0)))\n  diff.wfal.s(s0)\n}","pretty":"thm zfnuleuOLD(setvar s0, setvar s1) {\n  ⊢ ∃!(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ ∃(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  mpbir(∃!(s0, ∀(s1, ¬ s1 ∈ s0)), ∃!(s0, ∀(s1,(s1 ∈ s0 ↔ F))))\n  ax-mp(∃!(s0, ∀(s1,(s1 ∈ s0 ↔ F))), ∃(s0, ∀(s1,(s1 ∈ s0 ↔ F))))\n  mpbi(∃(s0, ∀(s1,(s1 ∈ s0 ↔ F))), ∃(s0, ∀(s1, ¬ s1 ∈ s0)))\n  exbii(s0, ∀(s1, ¬ s1 ∈ s0), ∀(s1,(s1 ∈ s0 ↔ F)))\n  mpbi((∃(s0, ∀(s1,(s1 ∈ s0 ↔ F)))→ ∃!(s0, ∀(s1,(s1 ∈ s0 ↔ F)))), ∃*(s0, ∀(s1,(s1 ∈ s0 ↔ F))))\n  axextmo(s0, s1, wfal)\n  nfv(s0, wfal)\n  moeu(s0, ∀(s1,(s1 ∈ s0 ↔ F)))\n  eubii(s0, ∀(s1, ¬ s1 ∈ s0), ∀(s1,(s1 ∈ s0 ↔ F)))\n  albii(s1, ¬ s1 ∈ s0, (s1 ∈ s0 ↔ F))\n  nbfal(s1 ∈ s0)\n  diff.wfal.s(s0)\n}","parent":["mpbir","ax-mp","mpbi","exbii","axextmo","nfv","moeu","eubii","albii","nbfal","diff.wfal.s"],"children":[]},{"name":"axnulALT","content":"Alternate proof of ~ axnul , proved from propositional calculus, ~ ax-gen , ~ ax-4 , ~ sp , and ~ ax-rep . To check this, replace ~ sp with the obsolete axiom ~ ax-c5 in the proof of ~ axnulALT and type the Metamath program \"MM> SHOW TRACE_BACK axnulALT / AXIOMS\" command. (Contributed by Jeff Hoffman, 3-Feb-2008.) (Proof shortened by Mario Carneiro, 17-Nov-2016.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm axnulALT(setvar s0, setvar s1) {\n  |- wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  -| diffss(s0, s1)\n} = {\n  mpbir(wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wex(hs0, wa(wcel(cv(hs0), cv(hs1)), wal(s0, wfal)))))))\n  mpg(hs0, wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wex(hs0, wa(wcel(cv(hs0), cv(hs1)), wal(s0, wfal)))))), wex(s0, wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0))))))\n  ax-rep(hs0, s0, s1, hs1, wfal)\n  mpg(s1, wex(s0, wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0))))), wi(wal(s0, wfal), wceq(cv(s1), cv(s0))))\n  sylibr(wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0)))), wex(s0, wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0))))), wn(wal(s0, wn(wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0))))))))\n  con2i(wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0)))), wal(s0, wn(wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0)))))))\n  sp(s0, wn(wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0))))))\n  df-ex(s0, wal(s1, wi(wal(s0, wfal), wceq(cv(s1), cv(s0)))))\n  pm2.21i(wal(s0, wfal), wceq(cv(s1), cv(s0)))\n  exbii(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))), wal(s1, wb(wcel(cv(s1), cv(s0)), wex(hs0, wa(wcel(cv(hs0), cv(hs1)), wal(s0, wfal))))))\n  albii(s1, wn(wcel(cv(s1), cv(s0))), wb(wcel(cv(s1), cv(s0)), wex(hs0, wa(wcel(cv(hs0), cv(hs1)), wal(s0, wfal)))))\n  nbn(wcel(cv(s1), cv(s0)), wex(hs0, wa(wcel(cv(hs0), cv(hs1)), wal(s0, wfal))))\n  nex(hs0, wa(wcel(cv(hs0), cv(hs1)), wal(s0, wfal)))\n  intnan(wcel(cv(hs0), cv(hs1)), wal(s0, wfal))\n  mto(wal(s0, wfal), wfal)\n  fal()\n  sp(s0, wfal)\n  diff.hs0.s(hs1)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs1)\n  diff.hs1.s(s0)\n  diffss.ex(s1, hs1)\n  diff.hs1.s(s1)\n}","pretty":"thm axnulALT(setvar s0, setvar s1) {\n  ⊢ ∃(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  mpbir(∃(s0, ∀(s1, ¬ s1 ∈ s0)), ∃(s0, ∀(s1,(s1 ∈ s0 ↔ ∃(hs0,(hs0 ∈ hs1 ∧ ∀(s0, F)))))))\n  mpg(hs0, ∃(s0, ∀(s1,(s1 ∈ s0 ↔ ∃(hs0,(hs0 ∈ hs1 ∧ ∀(s0, F)))))), ∃(s0, ∀(s1,(∀(s0, F)→ s1 = s0))))\n  ax-rep(hs0, s0, s1, hs1, wfal)\n  mpg(s1, ∃(s0, ∀(s1,(∀(s0, F)→ s1 = s0))), (∀(s0, F)→ s1 = s0))\n  sylibr(∀(s1,(∀(s0, F)→ s1 = s0)), ∃(s0, ∀(s1,(∀(s0, F)→ s1 = s0))), ¬ ∀(s0, ¬ ∀(s1,(∀(s0, F)→ s1 = s0))))\n  con2i(∀(s1,(∀(s0, F)→ s1 = s0)), ∀(s0, ¬ ∀(s1,(∀(s0, F)→ s1 = s0))))\n  sp(s0, ¬ ∀(s1,(∀(s0, F)→ s1 = s0)))\n  df-ex(s0, ∀(s1,(∀(s0, F)→ s1 = s0)))\n  pm2.21i(∀(s0, F), s1 = s0)\n  exbii(s0, ∀(s1, ¬ s1 ∈ s0), ∀(s1,(s1 ∈ s0 ↔ ∃(hs0,(hs0 ∈ hs1 ∧ ∀(s0, F))))))\n  albii(s1, ¬ s1 ∈ s0, (s1 ∈ s0 ↔ ∃(hs0,(hs0 ∈ hs1 ∧ ∀(s0, F)))))\n  nbn(s1 ∈ s0, ∃(hs0,(hs0 ∈ hs1 ∧ ∀(s0, F))))\n  nex(hs0, (hs0 ∈ hs1 ∧ ∀(s0, F)))\n  intnan(hs0 ∈ hs1, ∀(s0, F))\n  mto(∀(s0, F), wfal)\n  fal()\n  sp(s0, wfal)\n  diff.hs0.s(hs1)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs1)\n  diff.hs1.s(s0)\n  diffss.ex(s1, hs1)\n  diff.hs1.s(s1)\n}","parent":["mpbir","mpg","ax-rep","sylibr","con2i","sp","df-ex","pm2.21i","exbii","albii","nbn","nex","intnan","mto","fal","diff.hs0.s","diffss.ex","diff.hs1.s"],"children":[]},{"name":"axnul","content":"The Null Set Axiom of ZF set theory: there exists a set with no elements. Axiom of Empty Set of [Enderton] p. 18. In some textbooks, this is presented as a separate axiom; here we show it can be derived from Separation ~ ax-sep . This version of the Null Set Axiom tells us that at least one empty set exists, but does not tell us that it is unique - we need the Axiom of Extensionality to do that (see ~ nulmo ). This proof, suggested by Jeff Hoffman, uses only ~ ax-4 and ~ ax-gen from predicate calculus, which are valid in \"free logic\" i.e. logic holding in an empty domain (see Axiom A5 and Rule R2 of [LeBlanc] p. 277). Thus, our ~ ax-sep implies the existence of at least one set. Note that Kunen's version of ~ ax-sep (Axiom 3 of [Kunen] p. 11) does not imply the existence of a set because his is universally closed, i.e., prefixed with universal quantifiers to eliminate all free variables. His existence is provided by a separate axiom stating ` E. x x = x ` (Axiom 0 of [Kunen] p. 10). See ~ axnulALT for a proof directly from ~ ax-rep . This theorem should not be referenced by any proof. Instead, use ~ ax-nul below so that the uses of the Null Set Axiom can be more easily identified. (Contributed by Jeff Hoffman, 3-Feb-2008.) (Revised by NM, 4-Feb-2008.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm axnul(setvar s0, setvar s1) {\n  |- wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  -| diffss(s0, s1)\n} = {\n  eximii(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))), wal(s1, wb(wcel(cv(s1), cv(s0)), wa(wcel(cv(s1), cv(hs0)), wfal))))\n  ax-sep(s0, s1, hs0, wfal)\n  alimi(s1, wb(wcel(cv(s1), cv(s0)), wa(wcel(cv(s1), cv(hs0)), wfal)), wn(wcel(cv(s1), cv(s0))))\n  mtbiri(wb(wcel(cv(s1), cv(s0)), wa(wcel(cv(s1), cv(hs0)), wfal)), wcel(cv(s1), cv(s0)), wa(wcel(cv(s1), cv(hs0)), wfal))\n  intnan(wcel(cv(s1), cv(hs0)), wfal)\n  fal()\n  id(wb(wcel(cv(s1), cv(s0)), wa(wcel(cv(s1), cv(hs0)), wfal)))\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wfal.s(s0)\n  diff.hs0.w(wfal)\n}","pretty":"thm axnul(setvar s0, setvar s1) {\n  ⊢ ∃(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  eximii(s0, ∀(s1, ¬ s1 ∈ s0), ∀(s1,(s1 ∈ s0 ↔(s1 ∈ hs0 ∧ F))))\n  ax-sep(s0, s1, hs0, wfal)\n  alimi(s1, (s1 ∈ s0 ↔(s1 ∈ hs0 ∧ F)), ¬ s1 ∈ s0)\n  mtbiri((s1 ∈ s0 ↔(s1 ∈ hs0 ∧ F)), s1 ∈ s0, (s1 ∈ hs0 ∧ F))\n  intnan(s1 ∈ hs0, wfal)\n  fal()\n  id((s1 ∈ s0 ↔(s1 ∈ hs0 ∧ F)))\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wfal.s(s0)\n  diff.hs0.w(wfal)\n}","parent":["eximii","ax-sep","alimi","mtbiri","intnan","fal","id","diffss.ex","diff.hs0.s","diff.wfal.s","diff.hs0.w"],"children":[]},{"name":"ax-nul","content":"The Null Set Axiom of ZF set theory. It was derived as ~ axnul above and is therefore redundant, but we state it as a separate axiom here so that its uses can be identified more easily. (Contributed by NM, 7-Aug-2003.)","origin":"axiom ax-nul(setvar s0, setvar s1) {\n  |- wex(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  -| diffss(s0, s1)\n}","pretty":"axiom ax-nul(setvar s0, setvar s1) {\n  ⊢ ∃(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n}","parent":[],"children":["0ex","dtru","axprlem1","axprlem4","axprlem5","bj-dtru"]},{"name":"0ex","content":"The Null Set Axiom of ZF set theory: the empty set exists. Corollary 5.16 of [TakeutiZaring] p. 20. For the unabbreviated version, see ~ ax-nul . (Contributed by NM, 21-Jun-1993.) (Proof shortened by Andrew Salmon, 9-Jul-2011.)","origin":"thm 0ex() {\n  |- wcel(emptycls, universe)\n} = {\n  issetri(hs0, emptycls)\n  mpbir(wex(hs0, wceq(cv(hs0), emptycls)), wex(hs0, wal(hs1, wn(wcel(cv(hs1), cv(hs0))))))\n  ax-nul(hs0, hs1)\n  exbii(hs0, wceq(cv(hs0), emptycls), wal(hs1, wn(wcel(cv(hs1), cv(hs0)))))\n  eq0(hs1, cv(hs0))\n  diff.hs0.c(emptycls)\n  diff.hs0.s(hs1)\n  diff.hs1.c(cv(hs0))\n}","pretty":"thm 0ex() {\n  ⊢ ∅ ∈ 𝕌\n} = {\n  issetri(hs0, emptycls)\n  mpbir(∃(hs0, hs0 = ∅), ∃(hs0, ∀(hs1, ¬ hs1 ∈ hs0)))\n  ax-nul(hs0, hs1)\n  exbii(hs0, hs0 = ∅, ∀(hs1, ¬ hs1 ∈ hs0))\n  eq0(hs1, hs0)\n  diff.hs0.c(emptycls)\n  diff.hs0.s(hs1)\n  diff.hs1.c(hs0)\n}","parent":["issetri","mpbir","ax-nul","exbii","eq0","diff.hs0.c","diff.hs0.s","diff.hs1.c"],"children":["al0ssb","sseliALT","csbexg","unisn2","class2set","0elpw","0nep0","unidif0","iin0","notzfaus","intv","snexALT","p0ex","dtruALT","zfpair","snex","dtruALT2","opex","opthwiener","0sn0ep","opthprc","nrelv","dmsnsnsn","0elon","nsuceq0","snsn0non","iotaex","fun0","fvrn0","fvssunirn","fprg","ovima0","onint0","tfinds2","finds","finds2","xpexr","soex","supp0","fvn0elsupp","fvn0elsuppb","brtpos0","reldmtpos","tfrlem16","tz7.44-1","seqomlem1","1n0","el1o","om0","mapdm0","ixpexg","0elixp","en0","ensn1","en1","2dom","map1","xp1en","endisj","pw2eng","map2xp","limensuci","1sdom","unxpdom2","sucxpdom","isinf","ac6sfi","fodomfi","0fsupp","fi0","oiexg","brwdom","brwdom2","inf3lemb","infeq5i","dfom3","cantnfvalf","cantnfval2","cantnfle","cantnflt","cantnff","cantnf0","cantnfp1lem1","cantnfp1lem3","cantnfp1","cantnflem1a","cantnflem1d","cantnflem1","cantnf","cnfcomlem","cnfcom","cnfcom2lem","cnfcom3","tc0","r10","scottex","djulcl","djulf1o","djuss","djuun","1stinl","2ndinl","infxpenlem","fseqenlem1","uncdadom","cdaun","cdaen","cda1dif","pm110.643","cda0en","cdacomen","cdaassen","xpcdaen","mapcdaen","cdaxpdom","cdainf","infcda1","pwsdompw","pwcdadom","ackbij1lem14","ackbij2lem2","ackbij2lem3","cf0","cfeq0","cfsuc","cflim2","isfin5","isfin4-3","fin1a2lem11","fin1a2lem12","fin1a2lem13","axcc2lem","ac6num","zornn0g","ttukeylem3","brdom3","iundom2g","cardeq0","alephadd","pwcfsdom","axpowndlem3","canthwe","canthp1lem1","pwxpndom2","pwcdandom","gchxpidm","intwun","0tsk","grothomex","indpi","fzennn","hash0","hashen1","hashmap","hashbc","hashf1","hashge3el3dif","ccat1st1st","swrdval","swrd00","swrd0","cshfn","cshfnOLD","cshnz","cshnzOLD","0csh0","0csh0OLD","incexclem","incexc","rexpen","sadcf","sadc0","sadcp1","smupf","smup0","smupp1","0ram","ram0","cshws0","str0","ressbas","ress0","0rest","xpscg","xpscfn","xpsc0","xpsc1","xpsfrnel","xpsfrnel2","xpsle","ismred2","acsfn","0cat","ciclcl","cicrcl","cicer","setcepi","0pos","meet0","join0","mgm0b","gsum0","sgrp0b","ga0","psgn0fv0","pmtrsn","oppglsm","efgi0","vrgpf","vrgpinv","frgpuptinv","frgpup2","0frgp","frgpnabllem1","frgpnabllem2","dprd0","dmdprdpr","dprdpr","00lsp","fvcoe1","coe1f2","coe1sfi","coe1add","coe1mul2lem1","coe1mul2lem2","coe1mul2","ply1coe","evls1rhmlem","evl1sca","evl1var","pf1mpf","pf1ind","cnfldfunALT","frgpcyg","frlmiscvec","mat0dimscm","mat0dimcrng","mat0scmat","mavmul0","mavmul0g","mvmumamul1","mdet0pr","mdet0f1o","mdet0fv0","mdetunilem9","d0mat2pmat","chpmat0d","en1top","en2top","sn0topon","indistopon","indistps","indistps2","sn0cld","indiscld","neipeltop","rest0","restsn","cmpfi","refun0","txindislem","hmphindis","xpstopnlem1","xpstopnlem2","ptcmpfi","snfil","fbasfip","fgcl","filconn","fbasrn","cfinfil","csdfil","supfil","ufildr","fin1aufil","rnelfmlem","fclsval","tmdgsum","tsmsfbas","ust0","ustn0","0met","xpsdsval","minveclem3b","tdeglem2","deg1ldg","deg1leb","deg1val","ulm0","uhgr0","upgr0eop","upgr0eopALT","usgr0","usgr0eop","lfuhgr1v0e","griedg0prc","0grsubgr","cplgr0","0grrusgr","clwwlk0on0","0ewlk","0wlkon","0trlon","0pthon","0pthonv","0conngr","konigsberglem1","konigsberglem2","konigsberglem3","wlkl0","disjdifprg","disjun0","fpwrelmapffslem","f1ocnt","resvsca","locfinref","esumnul","esumrnmpt2","prsiga","ldsysgenld","ldgenpisyslem1","oms0","carsggect","eulerpartgbij","eulerpartlemmf","repr0","breprexp","bnj941","bnj97","bnj149","bnj150","bnj944","derang0","indispconn","rdgprc","dfrdg3","trpredpred","trpred0","nosgnn0","nodense","nolt02o","nulsslt","nulssgt","fullfunfnv","fullfunfv","rank0","ssoninhaus","onint1","bj-0nel1","bj-xpnzex","bj-eltag","bj-0eltag","bj-tagss","bj-pr1val","bj-nuliota","bj-nuliotaALT","bj-rest10","bj-rest10b","bj-rest0","finxpreclem1","finxpreclem2","finxp0","finxpreclem5","cnfin0","cnfinltrel","poimirlem28","heibor1lem","heiborlem6","reheibor","n0elqs","mzpcompact2lem","wopprc","pw2f1ocnv","pwslnmlem0","pwfi2f1o","relintabex","clsk1indlem0","clsk1indlem4","clsk1indlem1","fnchoice","eliuniincex","mapdm0OLD","limsup0","0cnv","liminf0","0cnf","dvnprodlem3","qndenserrnbl","prsal","intsal","sge00","sge0sn","nnfoctbdjlem","isomenndlem","hoiqssbl","ovnsubadd2lem","iota0def","aiota0def","afv0fv0","lincval0","lco0","linds0","bnd2d"]},{"name":"al0ssb","content":"The empty set is the unique class which is a subclass of any set. (Contributed by AV, 24-Aug-2022.)","origin":"thm al0ssb(setvar s0, class c0) {\n  |- wb(wal(s0, wss(c0, cv(s0))), wceq(c0, emptycls))\n  -| diffsc(s0, c0)\n} = {\n  impbii(wal(s0, wss(c0, cv(s0))), wceq(c0, emptycls))\n  spcv(s0, emptycls, wss(c0, cv(s0)), wceq(c0, emptycls))\n  0ex()\n  syl6bb(wceq(cv(s0), emptycls), wss(c0, cv(s0)), wceq(c0, emptycls), wss(c0, emptycls))\n  sseq2(cv(s0), emptycls, c0)\n  ss0b(c0)\n  mpbiri(wceq(c0, emptycls), wal(s0, wss(c0, cv(s0))), wal(s0, wss(emptycls, cv(s0))))\n  ax-gen(s0, wss(emptycls, cv(s0)))\n  0ss(cv(s0))\n  albidv(s0, wceq(c0, emptycls), wss(c0, cv(s0)), wss(emptycls, cv(s0)))\n  sseq1(c0, emptycls, cv(s0))\n  diff.wceq.s(s0, c0, emptycls)\n  diff.emptycls.s(s0)\n}","pretty":"thm al0ssb(setvar s0, class c0) {\n  ⊢ (∀(s0, c0 ⊆ s0)↔ c0 = ∅)\n  ⊣ d(s0, c0)\n} = {\n  impbii(∀(s0, c0 ⊆ s0), c0 = ∅)\n  spcv(s0, emptycls, c0 ⊆ s0, c0 = ∅)\n  0ex()\n  syl6bb(s0 = ∅, c0 ⊆ s0, c0 = ∅, c0 ⊆ ∅)\n  sseq2(s0, emptycls, c0)\n  ss0b(c0)\n  mpbiri(c0 = ∅, ∀(s0, c0 ⊆ s0), ∀(s0, ∅ ⊆ s0))\n  ax-gen(s0, ∅ ⊆ s0)\n  0ss(s0)\n  albidv(s0, c0 = ∅, c0 ⊆ s0, ∅ ⊆ s0)\n  sseq1(c0, emptycls, s0)\n  diff.wceq.s(s0, c0, emptycls)\n  diff.emptycls.s(s0)\n}","parent":["impbii","spcv","0ex","syl6bb","sseq2","ss0b","mpbiri","ax-gen","0ss","albidv","sseq1","diff.wceq.s","diff.emptycls.s"],"children":["iota0def","aiota0def"]},{"name":"sseliALT","content":"Alternate proof of ~ sseli illustrating the use of the weak deduction theorem to prove it from the inference ~ sselii . (Contributed by NM, 24-Aug-2018.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm sseliALT(class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wcel(c0, c2))\n  -| wss(c1, c2)\n} = {\n  dedth3v(c1, csn(emptycls), c2, csn(emptycls), c0, emptycls, wcel(c0, c1), wcel(c0, c2), wcel(c0, c2), wcel(c0, cif(c2, csn(emptycls), wcel(c0, c1))), wcel(cif(c0, emptycls, wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1))))\n  biidd(wceq(c1, cif(c1, csn(emptycls), wcel(c0, c1))), wcel(c0, c2))\n  eleq2(c2, cif(c2, csn(emptycls), wcel(c0, c1)), c0)\n  eleq1(c0, cif(c0, emptycls, wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1)))\n  sselii(cif(c0, emptycls, wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1)), cif(c1, csn(emptycls), wcel(c0, c1)))\n  keephyp3v(c1, csn(emptycls), c2, csn(emptycls), c0, emptycls, wss(cif(c1, csn(emptycls), wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1))), wcel(c0, c1), wss(c1, c2), wss(cif(c1, csn(emptycls), wcel(c0, c1)), c2), wss(cif(c1, csn(emptycls), wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1))), wss(csn(emptycls), csn(emptycls)), wss(cif(c1, csn(emptycls), wcel(c0, c1)), csn(emptycls)), wss(cif(c1, csn(emptycls), wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1))))\n  sseq1(c1, cif(c1, csn(emptycls), wcel(c0, c1)), c2)\n  sseq2(c2, cif(c2, csn(emptycls), wcel(c0, c1)), cif(c1, csn(emptycls), wcel(c0, c1)))\n  biidd(wceq(c0, cif(c0, emptycls, wcel(c0, c1))), wss(cif(c1, csn(emptycls), wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1))))\n  sseq1(csn(emptycls), cif(c1, csn(emptycls), wcel(c0, c1)), csn(emptycls))\n  sseq2(csn(emptycls), cif(c2, csn(emptycls), wcel(c0, c1)), cif(c1, csn(emptycls), wcel(c0, c1)))\n  biidd(wceq(emptycls, cif(c0, emptycls, wcel(c0, c1))), wss(cif(c1, csn(emptycls), wcel(c0, c1)), cif(c2, csn(emptycls), wcel(c0, c1))))\n  ssid(csn(emptycls))\n  elimhyp3v(c1, csn(emptycls), c2, csn(emptycls), c0, emptycls, wcel(cif(c0, emptycls, wcel(c0, c1)), cif(c1, csn(emptycls), wcel(c0, c1))), wcel(c0, c1), wcel(c0, cif(c1, csn(emptycls), wcel(c0, c1))), wcel(c0, cif(c1, csn(emptycls), wcel(c0, c1))), wcel(emptycls, csn(emptycls)), wcel(emptycls, cif(c1, csn(emptycls), wcel(c0, c1))), wcel(emptycls, cif(c1, csn(emptycls), wcel(c0, c1))))\n  eleq2(c1, cif(c1, csn(emptycls), wcel(c0, c1)), c0)\n  biidd(wceq(c2, cif(c2, csn(emptycls), wcel(c0, c1))), wcel(c0, cif(c1, csn(emptycls), wcel(c0, c1))))\n  eleq1(c0, cif(c0, emptycls, wcel(c0, c1)), cif(c1, csn(emptycls), wcel(c0, c1)))\n  eleq2(csn(emptycls), cif(c1, csn(emptycls), wcel(c0, c1)), emptycls)\n  biidd(wceq(csn(emptycls), cif(c2, csn(emptycls), wcel(c0, c1))), wcel(emptycls, cif(c1, csn(emptycls), wcel(c0, c1))))\n  eleq1(emptycls, cif(c0, emptycls, wcel(c0, c1)), cif(c1, csn(emptycls), wcel(c0, c1)))\n  snid(emptycls)\n  0ex()\n}","pretty":"thm sseliALT(class c0, class c1, class c2) {\n  ⊢ (c0 ∈ c1 → c0 ∈ c2)\n  ⊣ c1 ⊆ c2\n} = {\n  dedth3v(c1, { ∅ }, c2, { ∅ }, c0, emptycls, c0 ∈ c1, c0 ∈ c2, c0 ∈ c2, c0 ∈ if(c0 ∈ c1, c2, { ∅ }), if(c0 ∈ c1, c0, ∅)∈ if(c0 ∈ c1, c2, { ∅ }))\n  biidd(c1 = if(c0 ∈ c1, c1, { ∅ }), c0 ∈ c2)\n  eleq2(c2, if(c0 ∈ c1, c2, { ∅ }), c0)\n  eleq1(c0, if(c0 ∈ c1, c0, ∅), if(c0 ∈ c1, c2, { ∅ }))\n  sselii(if(c0 ∈ c1, c0, ∅), if(c0 ∈ c1, c2, { ∅ }), if(c0 ∈ c1, c1, { ∅ }))\n  keephyp3v(c1, { ∅ }, c2, { ∅ }, c0, emptycls, if(c0 ∈ c1, c1, { ∅ })⊆ if(c0 ∈ c1, c2, { ∅ }), c0 ∈ c1, c1 ⊆ c2, if(c0 ∈ c1, c1, { ∅ })⊆ c2, if(c0 ∈ c1, c1, { ∅ })⊆ if(c0 ∈ c1, c2, { ∅ }), { ∅ } ⊆ { ∅ }, if(c0 ∈ c1, c1, { ∅ })⊆ { ∅ }, if(c0 ∈ c1, c1, { ∅ })⊆ if(c0 ∈ c1, c2, { ∅ }))\n  sseq1(c1, if(c0 ∈ c1, c1, { ∅ }), c2)\n  sseq2(c2, if(c0 ∈ c1, c2, { ∅ }), if(c0 ∈ c1, c1, { ∅ }))\n  biidd(c0 = if(c0 ∈ c1, c0, ∅), if(c0 ∈ c1, c1, { ∅ })⊆ if(c0 ∈ c1, c2, { ∅ }))\n  sseq1({ ∅ }, if(c0 ∈ c1, c1, { ∅ }), { ∅ })\n  sseq2({ ∅ }, if(c0 ∈ c1, c2, { ∅ }), if(c0 ∈ c1, c1, { ∅ }))\n  biidd(∅ = if(c0 ∈ c1, c0, ∅), if(c0 ∈ c1, c1, { ∅ })⊆ if(c0 ∈ c1, c2, { ∅ }))\n  ssid({ ∅ })\n  elimhyp3v(c1, { ∅ }, c2, { ∅ }, c0, emptycls, if(c0 ∈ c1, c0, ∅)∈ if(c0 ∈ c1, c1, { ∅ }), c0 ∈ c1, c0 ∈ if(c0 ∈ c1, c1, { ∅ }), c0 ∈ if(c0 ∈ c1, c1, { ∅ }), ∅ ∈ { ∅ }, ∅ ∈ if(c0 ∈ c1, c1, { ∅ }), ∅ ∈ if(c0 ∈ c1, c1, { ∅ }))\n  eleq2(c1, if(c0 ∈ c1, c1, { ∅ }), c0)\n  biidd(c2 = if(c0 ∈ c1, c2, { ∅ }), c0 ∈ if(c0 ∈ c1, c1, { ∅ }))\n  eleq1(c0, if(c0 ∈ c1, c0, ∅), if(c0 ∈ c1, c1, { ∅ }))\n  eleq2({ ∅ }, if(c0 ∈ c1, c1, { ∅ }), emptycls)\n  biidd({ ∅ } = if(c0 ∈ c1, c2, { ∅ }), ∅ ∈ if(c0 ∈ c1, c1, { ∅ }))\n  eleq1(emptycls, if(c0 ∈ c1, c0, ∅), if(c0 ∈ c1, c1, { ∅ }))\n  snid(emptycls)\n  0ex()\n}","parent":["dedth3v","biidd","eleq2","eleq1","sselii","keephyp3v","sseq1","sseq2","ssid","elimhyp3v","snid","0ex"],"children":[]},{"name":"csbexg","content":"The existence of proper substitution into a class. (Contributed by NM, 10-Nov-2005.) (Revised by NM, 17-Aug-2018.)","origin":"thm csbexg(setvar s0, class c0, class c1, class c2) {\n  |- wi(wal(s0, wcel(c0, c1)), wcel(csb(s0, c2, c0), universe))\n} = {\n  pm2.61ian(wal(s0, wcel(c0, c1)), wcel(csb(s0, c2, c0), universe), wcel(c2, universe))\n  syl5eqel(csb(s0, c2, c0), universe, cab(hs0, wsbc(s0, c2, wcel(cv(hs0), c0))), wa(wcel(c2, universe), wal(s0, wcel(c0, c1))))\n  df-csb(s0, hs0, c2, c0)\n  imp(wcel(c2, universe), wal(s0, wcel(c0, c1)), wcel(cab(hs0, wsbc(s0, c2, wcel(cv(hs0), c0))), universe))\n  sylibd(wcel(c2, universe), wal(s0, wcel(c0, c1)), wcel(cab(hs0, wsbc(s0, c2, wcel(cv(hs0), c0))), universe), wsbc(s0, c2, wcel(cab(hs0, wcel(cv(hs0), c0)), universe)))\n  syl5(wcel(c2, universe), wal(s0, wcel(c0, c1)), wsbc(s0, c2, wcel(cab(hs0, wcel(cv(hs0), c0)), universe)), wal(s0, wcel(cab(hs0, wcel(cv(hs0), c0)), universe)))\n  alimi(s0, wcel(c0, c1), wcel(cab(hs0, wcel(cv(hs0), c0)), universe))\n  syl5eqel(cab(hs0, wcel(cv(hs0), c0)), universe, c0, wcel(c0, c1))\n  abid2(hs0, c0)\n  elex(c0, c1)\n  spsbc(s0, c2, universe, wcel(cab(hs0, wcel(cv(hs0), c0)), universe))\n  sbcabel(s0, hs0, c2, universe, universe, wcel(cv(hs0), c0))\n  nfcv(s0, universe)\n  adantr(wn(wcel(c2, universe)), wal(s0, wcel(c0, c1)), wcel(csb(s0, c2, c0), universe))\n  syl6eqel(csb(s0, c2, c0), universe, emptycls, wn(wcel(c2, universe)))\n  csbprc(s0, c2, c0)\n  0ex()\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.c(c2)\n  diff.hs0.c(c0)\n  diff.universe.s(s0)\n}","pretty":"thm csbexg(setvar s0, class c0, class c1, class c2) {\n  ⊢ (∀(s0, c0 ∈ c1)→[c2 / s0]c0 ∈ 𝕌)\n} = {\n  pm2.61ian(∀(s0, c0 ∈ c1), [c2 / s0]c0 ∈ 𝕌, c2 ∈ 𝕌)\n  syl5eqel([c2 / s0]c0, universe, { hs0 |[c2 / s0]hs0 ∈ c0 }, (c2 ∈ 𝕌 ∧ ∀(s0, c0 ∈ c1)))\n  df-csb(s0, hs0, c2, c0)\n  imp(c2 ∈ 𝕌, ∀(s0, c0 ∈ c1), { hs0 |[c2 / s0]hs0 ∈ c0 } ∈ 𝕌)\n  sylibd(c2 ∈ 𝕌, ∀(s0, c0 ∈ c1), { hs0 |[c2 / s0]hs0 ∈ c0 } ∈ 𝕌, [c2 / s0]{ hs0 | hs0 ∈ c0 } ∈ 𝕌)\n  syl5(c2 ∈ 𝕌, ∀(s0, c0 ∈ c1), [c2 / s0]{ hs0 | hs0 ∈ c0 } ∈ 𝕌, ∀(s0, { hs0 | hs0 ∈ c0 } ∈ 𝕌))\n  alimi(s0, c0 ∈ c1, { hs0 | hs0 ∈ c0 } ∈ 𝕌)\n  syl5eqel({ hs0 | hs0 ∈ c0 }, universe, c0, c0 ∈ c1)\n  abid2(hs0, c0)\n  elex(c0, c1)\n  spsbc(s0, c2, universe, { hs0 | hs0 ∈ c0 } ∈ 𝕌)\n  sbcabel(s0, hs0, c2, universe, universe, hs0 ∈ c0)\n  nfcv(s0, universe)\n  adantr(¬ c2 ∈ 𝕌, ∀(s0, c0 ∈ c1), [c2 / s0]c0 ∈ 𝕌)\n  syl6eqel([c2 / s0]c0, universe, emptycls, ¬ c2 ∈ 𝕌)\n  csbprc(s0, c2, c0)\n  0ex()\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.c(c2)\n  diff.hs0.c(c0)\n  diff.universe.s(s0)\n}","parent":["pm2.61ian","syl5eqel","df-csb","imp","sylibd","syl5","alimi","abid2","elex","spsbc","sbcabel","nfcv","adantr","syl6eqel","csbprc","0ex","diffss.ex","diff.hs0.s","diff.hs0.c","diff.universe.s"],"children":["csbex","abfmpeld"]},{"name":"csbex","content":"The existence of proper substitution into a class. (Contributed by NM, 7-Aug-2007.) (Proof shortened by Andrew Salmon, 29-Jun-2011.) (Revised by NM, 17-Aug-2018.)","origin":"thm csbex(setvar s0, class c0, class c1) {\n  |- wcel(csb(s0, c0, c1), universe)\n  -| wcel(c1, universe)\n} = {\n  mpg(s0, wcel(csb(s0, c0, c1), universe), wcel(c1, universe))\n  csbexg(s0, c1, universe, c0)\n}","pretty":"thm csbex(setvar s0, class c0, class c1) {\n  ⊢ [c0 / s0]c1 ∈ 𝕌\n  ⊣ c1 ∈ 𝕌\n} = {\n  mpg(s0, [c0 / s0]c1 ∈ 𝕌, c1 ∈ 𝕌)\n  csbexg(s0, c1, universe, c0)\n}","parent":["mpg","csbexg"],"children":["iunopeqop","dfmpt2","cantnfdm","cantnff","bpolylem","ruclem1","pcmpt","cidffn","issubc","natffn","fnxpc","evlfcl","odf","itgfsum","itgparts","vmaf","ttgval","abfmpel","msrf","finxpreclem2","cnfinltrel","poimirlem17","poimirlem23","poimirlem24","unirep","cdlemk40","aomclem6","rnghmfn","rngchomrnghmresALTV"]},{"name":"unisn2","content":"A version of ~ unisn without the ` A e. _V ` hypothesis. (Contributed by Stefan Allan, 14-Mar-2006.)","origin":"thm unisn2(class c0) {\n  |- wcel(cuni(csn(c0)), cpr(emptycls, c0))\n} = {\n  pm2.61i(wcel(cuni(csn(c0)), cpr(emptycls, c0)), wcel(c0, universe))\n  eqeltrd(cuni(csn(c0)), cpr(emptycls, c0), c0, wcel(c0, universe))\n  unisng(c0, universe)\n  prid2g(c0, universe, emptycls)\n  syl6eqel(cuni(csn(c0)), cpr(emptycls, c0), cuni(emptycls), wn(wcel(c0, universe)))\n  unieqd(csn(c0), emptycls, wn(wcel(c0, universe)))\n  biimpi(wn(wcel(c0, universe)), wceq(csn(c0), emptycls))\n  snprc(c0)\n  eqeltri(cuni(emptycls), cpr(emptycls, c0), emptycls)\n  uni0()\n  prid1(emptycls, c0)\n  0ex()\n}","pretty":"thm unisn2(class c0) {\n  ⊢ ⋃ { c0 } ∈ { ∅, c0 }\n} = {\n  pm2.61i(⋃ { c0 } ∈ { ∅, c0 }, c0 ∈ 𝕌)\n  eqeltrd(⋃ { c0 }, { ∅, c0 }, c0, c0 ∈ 𝕌)\n  unisng(c0, universe)\n  prid2g(c0, universe, emptycls)\n  syl6eqel(⋃ { c0 }, { ∅, c0 }, ⋃ ∅, ¬ c0 ∈ 𝕌)\n  unieqd({ c0 }, emptycls, ¬ c0 ∈ 𝕌)\n  biimpi(¬ c0 ∈ 𝕌, { c0 } = ∅)\n  snprc(c0)\n  eqeltri(⋃ ∅, { ∅, c0 }, emptycls)\n  uni0()\n  prid1(emptycls, c0)\n  0ex()\n}","parent":["pm2.61i","eqeltrd","unisng","prid2g","syl6eqel","unieqd","biimpi","snprc","eqeltri","uni0","prid1","0ex"],"children":[]}]}