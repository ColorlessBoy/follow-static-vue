{"index":1147,"title":"Russell's paradox","content":"A few results around Russell's paradox. For clarity, we prove separately its FOL part ( ~ bj-ru0 ) and then two versions ( ~ bj-ru1 and ~ bj-ru ). Special attention is put on minimizing axiom depencencies.","blocks":[{"name":"bj-ru0","content":"The FOL part of Russell's paradox ~ ru (see also ~ bj-ru1 , ~ bj-ru ). Use of ~ elequ1 , ~ bj-elequ12 (instead of ~ eleq1 , ~ eleq12d as in ~ ru ) permits to remove dependency on ~ ax-10 , ~ ax-11 , ~ ax-12 , ~ ax-ext , ~ df-sb , ~ df-clab , ~ df-cleq , ~ df-clel . (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ru0(setvar s0, setvar s1) {\n  |- wn(wal(s0, wb(wcel(cv(s0), cv(s1)), wn(wcel(cv(s0), cv(s0))))))\n  -| diffss(s0, s1)\n} = {\n  mto(wal(s0, wb(wcel(cv(s0), cv(s1)), wn(wcel(cv(s0), cv(s0))))), wb(wcel(cv(s1), cv(s1)), wn(wcel(cv(s1), cv(s1)))))\n  pm5.19(wcel(cv(s1), cv(s1)))\n  spvv(s0, s1, wb(wcel(cv(s0), cv(s1)), wn(wcel(cv(s0), cv(s0)))), wb(wcel(cv(s1), cv(s1)), wn(wcel(cv(s1), cv(s1)))))\n  bibi12d(wceq(cv(s0), cv(s1)), wcel(cv(s0), cv(s1)), wn(wcel(cv(s0), cv(s0))), wcel(cv(s1), cv(s1)), wn(wcel(cv(s1), cv(s1))))\n  elequ1(s0, s1, s1)\n  notbid(wceq(cv(s0), cv(s1)), wcel(cv(s0), cv(s0)), wcel(cv(s1), cv(s1)))\n  anidms(wceq(cv(s0), cv(s1)), wb(wcel(cv(s0), cv(s0)), wcel(cv(s1), cv(s1))))\n  bj-elequ12(s0, s1, s0, s1)\n  diff.wb.s(s0, wcel(cv(s1), cv(s1)), wn(wcel(cv(s1), cv(s1))))\n  diff.wn.s(s0, wcel(cv(s1), cv(s1)))\n  diff.wcel.s(s0, cv(s1), cv(s1))\n  diff.cv.s(s0, s1)\n}","pretty":"thm bj-ru0(setvar s0, setvar s1) {\n  ⊢ ¬ ∀(s0,(s0 ∈ s1 ↔ ¬ s0 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  mto(∀(s0,(s0 ∈ s1 ↔ ¬ s0 ∈ s0)), (s1 ∈ s1 ↔ ¬ s1 ∈ s1))\n  pm5.19(s1 ∈ s1)\n  spvv(s0, s1, (s0 ∈ s1 ↔ ¬ s0 ∈ s0), (s1 ∈ s1 ↔ ¬ s1 ∈ s1))\n  bibi12d(s0 = s1, s0 ∈ s1, ¬ s0 ∈ s0, s1 ∈ s1, ¬ s1 ∈ s1)\n  elequ1(s0, s1, s1)\n  notbid(s0 = s1, s0 ∈ s0, s1 ∈ s1)\n  anidms(s0 = s1, (s0 ∈ s0 ↔ s1 ∈ s1))\n  bj-elequ12(s0, s1, s0, s1)\n  diff.wb.s(s0, s1 ∈ s1, ¬ s1 ∈ s1)\n  diff.wn.s(s0, s1 ∈ s1)\n  diff.wcel.s(s0, s1, s1)\n  diff.cv.s(s0, s1)\n}","parent":["mto","pm5.19","spvv","bibi12d","elequ1","notbid","anidms","bj-elequ12","diff.wb.s","diff.wn.s","diff.wcel.s","diff.cv.s"],"children":["bj-ru1"]},{"name":"bj-ru1","content":"A version of Russell's paradox ~ ru (see also ~ bj-ru ). Note the more economical use of ~ bj-abeq2 instead of ~ abeq2 to avoid dependency on ~ ax-13 . (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ru1(setvar s0, setvar s1) {\n  |- wn(wex(s0, wceq(cv(s0), cab(s1, wn(wcel(cv(s1), cv(s1)))))))\n  -| diffss(s0, s1)\n} = {\n  nex(s0, wceq(cv(s0), cab(s1, wn(wcel(cv(s1), cv(s1))))))\n  mtbir(wceq(cv(s0), cab(s1, wn(wcel(cv(s1), cv(s1))))), wal(s1, wb(wcel(cv(s1), cv(s0)), wn(wcel(cv(s1), cv(s1))))))\n  bj-ru0(s1, s0)\n  bj-abeq2(s1, cv(s0), wn(wcel(cv(s1), cv(s1))))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm bj-ru1(setvar s0, setvar s1) {\n  ⊢ ¬ ∃(s0, s0 = { s1 | ¬ s1 ∈ s1 })\n  ⊣ d(s0, s1)\n} = {\n  nex(s0, s0 = { s1 | ¬ s1 ∈ s1 })\n  mtbir(s0 = { s1 | ¬ s1 ∈ s1 }, ∀(s1,(s1 ∈ s0 ↔ ¬ s1 ∈ s1)))\n  bj-ru0(s1, s0)\n  bj-abeq2(s1, s0, ¬ s1 ∈ s1)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["nex","mtbir","bj-ru0","bj-abeq2","diff.cv.s","diffss.ex"],"children":["bj-ru"]},{"name":"bj-ru","content":"Remove dependency on ~ ax-13 (and ~ df-v ) from Russell's paradox ~ ru expressed with primitive symbols and with a class variable ` V ` (note that ~ axsep2 does require ~ ax-8 and ~ ax-9 since it requires ~ df-clel and ~ df-cleq --- see ~ bj-df-clel and ~ bj-df-cleq ). Note the more economical use of ~ bj-elissetv instead of ~ isset to avoid use of ~ df-v . (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ru(setvar s0, class c0) {\n  |- wn(wcel(cab(s0, wn(wcel(cv(s0), cv(s0)))), c0))\n} = {\n  mto(wcel(cab(s0, wn(wcel(cv(s0), cv(s0)))), c0), wex(hs0, wceq(cv(hs0), cab(s0, wn(wcel(cv(s0), cv(s0)))))))\n  bj-ru1(hs0, s0)\n  bj-elissetv(hs0, cab(s0, wn(wcel(cv(s0), cv(s0)))), c0)\n  diff.hs0.s(s0)\n  diff.hs0.c(cab(s0, wn(wcel(cv(s0), cv(s0)))))\n  diff.hs0.c(c0)\n}","pretty":"thm bj-ru(setvar s0, class c0) {\n  ⊢ ¬ { s0 | ¬ s0 ∈ s0 } ∈ c0\n} = {\n  mto({ s0 | ¬ s0 ∈ s0 } ∈ c0, ∃(hs0, hs0 = { s0 | ¬ s0 ∈ s0 }))\n  bj-ru1(hs0, s0)\n  bj-elissetv(hs0, { s0 | ¬ s0 ∈ s0 }, c0)\n  diff.hs0.s(s0)\n  diff.hs0.c({ s0 | ¬ s0 ∈ s0 })\n  diff.hs0.c(c0)\n}","parent":["mto","bj-ru1","bj-elissetv","diff.hs0.s","diff.hs0.c"],"children":[]}]}