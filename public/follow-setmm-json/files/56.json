{"index":56,"title":"Define proper substitution","content":"","blocks":[{"name":"sbjustlem","content":"Lemma for ~ sbjust . (Contributed by BJ, 9-Nov-2021.)","origin":"thm sbjustlem(setvar s0, setvar s1, setvar s2, setvar s3, wff w0) {\n  |- wb(wal(s0, wi(wceq(cv(s0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s0)), w0)))), wal(s3, wi(wceq(cv(s3), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s3)), w0)))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s0, s3)\n  -| diffss(s1, s3)\n  -| diffss(s2, s3)\n  -| diffsw(s0, w0)\n  -| diffsw(s3, w0)\n} = {\n  cbvalvw(s0, s3, wi(wceq(cv(s0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s0)), w0))), wi(wceq(cv(s3), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s3)), w0))))\n  imbi12d(wceq(cv(s0), cv(s3)), wceq(cv(s0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s0)), w0)), wceq(cv(s3), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s3)), w0)))\n  equequ1(s0, s3, s1)\n  albidv(s2, wceq(cv(s0), cv(s3)), wi(wceq(cv(s2), cv(s0)), w0), wi(wceq(cv(s2), cv(s3)), w0))\n  imbi1d(wceq(cv(s0), cv(s3)), wceq(cv(s2), cv(s0)), w0, wceq(cv(s2), cv(s3)))\n  equequ2(s0, s3, s2)\n  diff.wi.s(s0, wceq(cv(s3), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s3)), w0)))\n  diff.wceq.s(s0, cv(s3), cv(s1))\n  diff.cv.s(s0, s1)\n  diff.wal.s(s0, s2, wi(wceq(cv(s2), cv(s3)), w0))\n  diff.wi.s(s0, wceq(cv(s2), cv(s3)), w0)\n  diff.wceq.s(s0, cv(s2), cv(s3))\n  diff.cv.s(s0, s2)\n  diff.cv.s(s0, s3)\n  diff.wi.s(s3, wceq(cv(s0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s0)), w0)))\n  diff.wceq.s(s3, cv(s0), cv(s1))\n  diff.cv.s(s3, s1)\n  diffss.ex(s3, s1)\n  diff.wal.s(s3, s2, wi(wceq(cv(s2), cv(s0)), w0))\n  diff.wi.s(s3, wceq(cv(s2), cv(s0)), w0)\n  diff.wceq.s(s3, cv(s2), cv(s0))\n  diff.cv.s(s3, s2)\n  diffss.ex(s3, s2)\n  diff.cv.s(s3, s0)\n  diffss.ex(s3, s0)\n  diff.wceq.s(s2, cv(s0), cv(s3))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s3)\n}","pretty":"thm sbjustlem(setvar s0, setvar s1, setvar s2, setvar s3, wff w0) {\n  ⊢ (∀(s0,(s0 = s1 → ∀(s2,(s2 = s0 → w0))))↔ ∀(s3,(s3 = s1 → ∀(s2,(s2 = s3 → w0)))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s0, s3)\n  ⊣ d(s1, s3)\n  ⊣ d(s2, s3)\n  ⊣ d(s0, w0)\n  ⊣ d(s3, w0)\n} = {\n  cbvalvw(s0, s3, (s0 = s1 → ∀(s2,(s2 = s0 → w0))), (s3 = s1 → ∀(s2,(s2 = s3 → w0))))\n  imbi12d(s0 = s3, s0 = s1, ∀(s2,(s2 = s0 → w0)), s3 = s1, ∀(s2,(s2 = s3 → w0)))\n  equequ1(s0, s3, s1)\n  albidv(s2, s0 = s3, (s2 = s0 → w0), (s2 = s3 → w0))\n  imbi1d(s0 = s3, s2 = s0, w0, s2 = s3)\n  equequ2(s0, s3, s2)\n  diff.wi.s(s0, s3 = s1, ∀(s2,(s2 = s3 → w0)))\n  diff.wceq.s(s0, s3, s1)\n  diff.cv.s(s0, s1)\n  diff.wal.s(s0, s2, (s2 = s3 → w0))\n  diff.wi.s(s0, s2 = s3, w0)\n  diff.wceq.s(s0, s2, s3)\n  diff.cv.s(s0, s2)\n  diff.cv.s(s0, s3)\n  diff.wi.s(s3, s0 = s1, ∀(s2,(s2 = s0 → w0)))\n  diff.wceq.s(s3, s0, s1)\n  diff.cv.s(s3, s1)\n  diffss.ex(s3, s1)\n  diff.wal.s(s3, s2, (s2 = s0 → w0))\n  diff.wi.s(s3, s2 = s0, w0)\n  diff.wceq.s(s3, s2, s0)\n  diff.cv.s(s3, s2)\n  diffss.ex(s3, s2)\n  diff.cv.s(s3, s0)\n  diffss.ex(s3, s0)\n  diff.wceq.s(s2, s0, s3)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s3)\n}","parent":["cbvalvw","imbi12d","equequ1","albidv","imbi1d","equequ2","diff.wi.s","diff.wceq.s","diff.cv.s","diff.wal.s","diffss.ex"],"children":["sbjust"]},{"name":"sbjust","content":"Justification theorem for ~ df-sb from Tarski's FOL. (Contributed by BJ, 22-Jan-2023.)","origin":"thm sbjust(setvar s0, setvar s1, setvar s2, setvar s3, wff w0) {\n  |- wb(wal(s0, wi(wceq(cv(s0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s0)), w0)))), wal(s3, wi(wceq(cv(s3), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s3)), w0)))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s3)\n  -| diffss(s2, s3)\n  -| diffsw(s0, w0)\n  -| diffsw(s3, w0)\n} = {\n  bitri(wal(s0, wi(wceq(cv(s0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s0)), w0)))), wal(s3, wi(wceq(cv(s3), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(s3)), w0)))), wal(hs0, wi(wceq(cv(hs0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(hs0)), w0)))))\n  sbjustlem(s0, s1, s2, hs0, w0)\n  sbjustlem(hs0, s1, s2, s3, w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s1, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s1)\n  diff.hs0.s(s2)\n  diff.hs0.s(s3)\n}","pretty":"thm sbjust(setvar s0, setvar s1, setvar s2, setvar s3, wff w0) {\n  ⊢ (∀(s0,(s0 = s1 → ∀(s2,(s2 = s0 → w0))))↔ ∀(s3,(s3 = s1 → ∀(s2,(s2 = s3 → w0)))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s3)\n  ⊣ d(s2, s3)\n  ⊣ d(s0, w0)\n  ⊣ d(s3, w0)\n} = {\n  bitri(∀(s0,(s0 = s1 → ∀(s2,(s2 = s0 → w0)))), ∀(s3,(s3 = s1 → ∀(s2,(s2 = s3 → w0)))), ∀(hs0,(hs0 = s1 → ∀(s2,(s2 = hs0 → w0)))))\n  sbjustlem(s0, s1, s2, hs0, w0)\n  sbjustlem(hs0, s1, s2, s3, w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s1, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s1)\n  diff.hs0.s(s2)\n  diff.hs0.s(s3)\n}","parent":["bitri","sbjustlem","diffss.ex","diff.hs0.s","diff.hs0.w"],"children":[]},{"name":"wsb","content":"Extend wff definition to include proper substitution (read \"the wff that results when ` y ` is properly substituted for ` x ` in wff ` ph ` \"). (Contributed by NM, 24-Jan-2006.)","origin":"prop wff wsb(setvar s0, setvar s1, wff w0) { [s0 / s1]w0 }","pretty":"","parent":[],"children":[]},{"name":"diff.wsb.s","content":"","origin":"axiom diff.wsb.s(setvar sBase, setvar s0, setvar s1, wff w0) {\n  |- diffsw(sBase, wsb(s0, s1, w0))\n  -| diffss(sBase, s0)\n  -| diffss(sBase, s1)\n  -| diffsw(sBase, w0)\n}","pretty":"axiom diff.wsb.s(setvar sBase, setvar s0, setvar s1, wff w0) {\n  ⊢ d(sBase,[s0 / s1]w0)\n  ⊣ d(sBase, s0)\n  ⊣ d(sBase, s1)\n  ⊣ d(sBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wsb.c","content":"","origin":"axiom diff.wsb.c(class cBase, setvar s0, setvar s1, wff w0) {\n  |- diffcw(cBase, wsb(s0, s1, w0))\n  -| diffsc(s0, cBase)\n  -| diffsc(s1, cBase)\n  -| diffcw(cBase, w0)\n}","pretty":"axiom diff.wsb.c(class cBase, setvar s0, setvar s1, wff w0) {\n  ⊢ d(cBase,[s0 / s1]w0)\n  ⊣ d(s0, cBase)\n  ⊣ d(s1, cBase)\n  ⊣ d(cBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wsb.w","content":"","origin":"axiom diff.wsb.w(wff wBase, setvar s0, setvar s1, wff w0) {\n  |- diffww(wBase, wsb(s0, s1, w0))\n  -| diffsw(s0, wBase)\n  -| diffsw(s1, wBase)\n  -| diffww(wBase, w0)\n}","pretty":"axiom diff.wsb.w(wff wBase, setvar s0, setvar s1, wff w0) {\n  ⊢ d(wBase,[s0 / s1]w0)\n  ⊣ d(s0, wBase)\n  ⊣ d(s1, wBase)\n  ⊣ d(wBase, w0)\n}","parent":[],"children":[]},{"name":"df-sb","content":"Define proper substitution. For our notation, we use ` [ t / x ] ph ` to mean \"the wff that results from the proper substitution of ` t ` for ` x ` in the wff ` ph ` \". That is, ` t ` properly replaces ` x ` . For example, ` [ t / x ] z e. x ` is the same as ` z e. t ` (when ` x ` and ` z ` are distinct), as shown in ~ elsb4 . Our notation was introduced in Haskell B. Curry's _Foundations of Mathematical Logic_ (1977), p. 316 and is frequently used in textbooks of lambda calculus and combinatory logic. This notation improves the common but ambiguous notation, \" ` ph ( t ) ` is the wff that results when ` t ` is properly substituted for ` x ` in ` ph ( x ) ` \". For example, if the original ` ph ( x ) ` is ` x = t ` , then ` ph ( t ) ` is ` t = t ` , from which we obtain that ` ph ( x ) ` is ` x = x ` . So what exactly does ` ph ( x ) ` mean? Curry's notation solves this problem. A very similar notation, namely ` ( y | x ) ph ` , was introduced in Bourbaki's Set Theory (Chapter 1, Description of Formal Mathematic, 1953). In most books, proper substitution has a somewhat complicated recursive definition with multiple cases based on the occurrences of free and bound variables in the wff. Instead, we use a single formula that is exactly equivalent and gives us a direct definition. We later prove that our definition has the properties we expect of proper substitution (see theorems ~ sbequ , ~ sbcom2 and ~ sbid2v ). Note that our definition is valid even when ` x ` and ` t ` are replaced with the same variable, as ~ sbid shows. We achieve this by applying twice Tarski's definition ~ sb6 which is valid for disjoint variables, and introducing a dummy variable ` y ` which isolates ` x ` from ` t ` , as in ~ dfsb7 with respect to ~ sb5 . We can also achieve this by having ` x ` free in the first conjunct and bound in the second, as the alternate definition ~ dfsb1 shows. Another version that mixes free and bound variables is ~ dfsb3 . When ` x ` and ` t ` are distinct, we can express proper substitution with the simpler expressions of ~ sb5 and ~ sb6 . Note that the occurrences of a given variable in the definiens are either all bound ( ` x , y ` ) or all free ( ` t ` ). Also note that the definiens uses only primitive symbols. This double level definition will make several proofs using it appear as doubled. Alternately, one could often first prove as a lemma the same theorem with a disjoint variable condition on the substitute and the substituted variables, and then prove the original theorem by applying this lemma twice in a row. (Contributed by NM, 10-May-1993.) Revised from the original definition ~ dfsb1 . (Revised by BJ, 22-Dec-2020.)","origin":"axiom df-sb(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wsb(s0, s1, w0), wal(s2, wi(wceq(cv(s2), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(s2)), w0)))))\n  -| diffss(s1, s2)\n  -| diffss(s0, s2)\n  -| diffsw(s2, w0)\n}","pretty":"axiom df-sb(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ ([s0 / s1]w0 ↔ ∀(s2,(s2 = s0 → ∀(s1,(s1 = s2 → w0)))))\n  ⊣ d(s1, s2)\n  ⊣ d(s0, s2)\n  ⊣ d(s2, w0)\n}","parent":[],"children":["sbt","stdpc4","sbi1","spsbe","spsbeOLD","sbequ","sb6","sbequ1","sbequ2","dfsb7","sbn","sb4b","bj-ssbeq","bj-ssbid2ALT","bj-ssbid1ALT"]},{"name":"sbt","content":"A substitution into a theorem yields a theorem. See ~ sbtALT for a shorter proof requiring more axioms. See ~ chvar and ~ chvarv for versions using implicit substitution. (Contributed by NM, 21-Jan-2004.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 20-Jul-2018.) Revise ~ df-sb . (Revised by Steven Nguyen, 6-Jul-2023.)","origin":"thm sbt(setvar s0, setvar s1, wff w0) {\n  |- wsb(s0, s1, w0)\n  -| w0\n} = {\n  mpbir(wsb(s0, s1, w0), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))))\n  ax-gen(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))))\n  a1i(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))\n  ax-gen(s1, wi(wceq(cv(s1), cv(hs0)), w0))\n  a1i(wceq(cv(s1), cv(hs0)), w0)\n  df-sb(s0, s1, hs0, w0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(w0)\n}","pretty":"thm sbt(setvar s0, setvar s1, wff w0) {\n  ⊢ [s0 / s1]w0\n  ⊣ w0\n} = {\n  mpbir([s0 / s1]w0, ∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w0)))))\n  ax-gen(hs0, (hs0 = s0 → ∀(s1,(s1 = hs0 → w0))))\n  a1i(hs0 = s0, ∀(s1,(s1 = hs0 → w0)))\n  ax-gen(s1, (s1 = hs0 → w0))\n  a1i(s1 = hs0, w0)\n  df-sb(s0, s1, hs0, w0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(w0)\n}","parent":["mpbir","ax-gen","a1i","df-sb","diffss.ex","diff.hs0.s","diff.hs0.w"],"children":["sbimi","vjust","iscatd2","iuninc","suppss2f","esumpfinvalf","wl-rgenw","sn-vexw","sbtT","2sb5ndVD","2sb5ndALT"]},{"name":"stdpc4","content":"The specialization axiom of standard predicate calculus. It states that if a statement ` ph ` holds for all ` x ` , then it also holds for the specific case of ` t ` (properly) substituted for ` x ` . Translated to traditional notation, it can be read: \" ` A. x ph ( x ) -> ph ( t ) ` , provided that ` t ` is free for ` x ` in ` ph ( x ) ` \". Axiom 4 of [Mendelson] p. 69. See also ~ spsbc and ~ rspsbc . (Contributed by NM, 14-May-1993.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.)","origin":"thm stdpc4(setvar s0, setvar s1, wff w0) {\n  |- wi(wal(s0, w0), wsb(s1, s0, w0))\n} = {\n  sylibr(wal(s0, w0), wsb(s1, s0, w0), wal(hs0, wi(wceq(cv(hs0), cv(s1)), wal(s0, wi(wceq(cv(s0), cv(hs0)), w0)))))\n  alrimiv(hs0, wal(s0, w0), wi(wceq(cv(hs0), cv(s1)), wal(s0, wi(wceq(cv(s0), cv(hs0)), w0))))\n  a1d(wal(s0, w0), wceq(cv(hs0), cv(s1)), wal(s0, wi(wceq(cv(s0), cv(hs0)), w0)))\n  ala1(s0, w0, wceq(cv(s0), cv(hs0)))\n  df-sb(s1, s0, hs0, w0)\n  diff.hs0.w(wal(s0, w0))\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.hs0.w(w0)\n}","pretty":"thm stdpc4(setvar s0, setvar s1, wff w0) {\n  ⊢ (∀(s0, w0)→[s1 / s0]w0)\n} = {\n  sylibr(∀(s0, w0), [s1 / s0]w0, ∀(hs0,(hs0 = s1 → ∀(s0,(s0 = hs0 → w0)))))\n  alrimiv(hs0, ∀(s0, w0), (hs0 = s1 → ∀(s0,(s0 = hs0 → w0))))\n  a1d(∀(s0, w0), hs0 = s1, ∀(s0,(s0 = hs0 → w0)))\n  ala1(s0, w0, s0 = hs0)\n  df-sb(s1, s0, hs0, w0)\n  diff.hs0.w(∀(s0, w0))\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.hs0.w(w0)\n}","parent":["sylibr","alrimiv","a1d","ala1","df-sb","diff.hs0.w","diffss.ex","diff.hs0.s"],"children":["sbtALT","2stdpc4","spsbim","sbv","sbft","sb2","spsbimOLD","spsbbiOLD","sbtrt","pm13.183","pm13.183OLD","spsbc","nd1","nd2","bj-ssbft","bj-vexwt","bj-ab0","axfrege58b","pm10.14","pm11.57"]},{"name":"sbtALT","content":"Alternate proof of ~ sbt , shorter but using ~ ax-4 and ~ ax-5 . (Contributed by NM, 21-Jan-2004.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm sbtALT(setvar s0, setvar s1, wff w0) {\n  |- wsb(s0, s1, w0)\n  -| w0\n} = {\n  mpg(s1, wsb(s0, s1, w0), w0)\n  stdpc4(s1, s0, w0)\n}","pretty":"thm sbtALT(setvar s0, setvar s1, wff w0) {\n  ⊢ [s0 / s1]w0\n  ⊣ w0\n} = {\n  mpg(s1, [s0 / s1]w0, w0)\n  stdpc4(s1, s0, w0)\n}","parent":["mpg","stdpc4"],"children":[]},{"name":"2stdpc4","content":"A double specialization using explicit substitution. This is Theorem PM*11.1 in [WhiteheadRussell] p. 159. See ~ stdpc4 for the analogous single specialization. See ~ 2sp for another double specialization. (Contributed by Andrew Salmon, 24-May-2011.) (Revised by BJ, 21-Oct-2018.)","origin":"thm 2stdpc4(setvar s0, setvar s1, setvar s2, setvar s3, wff w0) {\n  |- wi(wal(s0, wal(s1, w0)), wsb(s2, s0, wsb(s3, s1, w0)))\n} = {\n  syl(wal(s0, wal(s1, w0)), wsb(s2, s0, wsb(s3, s1, w0)), wal(s0, wsb(s3, s1, w0)))\n  alimi(s0, wal(s1, w0), wsb(s3, s1, w0))\n  stdpc4(s1, s3, w0)\n  stdpc4(s0, s2, wsb(s3, s1, w0))\n}","pretty":"thm 2stdpc4(setvar s0, setvar s1, setvar s2, setvar s3, wff w0) {\n  ⊢ (∀(s0, ∀(s1, w0))→[s2 / s0][s3 / s1]w0)\n} = {\n  syl(∀(s0, ∀(s1, w0)), [s2 / s0][s3 / s1]w0, ∀(s0,[s3 / s1]w0))\n  alimi(s0, ∀(s1, w0), [s3 / s1]w0)\n  stdpc4(s1, s3, w0)\n  stdpc4(s0, s2, [s3 / s1]w0)\n}","parent":["syl","alimi","stdpc4"],"children":["ax11-pm2","pm11.11"]},{"name":"sbi1","content":"Distribute substitution over implication. (Contributed by NM, 14-May-1993.) Remove dependencies on axioms. (Revised by Steven Nguyen, 24-Jul-2023.)","origin":"thm sbi1(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wsb(s0, s1, wi(w0, w1)), wi(wsb(s0, s1, w0), wsb(s0, s1, w1)))\n} = {\n  sylbi(wsb(s0, s1, wi(w0, w1)), wi(wsb(s0, s1, w0), wsb(s0, s1, w1)), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), wi(w0, w1))))))\n  df-sb(s0, s1, hs0, wi(w0, w1))\n  3imtr4g(wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), wi(w0, w1))))), wsb(s0, s1, w0), wsb(s0, s1, w1), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w1)))))\n  al2imi(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), wi(w0, w1)))), wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))), wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w1))))\n  imim3i(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), wi(w0, w1))), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w1)))\n  al2imi(s1, wi(wceq(cv(s1), cv(hs0)), wi(w0, w1)), wi(wceq(cv(s1), cv(hs0)), w0), wi(wceq(cv(s1), cv(hs0)), w1))\n  ax-2(wceq(cv(s1), cv(hs0)), w0, w1)\n  df-sb(s0, s1, hs0, w0)\n  df-sb(s0, s1, hs0, w1)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(wi(w0, w1))\n  diff.hs0.w(w0)\n  diff.hs0.w(w1)\n}","pretty":"thm sbi1(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ ([s0 / s1](w0 → w1)→([s0 / s1]w0 →[s0 / s1]w1))\n} = {\n  sylbi([s0 / s1](w0 → w1), ([s0 / s1]w0 →[s0 / s1]w1), ∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 →(w0 → w1))))))\n  df-sb(s0, s1, hs0, (w0 → w1))\n  3imtr4g(∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 →(w0 → w1))))), [s0 / s1]w0, [s0 / s1]w1, ∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w0)))), ∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w1)))))\n  al2imi(hs0, (hs0 = s0 → ∀(s1,(s1 = hs0 →(w0 → w1)))), (hs0 = s0 → ∀(s1,(s1 = hs0 → w0))), (hs0 = s0 → ∀(s1,(s1 = hs0 → w1))))\n  imim3i(hs0 = s0, ∀(s1,(s1 = hs0 →(w0 → w1))), ∀(s1,(s1 = hs0 → w0)), ∀(s1,(s1 = hs0 → w1)))\n  al2imi(s1, (s1 = hs0 →(w0 → w1)), (s1 = hs0 → w0), (s1 = hs0 → w1))\n  ax-2(s1 = hs0, w0, w1)\n  df-sb(s0, s1, hs0, w0)\n  df-sb(s0, s1, hs0, w1)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w((w0 → w1))\n  diff.hs0.w(w0)\n  diff.hs0.w(w1)\n}","parent":["sylbi","df-sb","3imtr4g","al2imi","imim3i","ax-2","diffss.ex","diff.hs0.s","diff.hs0.w"],"children":["spsbim","sbimi","spsbimOLD","sbim","2sb5ndVD","2sb5ndALT"]},{"name":"spsbim","content":"Distribute substitution over implication. Closed form of ~ sbimi . Specialization of implication. (Contributed by NM, 5-Aug-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) (Proof shortened by Steven Nguyen, 24-Jul-2023.)","origin":"thm spsbim(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, wi(w0, w1)), wi(wsb(s1, s0, w0), wsb(s1, s0, w1)))\n} = {\n  syl(wal(s0, wi(w0, w1)), wi(wsb(s1, s0, w0), wsb(s1, s0, w1)), wsb(s1, s0, wi(w0, w1)))\n  stdpc4(s0, s1, wi(w0, w1))\n  sbi1(s1, s0, w0, w1)\n}","pretty":"thm spsbim(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0,(w0 → w1))→([s1 / s0]w0 →[s1 / s0]w1))\n} = {\n  syl(∀(s0,(w0 → w1)), ([s1 / s0]w0 →[s1 / s0]w1), [s1 / s0](w0 → w1))\n  stdpc4(s0, s1, (w0 → w1))\n  sbi1(s1, s0, w0, w1)\n}","parent":["syl","stdpc4","sbi1"],"children":["spsbbi","sbimdv","sbimd","mo3","mo3OLD","bj-hbsb3t","wl-mo3t","pm11.59","sbiota1"]},{"name":"spsbbi","content":"Biconditional property for substitution. Closed form of ~ sbbii . Specialization of biconditional. (Contributed by NM, 2-Jun-1993.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.)","origin":"thm spsbbi(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wal(s0, wb(w0, w1)), wb(wsb(s1, s0, w0), wsb(s1, s0, w1)))\n} = {\n  impbid(wal(s0, wb(w0, w1)), wsb(s1, s0, w0), wsb(s1, s0, w1))\n  syl(wal(s0, wb(w0, w1)), wi(wsb(s1, s0, w0), wsb(s1, s0, w1)), wal(s0, wi(w0, w1)))\n  alimi(s0, wb(w0, w1), wi(w0, w1))\n  biimp(w0, w1)\n  spsbim(s0, s1, w0, w1)\n  syl(wal(s0, wb(w0, w1)), wi(wsb(s1, s0, w1), wsb(s1, s0, w0)), wal(s0, wi(w1, w0)))\n  alimi(s0, wb(w0, w1), wi(w1, w0))\n  biimpr(w0, w1)\n  spsbim(s0, s1, w1, w0)\n}","pretty":"thm spsbbi(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0,(w0 ↔ w1))→([s1 / s0]w0 ↔[s1 / s0]w1))\n} = {\n  impbid(∀(s0,(w0 ↔ w1)), [s1 / s0]w0, [s1 / s0]w1)\n  syl(∀(s0,(w0 ↔ w1)), ([s1 / s0]w0 →[s1 / s0]w1), ∀(s0,(w0 → w1)))\n  alimi(s0, (w0 ↔ w1), (w0 → w1))\n  biimp(w0, w1)\n  spsbim(s0, s1, w0, w1)\n  syl(∀(s0,(w0 ↔ w1)), ([s1 / s0]w1 →[s1 / s0]w0), ∀(s0,(w1 → w0)))\n  alimi(s0, (w0 ↔ w1), (w1 → w0))\n  biimpr(w0, w1)\n  spsbim(s0, s1, w1, w0)\n}","parent":["impbid","syl","alimi","biimp","spsbim","biimpr"],"children":["sbbidv","sbbid","sbbib","sbeqi"]},{"name":"sbimi","content":"Distribute substitution over implication. (Contributed by NM, 25-Jun-1998.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) (Proof shortened by Steven Nguyen, 24-Jul-2023.)","origin":"thm sbimi(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wsb(s0, s1, w0), wsb(s0, s1, w1))\n  -| wi(w0, w1)\n} = {\n  ax-mp(wi(wsb(s0, s1, w0), wsb(s0, s1, w1)), wsb(s0, s1, wi(w0, w1)))\n  sbt(s0, s1, wi(w0, w1))\n  sbi1(s0, s1, w0, w1)\n}","pretty":"thm sbimi(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ ([s0 / s1]w0 →[s0 / s1]w1)\n  ⊣ (w0 → w1)\n} = {\n  ax-mp(([s0 / s1]w0 →[s0 / s1]w1), [s0 / s1](w0 → w1))\n  sbt(s0, s1, (w0 → w1))\n  sbi1(s0, s1, w0, w1)\n}","parent":["ax-mp","sbt","sbi1"],"children":["sbbii","sbi2","sbi2vOLD","sbievOLD","hbsb3","sb6f","sbie","2mo","fmptdF","funcnv4mpt","disjdsct","measiuns","ballotlemodife","bj-hbsb3v","bj-sbidmOLD","mptsnunlem"]},{"name":"sbbii","content":"Infer substitution into both sides of a logical equivalence. (Contributed by NM, 14-May-1993.)","origin":"thm sbbii(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wsb(s0, s1, w0), wsb(s0, s1, w1))\n  -| wb(w0, w1)\n} = {\n  impbii(wsb(s0, s1, w0), wsb(s0, s1, w1))\n  sbimi(s0, s1, w0, w1)\n  biimpi(w0, w1)\n  sbimi(s0, s1, w1, w0)\n  biimpri(w1, w0)\n}","pretty":"thm sbbii(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ ([s0 / s1]w0 ↔[s0 / s1]w1)\n  ⊣ (w0 ↔ w1)\n} = {\n  impbii([s0 / s1]w0, [s0 / s1]w1)\n  sbimi(s0, s1, w0, w1)\n  biimpi(w0, w1)\n  sbimi(s0, s1, w1, w0)\n  biimpri(w1, w0)\n}","parent":["impbii","sbimi","biimpi","biimpri"],"children":["2sbbii","sbievw2","equsb3r","sbcov","sbanvOLD","sbbivOLD","sbcom4","sbor","sban","sb3an","sbbi","sbco","sbidm","sbco2d","sbco3","sb7f","sbex","sbco4lem","sbco4","sbmo","clelsb3vOLD","abbiiOLD","cbvabv","cbvab","clelsb3f","clelsb3fOLD","sbabel","sbralie","sbcco","exss","inopab","isarep1","bj-sbnf","bj-sbeq","bj-snsetex","wl-ich","wl-clelsb3df","2uasbanh","2uasbanhVD","2reu8i","ichid","ichcircshi","ichbi12i","icheq","ichan"]},{"name":"2sbbii","content":"Infer double substitution into both sides of a logical equivalence. (Contributed by AV, 30-Jul-2023.)","origin":"thm 2sbbii(setvar s0, setvar s1, setvar s2, setvar s3, wff w0, wff w1) {\n  |- wb(wsb(s0, s1, wsb(s2, s3, w0)), wsb(s0, s1, wsb(s2, s3, w1)))\n  -| wb(w0, w1)\n} = {\n  sbbii(s0, s1, wsb(s2, s3, w0), wsb(s2, s3, w1))\n  sbbii(s2, s3, w0, w1)\n}","pretty":"thm 2sbbii(setvar s0, setvar s1, setvar s2, setvar s3, wff w0, wff w1) {\n  ⊢ ([s0 / s1][s2 / s3]w0 ↔[s0 / s1][s2 / s3]w1)\n  ⊣ (w0 ↔ w1)\n} = {\n  sbbii(s0, s1, [s2 / s3]w0, [s2 / s3]w1)\n  sbbii(s2, s3, w0, w1)\n}","parent":["sbbii"],"children":["ichcircshi","ichbi12i","icheq"]},{"name":"sbimdv","content":"Deduction substituting both sides of an implication, with ` ph ` and ` x ` disjoint. See also ~ sbimd . (Contributed by Wolf Lammen, 6-May-2023.) Revise ~ df-sb . (Revised by Steven Nguyen, 6-Jul-2023.)","origin":"thm sbimdv(setvar s0, setvar s1, wff w0, wff w1, wff w2) {\n  |- wi(w0, wi(wsb(s0, s1, w1), wsb(s0, s1, w2)))\n  -| wi(w0, wi(w1, w2))\n  -| diffsw(s1, w0)\n} = {\n  syl(w0, wi(wsb(s0, s1, w1), wsb(s0, s1, w2)), wal(s1, wi(w1, w2)))\n  alrimiv(s1, w0, wi(w1, w2))\n  spsbim(s1, s0, w1, w2)\n}","pretty":"thm sbimdv(setvar s0, setvar s1, wff w0, wff w1, wff w2) {\n  ⊢ (w0 →([s0 / s1]w1 →[s0 / s1]w2))\n  ⊣ (w0 →(w1 → w2))\n  ⊣ d(s1, w0)\n} = {\n  syl(w0, ([s0 / s1]w1 →[s0 / s1]w2), ∀(s1,(w1 → w2)))\n  alrimiv(s1, w0, (w1 → w2))\n  spsbim(s1, s0, w1, w2)\n}","parent":["syl","alrimiv","spsbim"],"children":["sbbidvOLD"]},{"name":"sbbidv","content":"Deduction substituting both sides of a biconditional, with ` ph ` and ` x ` disjoint. See also ~ sbbid . (Contributed by Wolf Lammen, 6-May-2023.) (Proof shortened by Steven Nguyen, 6-Jul-2023.)","origin":"thm sbbidv(setvar s0, setvar s1, wff w0, wff w1, wff w2) {\n  |- wi(w0, wb(wsb(s0, s1, w1), wsb(s0, s1, w2)))\n  -| wi(w0, wb(w1, w2))\n  -| diffsw(s1, w0)\n} = {\n  syl(w0, wb(wsb(s0, s1, w1), wsb(s0, s1, w2)), wal(s1, wb(w1, w2)))\n  alrimiv(s1, w0, wb(w1, w2))\n  spsbbi(s1, s0, w1, w2)\n}","pretty":"thm sbbidv(setvar s0, setvar s1, wff w0, wff w1, wff w2) {\n  ⊢ (w0 →([s0 / s1]w1 ↔[s0 / s1]w2))\n  ⊣ (w0 →(w1 ↔ w2))\n  ⊣ d(s1, w0)\n} = {\n  syl(w0, ([s0 / s1]w1 ↔[s0 / s1]w2), ∀(s1,(w1 ↔ w2)))\n  alrimiv(s1, w0, (w1 ↔ w2))\n  spsbbi(s1, s0, w1, w2)\n}","parent":["syl","alrimiv","spsbbi"],"children":["sbcom2","abbi2dv","abbidv","wl-equsb3","wl-clabtv","2reu8i"]},{"name":"spsbe","content":"Existential generalization: if a proposition is true for a specific instance, then there exists an instance where it is true. (Contributed by NM, 29-Jun-1993.) (Proof shortened by Wolf Lammen, 3-May-2018.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) (Proof shortened by Steven Nguyen, 11-Jul-2023.)","origin":"thm spsbe(setvar s0, setvar s1, wff w0) {\n  |- wi(wsb(s0, s1, w0), wex(s1, w0))\n} = {\n  syl(wsb(s0, s1, w0), wex(s1, w0), wex(hs0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))))\n  sylbi(wsb(s0, s1, w0), wex(hs0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))))\n  df-sb(s0, s1, hs0, w0)\n  mpi(wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))), wex(hs0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))), wex(hs0, wceq(cv(hs0), cv(s0))))\n  ax6ev(hs0, s0)\n  exim(hs0, wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))\n  exsbim(hs0, s1, w0)\n  diffss.ex(s1, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n}","pretty":"thm spsbe(setvar s0, setvar s1, wff w0) {\n  ⊢ ([s0 / s1]w0 → ∃(s1, w0))\n} = {\n  syl([s0 / s1]w0, ∃(s1, w0), ∃(hs0, ∀(s1,(s1 = hs0 → w0))))\n  sylbi([s0 / s1]w0, ∃(hs0, ∀(s1,(s1 = hs0 → w0))), ∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w0)))))\n  df-sb(s0, s1, hs0, w0)\n  mpi(∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w0)))), ∃(hs0, ∀(s1,(s1 = hs0 → w0))), ∃(hs0, hs0 = s0))\n  ax6ev(hs0, s0)\n  exim(hs0, hs0 = s0, ∀(s1,(s1 = hs0 → w0)))\n  exsbim(hs0, s1, w0)\n  diffss.ex(s1, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n}","parent":["syl","sylbi","df-sb","mpi","ax6ev","exim","exsbim","diffss.ex","diff.hs0.w","diff.hs0.s"],"children":["sbv","sbft","2mo","noel","bj-ssbft","wl-lem-moexsb","nsb","spsbce-2","sb5ALT","sb5ALTVD"]},{"name":"spsbeOLD","content":"Obsolete version of ~ spsbe as of 11-Jul-2023. (Contributed by NM, 29-Jun-1993.) (Proof shortened by Wolf Lammen, 3-May-2018.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) (New usage is discouraged.) (Proof modification is discouraged.)","origin":"thm spsbeOLD(setvar s0, setvar s1, wff w0) {\n  |- wi(wsb(s0, s1, w0), wex(s1, w0))\n} = {\n  3syl(wsb(s0, s1, w0), wex(s1, w0), wex(hs0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))), wex(hs0, wi(wex(s1, wceq(cv(s1), cv(hs0))), wex(s1, w0))))\n  sylbi(wsb(s0, s1, w0), wex(hs0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))))\n  df-sb(s0, s1, hs0, w0)\n  mpi(wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))), wex(hs0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0))), wex(hs0, wceq(cv(hs0), cv(s0))))\n  ax6ev(hs0, s0)\n  exim(hs0, wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))\n  eximi(hs0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)), wi(wex(s1, wceq(cv(s1), cv(hs0))), wex(s1, w0)))\n  exim(s1, wceq(cv(s1), cv(hs0)), w0)\n  exlimiv(hs0, wi(wex(s1, wceq(cv(s1), cv(hs0))), wex(s1, w0)), wex(s1, w0))\n  ax-mp(wi(wi(wex(s1, wceq(cv(s1), cv(hs0))), wex(s1, w0)), wex(s1, w0)), wex(s1, wceq(cv(s1), cv(hs0))))\n  ax6ev(s1, hs0)\n  pm2.27(wex(s1, wceq(cv(s1), cv(hs0))), wex(s1, w0))\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s0)\n  diff.hs0.w(wex(s1, w0))\n}","pretty":"thm spsbeOLD(setvar s0, setvar s1, wff w0) {\n  ⊢ ([s0 / s1]w0 → ∃(s1, w0))\n} = {\n  3syl([s0 / s1]w0, ∃(s1, w0), ∃(hs0, ∀(s1,(s1 = hs0 → w0))), ∃(hs0,(∃(s1, s1 = hs0)→ ∃(s1, w0))))\n  sylbi([s0 / s1]w0, ∃(hs0, ∀(s1,(s1 = hs0 → w0))), ∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w0)))))\n  df-sb(s0, s1, hs0, w0)\n  mpi(∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w0)))), ∃(hs0, ∀(s1,(s1 = hs0 → w0))), ∃(hs0, hs0 = s0))\n  ax6ev(hs0, s0)\n  exim(hs0, hs0 = s0, ∀(s1,(s1 = hs0 → w0)))\n  eximi(hs0, ∀(s1,(s1 = hs0 → w0)), (∃(s1, s1 = hs0)→ ∃(s1, w0)))\n  exim(s1, s1 = hs0, w0)\n  exlimiv(hs0, (∃(s1, s1 = hs0)→ ∃(s1, w0)), ∃(s1, w0))\n  ax-mp(((∃(s1, s1 = hs0)→ ∃(s1, w0))→ ∃(s1, w0)), ∃(s1, s1 = hs0))\n  ax6ev(s1, hs0)\n  pm2.27(∃(s1, s1 = hs0), ∃(s1, w0))\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s0)\n  diff.hs0.w(∃(s1, w0))\n}","parent":["3syl","sylbi","df-sb","mpi","ax6ev","exim","eximi","exlimiv","ax-mp","pm2.27","diffss.ex","diff.hs0.s","diff.hs0.w"],"children":[]},{"name":"sbequ","content":"Equality property for substitution, from Tarski's system. Used in proof of Theorem 9.7 in [Megill] p. 449 (p. 16 of the preprint). (Contributed by NM, 14-May-1993.) Revise ~ df-sb . (Revised by BJ, 30-Dec-2020.)","origin":"thm sbequ(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wi(wceq(cv(s0), cv(s1)), wb(wsb(s0, s2, w0), wsb(s1, s2, w0)))\n} = {\n  3bitr4g(wceq(cv(s0), cv(s1)), wsb(s0, s2, w0), wsb(s1, s2, w0), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s2, wi(wceq(cv(s2), cv(hs0)), w0)))), wal(hs0, wi(wceq(cv(hs0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(hs0)), w0)))))\n  albidv(hs0, wceq(cv(s0), cv(s1)), wi(wceq(cv(hs0), cv(s0)), wal(s2, wi(wceq(cv(s2), cv(hs0)), w0))), wi(wceq(cv(hs0), cv(s1)), wal(s2, wi(wceq(cv(s2), cv(hs0)), w0))))\n  imbi1d(wceq(cv(s0), cv(s1)), wceq(cv(hs0), cv(s0)), wal(s2, wi(wceq(cv(s2), cv(hs0)), w0)), wceq(cv(hs0), cv(s1)))\n  equequ2(s0, s1, hs0)\n  df-sb(s0, s2, hs0, w0)\n  df-sb(s1, s2, hs0, w0)\n  diff.hs0.w(wceq(cv(s0), cv(s1)))\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(w0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","pretty":"thm sbequ(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ (s0 = s1 →([s0 / s2]w0 ↔[s1 / s2]w0))\n} = {\n  3bitr4g(s0 = s1, [s0 / s2]w0, [s1 / s2]w0, ∀(hs0,(hs0 = s0 → ∀(s2,(s2 = hs0 → w0)))), ∀(hs0,(hs0 = s1 → ∀(s2,(s2 = hs0 → w0)))))\n  albidv(hs0, s0 = s1, (hs0 = s0 → ∀(s2,(s2 = hs0 → w0))), (hs0 = s1 → ∀(s2,(s2 = hs0 → w0))))\n  imbi1d(s0 = s1, hs0 = s0, ∀(s2,(s2 = hs0 → w0)), hs0 = s1)\n  equequ2(s0, s1, hs0)\n  df-sb(s0, s2, hs0, w0)\n  df-sb(s1, s2, hs0, w0)\n  diff.hs0.w(s0 = s1)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(w0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","parent":["3bitr4g","albidv","imbi1d","equequ2","df-sb","diff.hs0.w","diffss.ex","diff.hs0.s"],"children":["sbequi","sbcom3vv","sbco2vv","sbco2v","drsb2","sbcom2","sbcom2OLD","sbcom3","sbco2","sb10f","sb8euv","sb8eu","cbvralf","cbvreu","cbvralsv","cbvrexsv","cbvrab","cbvreucsf","cbvrabcsf","cbvopab1","cbvmpt","cbviota","sb8iota","cbvriota","tfis","tfinds","findes","uzind4s","bj-cleljustab","wl-sbcom2d-lem1","wl-sb8eut","wl-dfclab","sbeqi","cleljust2","disjinfi","2reu8i"]},{"name":"sbequi","content":"An equality theorem for substitution. (Contributed by NM, 14-May-1993.) (Proof shortened by Wolf Lammen, 15-Sep-2018.) (Proof shortened by Steven Nguyen, 7-Jul-2023.)","origin":"thm sbequi(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wsb(s0, s2, w0), wsb(s1, s2, w0)))\n} = {\n  biimpd(wceq(cv(s0), cv(s1)), wsb(s0, s2, w0), wsb(s1, s2, w0))\n  sbequ(s0, s1, s2, w0)\n}","pretty":"thm sbequi(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ (s0 = s1 →([s0 / s2]w0 →[s1 / s2]w0))\n} = {\n  biimpd(s0 = s1, [s0 / s2]w0, [s1 / s2]w0)\n  sbequ(s0, s1, s2, w0)\n}","parent":["biimpd","sbequ"],"children":["sbequOLD"]},{"name":"sb6","content":"Alternate definition of substitution when variables are disjoint. Compare Theorem 6.2 of [Quine] p. 40. Also proved as Lemmas 16 and 17 of [Tarski] p. 70. The implication \"to the left\" also holds without a disjoint variable condition ( ~ sb2 ). Theorem ~ sb6f replaces the disjoint variable condition with a non-freeness hypothesis. Theorem ~ sb4b replaces it with a distinctor antecedent. (Contributed by NM, 18-Aug-1993.) (Proof shortened by Wolf Lammen, 21-Sep-2018.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) Remove use of ~ ax-11 . (Revised by Steven Nguyen, 7-Jul-2023.) (Proof shortened by Wolf Lammen, 16-Jul-2023.)","origin":"thm sb6(setvar s0, setvar s1, wff w0) {\n  |- wb(wsb(s0, s1, w0), wal(s1, wi(wceq(cv(s1), cv(s0)), w0)))\n  -| diffss(s0, s1)\n} = {\n  bitri(wsb(s0, s1, w0), wal(s1, wi(wceq(cv(s1), cv(s0)), w0)), wal(hs0, wi(wceq(cv(hs0), cv(s0)), wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)))))\n  df-sb(s0, s1, hs0, w0)\n  equsalvw(hs0, s0, wal(s1, wi(wceq(cv(s1), cv(hs0)), w0)), wal(s1, wi(wceq(cv(s1), cv(s0)), w0)))\n  albidv(s1, wceq(cv(hs0), cv(s0)), wi(wceq(cv(s1), cv(hs0)), w0), wi(wceq(cv(s1), cv(s0)), w0))\n  imbi1d(wceq(cv(hs0), cv(s0)), wceq(cv(s1), cv(hs0)), w0, wceq(cv(s1), cv(s0)))\n  equequ2(hs0, s0, s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s0)\n  diff.hs0.w(wal(s1, wi(wceq(cv(s1), cv(s0)), w0)))\n  diff.wceq.s(s1, cv(hs0), cv(s0))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm sb6(setvar s0, setvar s1, wff w0) {\n  ⊢ ([s0 / s1]w0 ↔ ∀(s1,(s1 = s0 → w0)))\n  ⊣ d(s0, s1)\n} = {\n  bitri([s0 / s1]w0, ∀(s1,(s1 = s0 → w0)), ∀(hs0,(hs0 = s0 → ∀(s1,(s1 = hs0 → w0)))))\n  df-sb(s0, s1, hs0, w0)\n  equsalvw(hs0, s0, ∀(s1,(s1 = hs0 → w0)), ∀(s1,(s1 = s0 → w0)))\n  albidv(s1, hs0 = s0, (s1 = hs0 → w0), (s1 = s0 → w0))\n  imbi1d(hs0 = s0, s1 = hs0, w0, s1 = s0)\n  equequ2(hs0, s0, s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.w(w0)\n  diff.hs0.s(s0)\n  diff.hs0.w(∀(s1,(s1 = s0 → w0)))\n  diff.wceq.s(s1, hs0, s0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["bitri","df-sb","equsalvw","albidv","imbi1d","equequ2","diffss.ex","diff.hs0.w","diff.hs0.s","diff.wceq.s","diff.cv.s"],"children":["sb4vOLD","sb2vOLD","sbievw","sbcom3vv","sb6a","sb5","2sb6","nfs1v","sbnvOLD","sbiev","sbequivvOLD","nfsbv","2sb8evOLD","2eu6","iota4","bj-ax12ssb","bj-hbs1","bj-hbsb2av","bj-sbievw1","bj-sbievw2","bj-sbievw","wl-lem-moexsb","wl-dfralsb","wl-dfrabsb","absnsb"]},{"name":"sb4vOLD","content":"Obsolete as of 30-Jul-2023. Use ~ sb6 instead. (Contributed by BJ, 23-Jun-2019.) (Proof shortened by Steven Nguyen, 8-Jul-2023.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm sb4vOLD(setvar s0, setvar s1, wff w0) {\n  |- wi(wsb(s0, s1, w0), wal(s1, wi(wceq(cv(s1), cv(s0)), w0)))\n  -| diffss(s0, s1)\n} = {\n  biimpi(wsb(s0, s1, w0), wal(s1, wi(wceq(cv(s1), cv(s0)), w0)))\n  sb6(s0, s1, w0)\n}","pretty":"thm sb4vOLD(setvar s0, setvar s1, wff w0) {\n  ⊢ ([s0 / s1]w0 → ∀(s1,(s1 = s0 → w0)))\n  ⊣ d(s0, s1)\n} = {\n  biimpi([s0 / s1]w0, ∀(s1,(s1 = s0 → w0)))\n  sb6(s0, s1, w0)\n}","parent":["biimpi","sb6"],"children":["sb6OLD","sbi1vOLD"]},{"name":"sb2vOLD","content":"Obsolete as of 30-Jul-2023. Use ~ sb6 instead. Version of ~ sb2 with a disjoint variable condition, which does not require ~ ax-13 . (Contributed by BJ, 31-May-2019.) Revise ~ df-sb . (Revised by Steven Nguyen, 8-Jul-2023.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm sb2vOLD(setvar s0, setvar s1, wff w0) {\n  |- wi(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), wsb(s1, s0, w0))\n  -| diffss(s0, s1)\n} = {\n  biimpri(wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), wsb(s1, s0, w0))\n  sb6(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","pretty":"thm sb2vOLD(setvar s0, setvar s1, wff w0) {\n  ⊢ (∀(s0,(s0 = s1 → w0))→[s1 / s0]w0)\n  ⊣ d(s0, s1)\n} = {\n  biimpri(∀(s0,(s0 = s1 → w0)), [s1 / s0]w0)\n  sb6(s1, s0, w0)\n  diffss.ex(s1, s0)\n}","parent":["biimpri","sb6","diffss.ex"],"children":["equsb1vOLD","sb6OLD","sbi1vOLD"]},{"name":"sbv","content":"Substitution for a variable not occurring in a proposition. See ~ sbf for a version without disjoint variable condition on ` x , ph ` . If one adds a disjoint variable condition on ` x , t ` , then ~ sbv can be proved directly by chaining ~ equsv with ~ sb6 . (Contributed by BJ, 22-Dec-2020.)","origin":"thm sbv(setvar s0, setvar s1, wff w0) {\n  |- wb(wsb(s0, s1, w0), w0)\n  -| diffsw(s1, w0)\n} = {\n  impbii(wsb(s0, s1, w0), w0)\n  syl(wsb(s0, s1, w0), w0, wex(s1, w0))\n  spsbe(s0, s1, w0)\n  ax5e(s1, w0)\n  syl(w0, wsb(s0, s1, w0), wal(s1, w0))\n  ax-5(s1, w0)\n  stdpc4(s1, s0, w0)\n}","pretty":"thm sbv(setvar s0, setvar s1, wff w0) {\n  ⊢ ([s0 / s1]w0 ↔ w0)\n  ⊣ d(s1, w0)\n} = {\n  impbii([s0 / s1]w0, w0)\n  syl([s0 / s1]w0, w0, ∃(s1, w0))\n  spsbe(s0, s1, w0)\n  ax5e(s1, w0)\n  syl(w0, [s0 / s1]w0, ∀(s1, w0))\n  ax-5(s1, w0)\n  stdpc4(s1, s0, w0)\n}","parent":["impbii","syl","spsbe","ax5e","ax-5","stdpc4"],"children":["sbievw2","sbcom4","iuninc","measiuns","ballotlemodife","bj-vjust","mptsnunlem"]},{"name":"sbievw","content":"Version of ~ sbiev with an extra DV condition, not requiring ~ ax-12 . (Contributed by BJ, 18-Jul-2023.)","origin":"thm sbievw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wsb(s0, s1, w0), w1)\n  -| wi(wceq(cv(s1), cv(s0)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s1, w1)\n} = {\n  bitri(wsb(s0, s1, w0), w1, wal(s1, wi(wceq(cv(s1), cv(s0)), w0)))\n  sb6(s0, s1, w0)\n  equsalvw(s1, s0, w0, w1)\n  diffss.ex(s1, s0)\n}","pretty":"thm sbievw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ ([s0 / s1]w0 ↔ w1)\n  ⊣ (s1 = s0 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, w1)\n} = {\n  bitri([s0 / s1]w0, w1, ∀(s1,(s1 = s0 → w0)))\n  sb6(s0, s1, w0)\n  equsalvw(s1, s0, w0, w1)\n  diffss.ex(s1, s0)\n}","parent":["bitri","sb6","equsalvw","diffss.ex"],"children":["sbievw2","2mos","clelsb3vOLD","cbvabv","sbcco2","sbcie2g","2reu8i","ichcircshi"]},{"name":"sbcom3vv","content":"Version of ~ sbcom3 with a disjoint variable condition using fewer axioms. (Contributed by BJ, 30-Dec-2020.) (Proof shortened by Wolf Lammen, 19-Jan-2023.)","origin":"thm sbcom3vv(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wsb(s0, s1, wsb(s1, s2, w0)), wsb(s0, s1, wsb(s0, s2, w0)))\n  -| diffss(s0, s1)\n} = {\n  3bitr4i(wsb(s0, s1, wsb(s1, s2, w0)), wsb(s0, s1, wsb(s0, s2, w0)), wal(s1, wi(wceq(cv(s1), cv(s0)), wsb(s1, s2, w0))), wal(s1, wi(wceq(cv(s1), cv(s0)), wsb(s0, s2, w0))))\n  albii(s1, wi(wceq(cv(s1), cv(s0)), wsb(s1, s2, w0)), wi(wceq(cv(s1), cv(s0)), wsb(s0, s2, w0)))\n  pm5.74i(wceq(cv(s1), cv(s0)), wsb(s1, s2, w0), wsb(s0, s2, w0))\n  sbequ(s1, s0, s2, w0)\n  sb6(s0, s1, wsb(s1, s2, w0))\n  sb6(s0, s1, wsb(s0, s2, w0))\n}","pretty":"thm sbcom3vv(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ ([s0 / s1][s1 / s2]w0 ↔[s0 / s1][s0 / s2]w0)\n  ⊣ d(s0, s1)\n} = {\n  3bitr4i([s0 / s1][s1 / s2]w0, [s0 / s1][s0 / s2]w0, ∀(s1,(s1 = s0 →[s1 / s2]w0)), ∀(s1,(s1 = s0 →[s0 / s2]w0)))\n  albii(s1, (s1 = s0 →[s1 / s2]w0), (s1 = s0 →[s0 / s2]w0))\n  pm5.74i(s1 = s0, [s1 / s2]w0, [s0 / s2]w0)\n  sbequ(s1, s0, s2, w0)\n  sb6(s0, s1, [s1 / s2]w0)\n  sb6(s0, s1, [s0 / s2]w0)\n}","parent":["3bitr4i","albii","pm5.74i","sbequ","sb6"],"children":["sbievw2","sbcov"]},{"name":"sbievw2","content":"~ sbievw applied twice, avoiding a DV condition on ` x ` , ` y ` . Based on proofs by Wolf Lammen. (Contributed by Steven Nguyen, 29-Jul-2023.)","origin":"thm sbievw2(setvar s0, setvar s1, setvar s2, wff w0, wff w1, wff w2) {\n  |- wb(wsb(s0, s1, w0), w1)\n  -| wi(wceq(cv(s1), cv(s2)), wb(w0, w2))\n  -| wi(wceq(cv(s2), cv(s0)), wb(w2, w1))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsw(s1, w2)\n  -| diffsw(s2, w0)\n  -| diffsw(s2, w1)\n} = {\n  bitr3i(wsb(s0, s1, w0), w1, wsb(s0, s2, w2))\n  3bitr3i(wsb(s0, s2, w2), wsb(s0, s1, w0), wsb(s0, s2, wsb(s2, s1, w0)), wsb(s0, s2, wsb(s0, s1, w0)))\n  sbcom3vv(s0, s2, s1, w0)\n  sbbii(s0, s2, wsb(s2, s1, w0), w2)\n  sbievw(s2, s1, w0, w2)\n  sbv(s0, s2, wsb(s0, s1, w0))\n  sbievw(s0, s2, w2, w1)\n  diff.wsb.s(s2, s0, s1, w0)\n  diffss.ex(s2, s0)\n  diffss.ex(s2, s1)\n}","pretty":"thm sbievw2(setvar s0, setvar s1, setvar s2, wff w0, wff w1, wff w2) {\n  ⊢ ([s0 / s1]w0 ↔ w1)\n  ⊣ (s1 = s2 →(w0 ↔ w2))\n  ⊣ (s2 = s0 →(w2 ↔ w1))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s1, w2)\n  ⊣ d(s2, w0)\n  ⊣ d(s2, w1)\n} = {\n  bitr3i([s0 / s1]w0, w1, [s0 / s2]w2)\n  3bitr3i([s0 / s2]w2, [s0 / s1]w0, [s0 / s2][s2 / s1]w0, [s0 / s2][s0 / s1]w0)\n  sbcom3vv(s0, s2, s1, w0)\n  sbbii(s0, s2, [s2 / s1]w0, w2)\n  sbievw(s2, s1, w0, w2)\n  sbv(s0, s2, [s0 / s1]w0)\n  sbievw(s0, s2, w2, w1)\n  diff.wsb.s(s2, s0, s1, w0)\n  diffss.ex(s2, s0)\n  diffss.ex(s2, s1)\n}","parent":["bitr3i","3bitr3i","sbcom3vv","sbbii","sbievw","sbv","diff.wsb.s","diffss.ex"],"children":["sbco2vv","equsb3","elsb3","elsb4","eqsb3","clelsb3","sbss"]},{"name":"sbco2vv","content":"Version of ~ sbco2 with disjoint variable conditions and fewer axioms. (Contributed by BJ, 22-Dec-2020.) (Proof shortened by Wolf Lammen, 29-Apr-2023.)","origin":"thm sbco2vv(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wsb(s0, s1, wsb(s1, s2, w0)), wsb(s0, s2, w0))\n  -| diffss(s1, s2)\n  -| diffsw(s1, w0)\n} = {\n  sbievw2(s0, s1, hs0, wsb(s1, s2, w0), wsb(s0, s2, w0), wsb(hs0, s2, w0))\n  sbequ(s1, hs0, s2, w0)\n  sbequ(hs0, s0, s2, w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wsb.s(s1, hs0, s2, w0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.hs0.w(wsb(s1, s2, w0))\n  diff.hs0.w(wsb(s0, s2, w0))\n}","pretty":"thm sbco2vv(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ ([s0 / s1][s1 / s2]w0 ↔[s0 / s2]w0)\n  ⊣ d(s1, s2)\n  ⊣ d(s1, w0)\n} = {\n  sbievw2(s0, s1, hs0, [s1 / s2]w0, [s0 / s2]w0, [hs0 / s2]w0)\n  sbequ(s1, hs0, s2, w0)\n  sbequ(hs0, s0, s2, w0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wsb.s(s1, hs0, s2, w0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.hs0.w([s1 / s2]w0)\n  diff.hs0.w([s0 / s2]w0)\n}","parent":["sbievw2","sbequ","diffss.ex","diff.hs0.s","diff.wsb.s","diff.hs0.w"],"children":["sbid2vw","clelsb3vOLD","cbvabv","wl-equsb3","wl-dfrabv","wl-dfrabf","2reu8i"]},{"name":"equsb3","content":"Substitution in an equality. (Contributed by Raph Levien and FL, 4-Dec-2005.) Reduce axiom usage. (Revised by Wolf Lammen, 23-Jul-2023.)","origin":"thm equsb3(setvar s0, setvar s1, setvar s2) {\n  |- wb(wsb(s0, s1, wceq(cv(s1), cv(s2))), wceq(cv(s0), cv(s2)))\n  -| diffss(s1, s2)\n} = {\n  sbievw2(s0, s1, hs0, wceq(cv(s1), cv(s2)), wceq(cv(s0), cv(s2)), wceq(cv(hs0), cv(s2)))\n  equequ1(s1, hs0, s2)\n  equequ1(hs0, s0, s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wceq.s(s1, cv(hs0), cv(s2))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.cv.s(s1, s2)\n  diff.hs0.w(wceq(cv(s1), cv(s2)))\n  diff.hs0.w(wceq(cv(s0), cv(s2)))\n}","pretty":"thm equsb3(setvar s0, setvar s1, setvar s2) {\n  ⊢ ([s0 / s1]s1 = s2 ↔ s0 = s2)\n  ⊣ d(s1, s2)\n} = {\n  sbievw2(s0, s1, hs0, s1 = s2, s0 = s2, hs0 = s2)\n  equequ1(s1, hs0, s2)\n  equequ1(hs0, s0, s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wceq.s(s1, hs0, s2)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.cv.s(s1, s2)\n  diff.hs0.w(s1 = s2)\n  diff.hs0.w(s0 = s2)\n}","parent":["sbievw2","equequ1","diffss.ex","diff.hs0.s","diff.wceq.s","diff.cv.s","diff.hs0.w"],"children":["equsb3r","equsb1v","mo3","mo3OLD","sb8eulem","sb8iota","mo5f","mptsnunlem","wl-equsb3","wl-mo3t","wl-sb8eut","wl-dfrmosb","frege55lem1b","sbeqal1","icheq"]},{"name":"equsb3r","content":"Substitution applied to the atomic wff with equality. Variant of ~ equsb3 . (Contributed by AV, 29-Jul-2023.)","origin":"thm equsb3r(setvar s0, setvar s1, setvar s2) {\n  |- wb(wsb(s0, s1, wceq(cv(s2), cv(s1))), wceq(cv(s2), cv(s0)))\n  -| diffss(s1, s2)\n} = {\n  3bitri(wsb(s0, s1, wceq(cv(s2), cv(s1))), wceq(cv(s2), cv(s0)), wsb(s0, s1, wceq(cv(s1), cv(s2))), wceq(cv(s0), cv(s2)))\n  sbbii(s0, s1, wceq(cv(s2), cv(s1)), wceq(cv(s1), cv(s2)))\n  equcom(s2, s1)\n  equsb3(s0, s1, s2)\n  equcom(s0, s2)\n}","pretty":"thm equsb3r(setvar s0, setvar s1, setvar s2) {\n  ⊢ ([s0 / s1]s2 = s1 ↔ s2 = s0)\n  ⊣ d(s1, s2)\n} = {\n  3bitri([s0 / s1]s2 = s1, s2 = s0, [s0 / s1]s1 = s2, s0 = s2)\n  sbbii(s0, s1, s2 = s1, s1 = s2)\n  equcom(s2, s1)\n  equsb3(s0, s1, s2)\n  equcom(s0, s2)\n}","parent":["3bitri","sbbii","equcom","equsb3"],"children":["icheq"]},{"name":"equsb1v","content":"Version of ~ equsb1 with a disjoint variable condition, which neither requires ~ ax-12 nor ~ ax-13 . (Contributed by BJ, 11-Sep-2019.) Remove dependencies on axioms. (Revised by Wolf Lammen, 30-May-2023.) (Proof shortened by Steven Nguyen, 19-Jun-2023.) Revise ~ df-sb . (Revised by Steven Nguyen, 11-Jul-2023.) (Proof shortened by Steven Nguyen, 22-Jul-2023.)","origin":"thm equsb1v(setvar s0, setvar s1) {\n  |- wsb(s0, s1, wceq(cv(s1), cv(s0)))\n  -| diffss(s0, s1)\n} = {\n  mpbir(wsb(s0, s1, wceq(cv(s1), cv(s0))), wceq(cv(s0), cv(s0)))\n  equid(s0)\n  equsb3(s0, s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm equsb1v(setvar s0, setvar s1) {\n  ⊢ [s0 / s1]s1 = s0\n  ⊣ d(s0, s1)\n} = {\n  mpbir([s0 / s1]s1 = s0, s0 = s0)\n  equid(s0)\n  equsb3(s0, s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["mpbir","equid","equsb3","diffss.ex"],"children":["sbievOLD","pm13.183","exss"]},{"name":"equsb1vOLD","content":"Obsolete version of ~ equsb1v as of 22-Jul-2023. Version of ~ equsb1 with a disjoint variable condition, which neither requires ~ ax-12 nor ~ ax-13 . (Contributed by BJ, 11-Sep-2019.) Remove dependencies on axioms. (Revised by Wolf Lammen, 30-May-2023.) (Proof shortened by Steven Nguyen, 19-Jun-2023.) Revise ~ df-sb . (Revised by Steven Nguyen, 11-Jul-2023.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm equsb1vOLD(setvar s0, setvar s1) {\n  |- wsb(s0, s1, wceq(cv(s1), cv(s0)))\n  -| diffss(s0, s1)\n} = {\n  mpg(s1, wsb(s0, s1, wceq(cv(s1), cv(s0))), wi(wceq(cv(s1), cv(s0)), wceq(cv(s1), cv(s0))))\n  sb2vOLD(s1, s0, wceq(cv(s1), cv(s0)))\n  id(wceq(cv(s1), cv(s0)))\n  diffss.ex(s1, s0)\n}","pretty":"thm equsb1vOLD(setvar s0, setvar s1) {\n  ⊢ [s0 / s1]s1 = s0\n  ⊣ d(s0, s1)\n} = {\n  mpg(s1, [s0 / s1]s1 = s0, (s1 = s0 → s1 = s0))\n  sb2vOLD(s1, s0, s1 = s0)\n  id(s1 = s0)\n  diffss.ex(s1, s0)\n}","parent":["mpg","sb2vOLD","id","diffss.ex"],"children":[]}]}