{"index":1167,"title":"Argument, multiplication and inverse","content":"Since one needs arguments in order to define multiplication in ` CCbar ` , and one needs complex multiplication in order to define arguments, it would be contrieved to construct a whole theory for a temporary multiplication (and temporary powers, then temporary logarithm, and finally temporary argument) before redefining the extended complex multiplication. Therefore, we adopt a two-step process, see ~ df-bj-mulc","blocks":[{"name":"carg","content":"Syntax for the argument of a nonzero extended complex number.","origin":"const class carg { Arg }","pretty":"","parent":[],"children":[]},{"name":"diff.carg.s","content":"","origin":"axiom diff.carg.s(setvar s0) {\n  |- diffsc(s0, carg)\n}","pretty":"axiom diff.carg.s(setvar s0) {\n  ⊢ d(s0, Arg)\n}","parent":[],"children":[]},{"name":"diff.carg.c","content":"","origin":"axiom diff.carg.c(class c0) {\n  |- diffcc(carg, c0)\n}","pretty":"axiom diff.carg.c(class c0) {\n  ⊢ d(Arg, c0)\n}","parent":[],"children":[]},{"name":"diff.carg.w","content":"","origin":"axiom diff.carg.w(wff w0) {\n  |- diffcw(carg, w0)\n}","pretty":"axiom diff.carg.w(wff w0) {\n  ⊢ d(Arg, w0)\n}","parent":[],"children":[]},{"name":"df-bj-arg","content":"Define the argument of a nonzero extended complex number. By convention, it has values in ` ( -u _pi , _pi ] ` . Another convention chooses ` [ 0 , 2 _pi ) ` but the present one simplifies formulas giving the argument as an arctangent. (Contributed by BJ, 22-Jun-2019.)","origin":"axiom df-bj-arg(setvar s0) {\n  |- wceq(carg, cmpt(s0, cdif(cccbar, csn(nat0)), cif(cfv(cim, cfv(clog, cv(s0))), cfv(c1st, cv(s0)), wcel(cv(s0), cc))))\n}","pretty":"axiom df-bj-arg(setvar s0) {\n  ⊢ Arg =(s0 ∈(CCbar \\ { 0 })↦ if(s0 ∈ ℂ,(Im `(log ` s0)),(1st ` s0)))\n}","parent":[],"children":[""]},{"name":"cmulc","content":"Syntax for the multiplication of extended complex numbers.","origin":"const class cmulc { .cc }","pretty":"","parent":[],"children":[]},{"name":"diff.cmulc.s","content":"","origin":"axiom diff.cmulc.s(setvar s0) {\n  |- diffsc(s0, cmulc)\n}","pretty":"axiom diff.cmulc.s(setvar s0) {\n  ⊢ d(s0, .cc)\n}","parent":[],"children":[]},{"name":"diff.cmulc.c","content":"","origin":"axiom diff.cmulc.c(class c0) {\n  |- diffcc(cmulc, c0)\n}","pretty":"axiom diff.cmulc.c(class c0) {\n  ⊢ d(.cc, c0)\n}","parent":[],"children":[]},{"name":"diff.cmulc.w","content":"","origin":"axiom diff.cmulc.w(wff w0) {\n  |- diffcw(cmulc, w0)\n}","pretty":"axiom diff.cmulc.w(wff w0) {\n  ⊢ d(.cc, w0)\n}","parent":[],"children":[]},{"name":"df-bj-mulc","content":"Define the multiplication of extended complex numbers and of the complex projective line (Riemann sphere). In our convention, a product with 0 is 0, even when the other factor is infinite. An alternate convention leaves products of 0 with an infinite number undefined since the multiplication is not continuous at these points. Note that our convention entails ` ( 0 / 0 ) = 0 ` (given ~ df-bj-invc ). Note that this definition uses ` x. ` and ` Arg ` and ` / ` . Indeed, it would be contrieved to bypass ordinary complex multiplication, and the present two-step definition looks like a good compromise. (Contributed by BJ, 22-Jun-2019.)","origin":"axiom df-bj-mulc(setvar s0) {\n  |- wceq(cmulc, cmpt(s0, cun(cxp(cccbar, cccbar), cxp(ccchat, ccchat)), cif(nat0, cif(cinfty, cif(co(cfv(c1st, cv(s0)), cmul, cfv(c2nd, cv(s0))), cfv(cinftyexpitau, co(co(cfv(carg, cfv(c1st, cv(s0))), caddcc, cfv(carg, cfv(c2nd, cv(s0)))), cdiv, ctau)), wcel(cv(s0), cxp(cc, cc))), wo(wceq(cfv(c1st, cv(s0)), cinfty), wceq(cfv(c2nd, cv(s0)), cinfty))), wo(wceq(cfv(c1st, cv(s0)), nat0), wceq(cfv(c2nd, cv(s0)), nat0)))))\n}","pretty":"axiom df-bj-mulc(setvar s0) {\n  ⊢ .cc =(s0 ∈((CCbar × CCbar)⋃(CChat × CChat))↦ if(((1st ` s0)= 0 ∨(2nd ` s0)= 0), 0, if(((1st ` s0)= infty ∨(2nd ` s0)= infty), infty, if(s0 ∈(ℂ × ℂ),((1st ` s0)[×](2nd ` s0)),(inftyexpitau `(((Arg `(1st ` s0))[+cc](Arg `(2nd ` s0)))[÷]τ))))))\n}","parent":[],"children":[""]},{"name":"cinvc","content":"Syntax for the inverse of nonzero extended complex numbers.","origin":"const class cinvc { invc }","pretty":"","parent":[],"children":[]},{"name":"diff.cinvc.s","content":"","origin":"axiom diff.cinvc.s(setvar s0) {\n  |- diffsc(s0, cinvc)\n}","pretty":"axiom diff.cinvc.s(setvar s0) {\n  ⊢ d(s0, invc)\n}","parent":[],"children":[]},{"name":"diff.cinvc.c","content":"","origin":"axiom diff.cinvc.c(class c0) {\n  |- diffcc(cinvc, c0)\n}","pretty":"axiom diff.cinvc.c(class c0) {\n  ⊢ d(invc, c0)\n}","parent":[],"children":[]},{"name":"diff.cinvc.w","content":"","origin":"axiom diff.cinvc.w(wff w0) {\n  |- diffcw(cinvc, w0)\n}","pretty":"axiom diff.cinvc.w(wff w0) {\n  ⊢ d(invc, w0)\n}","parent":[],"children":[]},{"name":"df-bj-invc","content":"Define inversion, which maps a nonzero extended complex number or element of the complex projective line (Riemann sphere) to its inverse. Beware of the overloading: the equality ` ( invc `` 0 ) = infty ` is to be understood in the complex projective line, but 0 as an extended complex number does not have an inverse, which we can state as ` ( invc `` 0 ) e/ CCbar ` . Note that this definition relies on ~ df-bj-mulc , which does not bypass ordinary complex multiplication, but defines extended complex multiplication on top of it. Therefore, we could have used directly ` / ` instead of ` ( iota_ ... .cc ... ) ` . (Contributed by BJ, 22-Jun-2019.)","origin":"axiom df-bj-invc(setvar s0, setvar s1) {\n  |- wceq(cinvc, cmpt(s0, cun(cccbar, ccchat), cif(cinfty, cif(crio(s1, cc, wceq(co(cv(s0), cmulc, cv(s1)), nat1)), nat0, wcel(cv(s0), cc)), wceq(cv(s0), nat0))))\n  -| diffss(s0, s1)\n}","pretty":"axiom df-bj-invc(setvar s0, setvar s1) {\n  ⊢ invc =(s0 ∈(CCbar ⋃ CChat)↦ if(s0 = 0, infty, if(s0 ∈ ℂ, iota(s1 ∈ ℂ,(s0[.cc]s1)= 1), 0)))\n  ⊣ d(s0, s1)\n}","parent":[],"children":[""]}]}