{"index":1582,"title":"Formal methods \"surprises\"","content":"Prove that some formal expressions using classical logic have meanings that might not be obvious to some lay readers. I find these are common mistakes and are worth pointing out to new people. In particular we prove ~ alimp-surprise , ~ empty-surprise , and ~ eximp-surprise .","blocks":[{"name":"alimp-surprise","content":"Demonstrate that when using \"for all\" and material implication the consequent can be both always true and always false if there is no case where the antecedent is true. Those inexperienced with formal notations of classical logic can be surprised with what \"for all\" and material implication do together when the implication's antecedent is never true. This can happen, for example, when the antecedent is set membership but the set is the empty set (e.g., ` x e. M ` and ` M = (/) ` ). This is perhaps best explained using an example. The sentence \"All Martians are green\" would typically be represented formally using the expression ` A. x ( ph -> ps ) ` . In this expression ` ph ` is true iff ` x ` is a Martian and ` ps ` is true iff ` x ` is green. Similarly, \"All Martians are not green\" would typically be represented as ` A. x ( ph -> -. ps ) ` . However, if there are no Martians ( ` -. E. x ph ` ), then both of those expressions are _true_. That is surprising to the inexperienced, because the two expressions seem to be the opposite of each other. The reason this occurs is because in classical logic the implication ` ( ph -> ps ) ` is equivalent to ` -. ph \\/ ps ` (as proven in ~ imor ). When ` ph ` is always false, ` -. ph ` is always true, and an _or_ with true is always true. Here are a few technical notes. In this notation, ` ph ` and ` ps ` are predicates that return a true or false value and may depend on ` x ` . We only say _may_ because it actually doesn't matter for our proof. In Metamath this simply means that we do not require that ` ph ` , ` ps ` , and ` x ` be distinct (so ` x ` can be part of ` ph ` or ` ps ` ). In natural language the term \"implies\" often presumes that the antecedent _can_ occur in at one least circumstance _and_ that there is some sort of causality. However, exactly what causality means is complex and situation-dependent. Modern logic typically uses material implication instead; this has a rigorous definition, but it is important for new users of formal notation to precisely understand it. There are ways to solve this, e.g., expressly stating that the antecedent exists (see ~ alimp-no-surprise ) or using the allsome quantifier ( ~ df-alsi ) . For other \"surprises\" for new users of classical logic, see ~ empty-surprise and ~ eximp-surprise . (Contributed by David A. Wheeler, 17-Oct-2018.)","origin":"thm alimp-surprise(setvar s0, wff w0, wff w1) {\n  |- wa(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))))\n  -| wn(wex(s0, w0))\n} = {\n  pm3.2i(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))))\n  mpgbir(s0, wal(s0, wi(w0, w1)), wo(wn(w0), w1))\n  albii(s0, wi(w0, w1), wo(wn(w0), w1))\n  imor(w0, w1)\n  orci(wn(w0), w1)\n  mpgbir(s0, wal(s0, wi(w0, wn(w1))), wo(wn(w0), wn(w1)))\n  albii(s0, wi(w0, wn(w1)), wo(wn(w0), wn(w1)))\n  imor(w0, wn(w1))\n  orci(wn(w0), wn(w1))\n  nexr(s0, w0)\n}","pretty":"thm alimp-surprise(setvar s0, wff w0, wff w1) {\n  ⊢ (∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1)))\n  ⊣ ¬ ∃(s0, w0)\n} = {\n  pm3.2i(∀(s0,(w0 → w1)), ∀(s0,(w0 → ¬ w1)))\n  mpgbir(s0, ∀(s0,(w0 → w1)), (¬ w0 ∨ w1))\n  albii(s0, (w0 → w1), (¬ w0 ∨ w1))\n  imor(w0, w1)\n  orci(¬ w0, w1)\n  mpgbir(s0, ∀(s0,(w0 → ¬ w1)), (¬ w0 ∨ ¬ w1))\n  albii(s0, (w0 → ¬ w1), (¬ w0 ∨ ¬ w1))\n  imor(w0, ¬ w1)\n  orci(¬ w0, ¬ w1)\n  nexr(s0, w0)\n}","parent":["pm3.2i","mpgbir","albii","imor","orci","nexr"],"children":["empty-surprise"]},{"name":"alimp-no-surprise","content":"There is no \"surprise\" in a for-all with implication if there exists a value where the antecedent is true. This is one way to prevent for-all with implication from allowing anything. For a contrast, see ~ alimp-surprise . The allsome quantifier also counters this problem, see ~ df-alsi . (Contributed by David A. Wheeler, 27-Oct-2018.)","origin":"thm alimp-no-surprise(setvar s0, wff w0, wff w1) {\n  |- wn(w3a(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))), wex(s0, w0)))\n} = {\n  mtbi(w3a(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))), wex(s0, w0)), wa(wal(s0, wa(wi(w0, w1), wi(w0, wn(w1)))), wex(s0, w0)))\n  mpbi(wn(wa(wal(s0, wa(wi(w0, w1), wi(w0, wn(w1)))), wex(s0, w0))), wi(wal(s0, wa(wi(w0, w1), wi(w0, wn(w1)))), wn(wex(s0, w0))))\n  sylbb(wal(s0, wa(wi(w0, w1), wi(w0, wn(w1)))), wn(wex(s0, w0)), wal(s0, wn(w0)))\n  albii(s0, wa(wi(w0, w1), wi(w0, wn(w1))), wn(w0))\n  pm4.82(w0, w1)\n  alnex(s0, w0)\n  imnan(wal(s0, wa(wi(w0, w1), wi(w0, wn(w1)))), wex(s0, w0))\n  3bitr2i(wa(wal(s0, wa(wi(w0, w1), wi(w0, wn(w1)))), wex(s0, w0)), w3a(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))), wex(s0, w0)), wa(wex(s0, w0), wa(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))))), w3a(wex(s0, w0), wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1)))))\n  anbi2ci(wal(s0, wa(wi(w0, w1), wi(w0, wn(w1)))), wex(s0, w0), wa(wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1)))))\n  19.26(s0, wi(w0, w1), wi(w0, wn(w1)))\n  3anass(wex(s0, w0), wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))))\n  3anrot(wex(s0, w0), wal(s0, wi(w0, w1)), wal(s0, wi(w0, wn(w1))))\n}","pretty":"thm alimp-no-surprise(setvar s0, wff w0, wff w1) {\n  ⊢ ¬(∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1))∧ ∃(s0, w0))\n} = {\n  mtbi((∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1))∧ ∃(s0, w0)), (∀(s0,((w0 → w1)∧(w0 → ¬ w1)))∧ ∃(s0, w0)))\n  mpbi(¬(∀(s0,((w0 → w1)∧(w0 → ¬ w1)))∧ ∃(s0, w0)), (∀(s0,((w0 → w1)∧(w0 → ¬ w1)))→ ¬ ∃(s0, w0)))\n  sylbb(∀(s0,((w0 → w1)∧(w0 → ¬ w1))), ¬ ∃(s0, w0), ∀(s0, ¬ w0))\n  albii(s0, ((w0 → w1)∧(w0 → ¬ w1)), ¬ w0)\n  pm4.82(w0, w1)\n  alnex(s0, w0)\n  imnan(∀(s0,((w0 → w1)∧(w0 → ¬ w1))), ∃(s0, w0))\n  3bitr2i((∀(s0,((w0 → w1)∧(w0 → ¬ w1)))∧ ∃(s0, w0)), (∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1))∧ ∃(s0, w0)), (∃(s0, w0)∧(∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1)))), (∃(s0, w0)∧ ∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1))))\n  anbi2ci(∀(s0,((w0 → w1)∧(w0 → ¬ w1))), ∃(s0, w0), (∀(s0,(w0 → w1))∧ ∀(s0,(w0 → ¬ w1))))\n  19.26(s0, (w0 → w1), (w0 → ¬ w1))\n  3anass(∃(s0, w0), ∀(s0,(w0 → w1)), ∀(s0,(w0 → ¬ w1)))\n  3anrot(∃(s0, w0), ∀(s0,(w0 → w1)), ∀(s0,(w0 → ¬ w1)))\n}","parent":["mtbi","mpbi","sylbb","albii","pm4.82","alnex","imnan","3bitr2i","anbi2ci","19.26","3anass","3anrot"],"children":["alsi-no-surprise"]},{"name":"empty-surprise","content":"Demonstrate that when using restricted \"for all\" over a class the expression can be both always true and always false if the class is empty. Those inexperienced with formal notations of classical logic can be surprised with what restricted \"for all\" does over an empty set. It is important to note that ` A. x e. A ph ` is simply an abbreviation for ` A. x ( x e. A -> ph ) ` (per ~ df-ral ). Thus, if ` A ` is the empty set, this expression is _always_ true regardless of the value of ` ph ` (see ~ alimp-surprise ). If you want the expression ` A. x e. A ph ` to not be vacuously true, you need to ensure that set ` A ` is inhabited (e.g., ` E. x e. A ` ). (Technical note: You can also assert that ` A =/= (/) ` ; this is an equivalent claim in classical logic as proven in ~ n0 , but in intuitionistic logic the statement ` A =/= (/) ` is a weaker claim than ` E. x e. A ` .) Some materials on logic (particularly those that discuss \"syllogisms\") are based on the much older work by Aristotle, but Aristotle expressly excluded empty sets from his system. Aristotle had a specific goal; he was trying to develop a \"companion-logic\" for science. He relegates fictions like fairy godmothers and mermaids and unicorns to the realms of poetry and literature... This is why he leaves no room for such nonexistent entities in his logic.\" (Groarke, \"Aristotle: Logic\", section 7. (Existential Assumptions), _Internet Encyclopedia of Philosophy_, ~ http://www.iep.utm.edu/aris-log/ ). While this made sense for his purposes, it is less flexible than modern (classical) logic which _does_ permit empty sets. If you wish to make claims that require a nonempty set, you must expressly include that requirement, e.g., by stating ` E. x ph ` . Examples of proofs that do this include ~ barbari , ~ celaront , and ~ cesaro . For another \"surprise\" for new users of classical logic, see ~ alimp-surprise and ~ eximp-surprise . (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"thm empty-surprise(setvar s0, class c0, wff w0) {\n  |- wral(s0, c0, w0)\n  -| wn(wex(s0, wcel(cv(s0), c0)))\n} = {\n  mpbir(wral(s0, c0, w0), wal(s0, wi(wcel(cv(s0), c0), w0)))\n  simpli(wal(s0, wi(wcel(cv(s0), c0), w0)), wal(s0, wi(wcel(cv(s0), c0), wn(w0))))\n  alimp-surprise(s0, wcel(cv(s0), c0), w0)\n  df-ral(s0, c0, w0)\n}","pretty":"thm empty-surprise(setvar s0, class c0, wff w0) {\n  ⊢ ∀(s0 ∈ c0, w0)\n  ⊣ ¬ ∃(s0, s0 ∈ c0)\n} = {\n  mpbir(∀(s0 ∈ c0, w0), ∀(s0,(s0 ∈ c0 → w0)))\n  simpli(∀(s0,(s0 ∈ c0 → w0)), ∀(s0,(s0 ∈ c0 → ¬ w0)))\n  alimp-surprise(s0, s0 ∈ c0, w0)\n  df-ral(s0, c0, w0)\n}","parent":["mpbir","simpli","alimp-surprise","df-ral"],"children":["empty-surprise2"]},{"name":"empty-surprise2","content":"\"Prove\" that false is true when using a restricted \"for all\" over the empty set, to demonstrate that the expression is always true if the value ranges over the empty set. Those inexperienced with formal notations of classical logic can be surprised with what restricted \"for all\" does over an empty set. We proved the general case in ~ empty-surprise . Here we prove an extreme example: we \"prove\" that false is true. Of course, we actually do no such thing (see ~ notfal ); the problem is that restricted \"for all\" works in ways that might seem counterintuitive to the inexperienced when given an empty set. Solutions to this can include requiring that the set not be empty or by using the allsome quantifier ~ df-alsc . (Contributed by David A. Wheeler, 20-Oct-2018.)","origin":"thm empty-surprise2(setvar s0, class c0) {\n  |- wral(s0, c0, wfal)\n  -| wn(wex(s0, wcel(cv(s0), c0)))\n} = {\n  empty-surprise(s0, c0, wfal)\n}","pretty":"thm empty-surprise2(setvar s0, class c0) {\n  ⊢ ∀(s0 ∈ c0, F)\n  ⊣ ¬ ∃(s0, s0 ∈ c0)\n} = {\n  empty-surprise(s0, c0, wfal)\n}","parent":["empty-surprise"],"children":[]},{"name":"eximp-surprise","content":"Show what implication inside \"there exists\" really expands to (using implication directly inside \"there exists\" is usually a mistake). Those inexperienced with formal notations of classical logic may use expressions combining \"there exists\" with implication. That is usually a mistake, because as proven using ~ imor , such an expression can be rewritten using _not_ with _or_ - and that is often not what the author intended. New users of formal notation who use \"there exists\" with an implication should consider if they meant \"and\" instead of \"implies\". A stark example is shown in ~ eximp-surprise2 . See also ~ alimp-surprise and ~ empty-surprise . (Contributed by David A. Wheeler, 17-Oct-2018.)","origin":"thm eximp-surprise(setvar s0, wff w0, wff w1) {\n  |- wb(wex(s0, wi(w0, w1)), wex(s0, wo(wn(w0), w1)))\n} = {\n  exbii(s0, wi(w0, w1), wo(wn(w0), w1))\n  imor(w0, w1)\n}","pretty":"thm eximp-surprise(setvar s0, wff w0, wff w1) {\n  ⊢ (∃(s0,(w0 → w1))↔ ∃(s0,(¬ w0 ∨ w1)))\n} = {\n  exbii(s0, (w0 → w1), (¬ w0 ∨ w1))\n  imor(w0, w1)\n}","parent":["exbii","imor"],"children":["eximp-surprise2"]},{"name":"eximp-surprise2","content":"Show that \"there exists\" with an implication is always true if there exists a situation where the antecedent is false. Those inexperienced with formal notations of classical logic may use expressions combining \"there exists\" with implication. This is usually a mistake, because that combination does not mean what an inexperienced person might think it means. For example, if there is some object that does not meet the precondition ` ph ` , then the expression ` E. x ( ph -> ps ) ` as a whole is always true, no matter what ` ps ` is ( ` ps ` could even be false, ` F. ` ). New users of formal notation who use \"there exists\" with an implication should consider if they meant \"and\" instead of \"implies\". See ~ eximp-surprise , which shows what implication really expands to. See also ~ empty-surprise . (Contributed by David A. Wheeler, 18-Oct-2018.)","origin":"thm eximp-surprise2(setvar s0, wff w0, wff w1) {\n  |- wex(s0, wi(w0, w1))\n  -| wex(s0, wn(w0))\n} = {\n  mpbir(wex(s0, wi(w0, w1)), wex(s0, wo(wn(w0), w1)))\n  eximii(s0, wo(wn(w0), w1), wn(w0))\n  orc(wn(w0), w1)\n  eximp-surprise(s0, w0, w1)\n}","pretty":"thm eximp-surprise2(setvar s0, wff w0, wff w1) {\n  ⊢ ∃(s0,(w0 → w1))\n  ⊣ ∃(s0, ¬ w0)\n} = {\n  mpbir(∃(s0,(w0 → w1)), ∃(s0,(¬ w0 ∨ w1)))\n  eximii(s0, (¬ w0 ∨ w1), ¬ w0)\n  orc(¬ w0, w1)\n  eximp-surprise(s0, w0, w1)\n}","parent":["mpbir","eximii","orc","eximp-surprise"],"children":[]}]}