{"index":1579,"title":"Formally define terms such as Reflexivity","content":"EXPERIMENTAL. Several terms are used in comments but not directly defined in set.mm. For example, there are proofs that a number of specific relations are reflexive, but there is no formal definition of what being reflexive actually *means*. Stating the relationships directly, instead of defining a broader property such as being reflexive, can reduce proof size (because the definition of that property does not need to be expanded later). A disadvantage, however, is that there are several terms that are widely used in comments but do not have a clear formal definition. Here we define wffs that formally define some of these key terms. The intent isn't to use these directly, but to instead provide a clear formal definition of widely-used mathematical terminology (we even use this terminology within the comments of set.mm itself). We could define these using extensible structures, but doing so appears overly restrictive. These definitions don't require the use of extensible structures; requiring something to be in an extensible structure to use them is too restrictive. Even if an extensible structure is already in use, it may in use for other things. For example, in geometry, there is a \"less-than\" relation, but while the geometry itself is an extensible structure, we would have to build a new structure to state \"the geometric less-than relation is transitive\" (which is more work than it's probably worth). By creating definitions that aren't tied to extensible structures we create definitions that can be applied to anything, including extensible structures, in whatever way we'd like. Benoit suggests that it might be better to define these as functions. There are many advantages to doing that, but they won't work for proper classes. I'm currently trying to also support proper classes, so I have not taken that approach, but if that turns out to be unreasonable then Benoit's approach is very much worth considering. Examples would be: BinRel = ` ( x e. _V |-> { r | r C_ ( x X. x ) } ) ` , ReflBinRel = ` ( x e. _V |-> { r e. ( ` BinRel ` `` x ) | ( Diag `` x ) C_ r } ) ` , and IrreflBinRel = ` ( x e. _V |-> { r e. ( ` BinRel ` `` x ) | ( r i^i ( Diag `` x ) ) = (/) } ) ` . For more discussion see: https://github.com/metamath/set.mm/pull/1286","blocks":[{"name":"wreflexive","content":"Extend wff definition to include \"Reflexive\" applied to a class, which is true iff class R is a reflexive relation over the set A. See ~ df-reflexive . (Contributed by David A. Wheeler, 1-Dec-2019.)","origin":"prop wff wreflexive(class c0, class c1) { c0[Reflexive]c1 }","pretty":"","parent":[],"children":[]},{"name":"diff.wreflexive.s","content":"","origin":"axiom diff.wreflexive.s(setvar sBase, class c0, class c1) {\n  |- diffsw(sBase, wreflexive(c0, c1))\n  -| diffsc(sBase, c0)\n  -| diffsc(sBase, c1)\n}","pretty":"axiom diff.wreflexive.s(setvar sBase, class c0, class c1) {\n  ⊢ d(sBase, c0[Reflexive]c1)\n  ⊣ d(sBase, c0)\n  ⊣ d(sBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wreflexive.c","content":"","origin":"axiom diff.wreflexive.c(class cBase, class c0, class c1) {\n  |- diffcw(cBase, wreflexive(c0, c1))\n  -| diffcc(cBase, c0)\n  -| diffcc(cBase, c1)\n}","pretty":"axiom diff.wreflexive.c(class cBase, class c0, class c1) {\n  ⊢ d(cBase, c0[Reflexive]c1)\n  ⊣ d(cBase, c0)\n  ⊣ d(cBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wreflexive.w","content":"","origin":"axiom diff.wreflexive.w(wff wBase, class c0, class c1) {\n  |- diffww(wBase, wreflexive(c0, c1))\n  -| diffcw(c0, wBase)\n  -| diffcw(c1, wBase)\n}","pretty":"axiom diff.wreflexive.w(wff wBase, class c0, class c1) {\n  ⊢ d(wBase, c0[Reflexive]c1)\n  ⊣ d(c0, wBase)\n  ⊣ d(c1, wBase)\n}","parent":[],"children":[]},{"name":"df-reflexive","content":"Define reflexive relation; relation ` R ` is reflexive over the set ` A ` iff ` A. x e. A x R x ` . (Contributed by David A. Wheeler, 1-Dec-2019.)","origin":"axiom df-reflexive(setvar s0, class c0, class c1) {\n  |- wb(wreflexive(c0, c1), wa(wss(c0, cxp(c1, c1)), wral(s0, c1, wbr(cv(s0), c0, cv(s0)))))\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c0)\n}","pretty":"axiom df-reflexive(setvar s0, class c0, class c1) {\n  ⊢ (c0[Reflexive]c1 ↔(c0 ⊆(c1 × c1)∧ ∀(s0 ∈ c1, s0[c0]s0)))\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c0)\n}","parent":[],"children":[""]},{"name":"wirreflexive","content":"Extend wff definition to include \"Irreflexive\" applied to a class, which is true iff class R is an irreflexive relation over the set A. See ~ df-irreflexive . (Contributed by David A. Wheeler, 1-Dec-2019.)","origin":"prop wff wirreflexive(class c0, class c1) { c0[Irreflexive]c1 }","pretty":"","parent":[],"children":[]},{"name":"diff.wirreflexive.s","content":"","origin":"axiom diff.wirreflexive.s(setvar sBase, class c0, class c1) {\n  |- diffsw(sBase, wirreflexive(c0, c1))\n  -| diffsc(sBase, c0)\n  -| diffsc(sBase, c1)\n}","pretty":"axiom diff.wirreflexive.s(setvar sBase, class c0, class c1) {\n  ⊢ d(sBase, c0[Irreflexive]c1)\n  ⊣ d(sBase, c0)\n  ⊣ d(sBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wirreflexive.c","content":"","origin":"axiom diff.wirreflexive.c(class cBase, class c0, class c1) {\n  |- diffcw(cBase, wirreflexive(c0, c1))\n  -| diffcc(cBase, c0)\n  -| diffcc(cBase, c1)\n}","pretty":"axiom diff.wirreflexive.c(class cBase, class c0, class c1) {\n  ⊢ d(cBase, c0[Irreflexive]c1)\n  ⊣ d(cBase, c0)\n  ⊣ d(cBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wirreflexive.w","content":"","origin":"axiom diff.wirreflexive.w(wff wBase, class c0, class c1) {\n  |- diffww(wBase, wirreflexive(c0, c1))\n  -| diffcw(c0, wBase)\n  -| diffcw(c1, wBase)\n}","pretty":"axiom diff.wirreflexive.w(wff wBase, class c0, class c1) {\n  ⊢ d(wBase, c0[Irreflexive]c1)\n  ⊣ d(c0, wBase)\n  ⊣ d(c1, wBase)\n}","parent":[],"children":[]},{"name":"df-irreflexive","content":"Define irreflexive relation; relation ` R ` is irreflexive over the set ` A ` iff ` A. x e. A -. x R x ` . Note that a relation can be neither reflexive nor irreflexive. (Contributed by David A. Wheeler, 1-Dec-2019.)","origin":"axiom df-irreflexive(setvar s0, class c0, class c1) {\n  |- wb(wirreflexive(c0, c1), wa(wss(c0, cxp(c1, c1)), wral(s0, c1, wn(wbr(cv(s0), c0, cv(s0))))))\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c0)\n}","pretty":"axiom df-irreflexive(setvar s0, class c0, class c1) {\n  ⊢ (c0[Irreflexive]c1 ↔(c0 ⊆(c1 × c1)∧ ∀(s0 ∈ c1, ¬ s0[c0]s0)))\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c0)\n}","parent":[],"children":[""]}]}