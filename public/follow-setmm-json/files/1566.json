{"index":1566,"title":"Examples and properties of set recursion","content":"","blocks":[{"name":"elsetrecslem","content":"Lemma for ~ elsetrecs . Any element of ` setrecs ( F ) ` is generated by some subset of ` setrecs ( F ) ` . This is much weaker than ~ setrec2v . To see why this lemma also requires ~ setrec1 , consider what would happen if we replaced ` B ` with ` { A } ` . The antecedent would still hold, but the consequent would fail in general. Consider dispensing with the deduction form. (Contributed by Emmett Weisz, 11-Jul-2021.) (New usage is discouraged.)","origin":"thm elsetrecslem(setvar s0, class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))\n  -| wceq(c1, csetrecs(c2))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n} = {\n  sylibr(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))), wn(wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))))\n  nsyl(wcel(c0, c1), wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))), wss(c1, cdif(c1, csn(c0))))\n  con2i(wcel(c0, c1), wss(c1, cdif(c1, csn(c0))))\n  simprbi(wss(c1, cdif(c1, csn(c0))), wn(wcel(c0, c1)), wss(c1, c1))\n  ssdifsn(c1, c1, c0)\n  setrec2v(hs0, c1, cdif(c1, csn(c0)), c2, wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))))\n  alrimiv(hs0, wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))), wi(wss(cv(hs0), cdif(c1, csn(c0))), wss(cfv(c2, cv(hs0)), cdif(c1, csn(c0)))))\n  syl(wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))), wi(wss(cv(hs0), cdif(c1, csn(c0))), wss(cfv(c2, cv(hs0)), cdif(c1, csn(c0)))), wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))))\n  spv(s0, hs0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))), wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))))\n  notbid(wceq(cv(s0), cv(hs0)), wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))), wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0)))))\n  anbi12d(wceq(cv(s0), cv(hs0)), wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))), wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))\n  sseq1(cv(s0), cv(hs0), c1)\n  eleq2d(c0, cfv(c2, cv(s0)), cfv(c2, cv(hs0)), wceq(cv(s0), cv(hs0)))\n  fveq2(cv(s0), cv(hs0), c2)\n  3imtr4g(wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))), wss(cv(hs0), cdif(c1, csn(c0))), wss(cfv(c2, cv(hs0)), cdif(c1, csn(c0))), wa(wss(cv(hs0), c1), wn(wcel(c0, cv(hs0)))), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  adantrd(wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))), wss(cv(hs0), c1), wn(wcel(c0, cv(hs0))), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  sylbir(wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))), wi(wss(cv(hs0), c1), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0)))))), wi(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  imnan(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))\n  a2i(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0)))), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  jctild(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0)))), wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0)))))\n  idd(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0)))))\n  setrec1(c2, cv(hs0), c1, wss(cv(hs0), c1))\n  a1i(wss(cv(hs0), c1), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), c1))\n  ssdifsn(cv(hs0), c1, c0)\n  ssdifsn(cfv(c2, cv(hs0)), c1, c0)\n  df-ex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))\n  diff.hs0.c(cdif(c1, csn(c0)))\n  diff.hs0.c(c2)\n  diff.hs0.w(wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))))\n  diff.wn.s(s0, wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0)))))\n  diff.wa.s(s0, wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))\n  diff.wss.s(s0, cv(hs0), c1)\n  diff.wcel.s(s0, c0, cfv(c2, cv(hs0)))\n  diff.cfv.s(s0, c2, cv(hs0))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm elsetrecslem(setvar s0, class c0, class c1, class c2) {\n  ⊢ (c0 ∈ c1 → ∃(s0,(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))))\n  ⊣ c1 = setrecs(c2)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c2)\n} = {\n  sylibr(c0 ∈ c1, ∃(s0,(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))), ¬ ∀(s0, ¬(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))))\n  nsyl(c0 ∈ c1, ∀(s0, ¬(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))), c1 ⊆(c1 \\ { c0 }))\n  con2i(c0 ∈ c1, c1 ⊆(c1 \\ { c0 }))\n  simprbi(c1 ⊆(c1 \\ { c0 }), ¬ c0 ∈ c1, c1 ⊆ c1)\n  ssdifsn(c1, c1, c0)\n  setrec2v(hs0, c1, (c1 \\ { c0 }), c2, ∀(s0, ¬(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))))\n  alrimiv(hs0, ∀(s0, ¬(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))), (hs0 ⊆(c1 \\ { c0 })→(c2 ` hs0)⊆(c1 \\ { c0 })))\n  syl(∀(s0, ¬(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))), (hs0 ⊆(c1 \\ { c0 })→(c2 ` hs0)⊆(c1 \\ { c0 })), ¬(hs0 ⊆ c1 ∧ c0 ∈(c2 ` hs0)))\n  spv(s0, hs0, ¬(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0)), ¬(hs0 ⊆ c1 ∧ c0 ∈(c2 ` hs0)))\n  notbid(s0 = hs0, (s0 ⊆ c1 ∧ c0 ∈(c2 ` s0)), (hs0 ⊆ c1 ∧ c0 ∈(c2 ` hs0)))\n  anbi12d(s0 = hs0, s0 ⊆ c1, c0 ∈(c2 ` s0), hs0 ⊆ c1, c0 ∈(c2 ` hs0))\n  sseq1(s0, hs0, c1)\n  eleq2d(c0, (c2 ` s0), (c2 ` hs0), s0 = hs0)\n  fveq2(s0, hs0, c2)\n  3imtr4g(¬(hs0 ⊆ c1 ∧ c0 ∈(c2 ` hs0)), hs0 ⊆(c1 \\ { c0 }), (c2 ` hs0)⊆(c1 \\ { c0 }), (hs0 ⊆ c1 ∧ ¬ c0 ∈ hs0), ((c2 ` hs0)⊆ c1 ∧ ¬ c0 ∈(c2 ` hs0)))\n  adantrd(¬(hs0 ⊆ c1 ∧ c0 ∈(c2 ` hs0)), hs0 ⊆ c1, ¬ c0 ∈ hs0, ((c2 ` hs0)⊆ c1 ∧ ¬ c0 ∈(c2 ` hs0)))\n  sylbir(¬(hs0 ⊆ c1 ∧ c0 ∈(c2 ` hs0)), (hs0 ⊆ c1 →((c2 ` hs0)⊆ c1 ∧ ¬ c0 ∈(c2 ` hs0))), (hs0 ⊆ c1 → ¬ c0 ∈(c2 ` hs0)))\n  imnan(hs0 ⊆ c1, c0 ∈(c2 ` hs0))\n  a2i(hs0 ⊆ c1, ¬ c0 ∈(c2 ` hs0), ((c2 ` hs0)⊆ c1 ∧ ¬ c0 ∈(c2 ` hs0)))\n  jctild(hs0 ⊆ c1, ¬ c0 ∈(c2 ` hs0), (c2 ` hs0)⊆ c1, ¬ c0 ∈(c2 ` hs0))\n  idd(hs0 ⊆ c1, ¬ c0 ∈(c2 ` hs0))\n  setrec1(c2, hs0, c1, hs0 ⊆ c1)\n  a1i(hs0 ⊆ c1, hs0 ∈ 𝕌)\n  vex(hs0)\n  id(hs0 ⊆ c1)\n  ssdifsn(hs0, c1, c0)\n  ssdifsn((c2 ` hs0), c1, c0)\n  df-ex(s0, (s0 ⊆ c1 ∧ c0 ∈(c2 ` s0)))\n  diff.hs0.c((c1 \\ { c0 }))\n  diff.hs0.c(c2)\n  diff.hs0.w(∀(s0, ¬(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))))\n  diff.wn.s(s0, (hs0 ⊆ c1 ∧ c0 ∈(c2 ` hs0)))\n  diff.wa.s(s0, hs0 ⊆ c1, c0 ∈(c2 ` hs0))\n  diff.wss.s(s0, hs0, c1)\n  diff.wcel.s(s0, c0, (c2 ` hs0))\n  diff.cfv.s(s0, c2, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["sylibr","nsyl","con2i","simprbi","ssdifsn","setrec2v","alrimiv","syl","spv","notbid","anbi12d","sseq1","eleq2d","fveq2","3imtr4g","adantrd","sylbir","imnan","a2i","jctild","idd","setrec1","a1i","vex","id","df-ex","diff.hs0.c","diff.hs0.w","diff.wn.s","diff.wa.s","diff.wss.s","diff.wcel.s","diff.cfv.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":["elsetrecs"]},{"name":"elsetrecs","content":"A set ` A ` is an element of ` setrecs ( F ) ` iff ` A ` is generated by some subset of ` setrecs ( F ) ` . The proof requires both ~ setrec1 and ~ setrec2 , but this theorem is not strong enough to uniquely determine ` setrecs ( F ) ` . If ` F ` respects the subset relation, the theorem still holds if both occurrences of ` e. ` are replaced by ` C_ ` for a stronger version of the theorem. (Contributed by Emmett Weisz, 12-Jul-2021.)","origin":"thm elsetrecs(setvar s0, class c0, class c1, class c2) {\n  |- wb(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))\n  -| wceq(c1, csetrecs(c2))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n} = {\n  impbii(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))\n  elsetrecslem(s0, c0, c1, c2)\n  exlimiv(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))), wcel(c0, c1))\n  sselda(c0, cfv(c2, cv(s0)), c1, wss(cv(s0), c1))\n  setrec1(c2, cv(s0), c1, wss(cv(s0), c1))\n  a1i(wss(cv(s0), c1), wcel(cv(s0), universe))\n  vex(s0)\n  id(wss(cv(s0), c1))\n  diff.wcel.s(s0, c0, c1)\n}","pretty":"thm elsetrecs(setvar s0, class c0, class c1, class c2) {\n  ⊢ (c0 ∈ c1 ↔ ∃(s0,(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))))\n  ⊣ c1 = setrecs(c2)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c2)\n} = {\n  impbii(c0 ∈ c1, ∃(s0,(s0 ⊆ c1 ∧ c0 ∈(c2 ` s0))))\n  elsetrecslem(s0, c0, c1, c2)\n  exlimiv(s0, (s0 ⊆ c1 ∧ c0 ∈(c2 ` s0)), c0 ∈ c1)\n  sselda(c0, (c2 ` s0), c1, s0 ⊆ c1)\n  setrec1(c2, s0, c1, s0 ⊆ c1)\n  a1i(s0 ⊆ c1, s0 ∈ 𝕌)\n  vex(s0)\n  id(s0 ⊆ c1)\n  diff.wcel.s(s0, c0, c1)\n}","parent":["impbii","elsetrecslem","exlimiv","sselda","setrec1","a1i","vex","id","diff.wcel.s"],"children":["elpg"]},{"name":"setrecsss","content":"The ` setrecs ` operator respects the subset relation between two functions ` F ` and ` G ` . (Contributed by Emmett Weisz, 13-Mar-2022.)","origin":"thm setrecsss(class c0, class c1, wff w0) {\n  |- wi(w0, wss(csetrecs(c0), csetrecs(c1)))\n  -| wi(w0, wfun(c1))\n  -| wi(w0, wss(c0, c1))\n} = {\n  setrec2v(hs0, csetrecs(c0), csetrecs(c1), c0, w0)\n  eqid(csetrecs(c0))\n  alrimiv(hs0, w0, wi(wss(cv(hs0), csetrecs(c1)), wss(cfv(c0, cv(hs0)), csetrecs(c1))))\n  ex(w0, wss(cv(hs0), csetrecs(c1)), wss(cfv(c0, cv(hs0)), csetrecs(c1)))\n  sstrd(cfv(c0, cv(hs0)), csetrecs(c1), cfv(c1, cv(hs0)), wa(w0, wss(cv(hs0), csetrecs(c1))))\n  adantr(w0, wss(cv(hs0), csetrecs(c1)), wss(cfv(c0, cv(hs0)), cfv(c1, cv(hs0))))\n  3sstr4d(cfv(c0, cv(hs0)), cfv(c1, cv(hs0)), cuni(cima(c0, csn(cv(hs0)))), cuni(cima(c1, csn(cv(hs0)))), w0)\n  unissd(cima(c0, csn(cv(hs0))), cima(c1, csn(cv(hs0))), w0)\n  syl(w0, wss(cima(c0, csn(cv(hs0))), cima(c1, csn(cv(hs0)))), wss(c0, c1))\n  imass1(c0, c1, csn(cv(hs0)))\n  syl(w0, wceq(cfv(c0, cv(hs0)), cuni(cima(c0, csn(cv(hs0))))), wfun(c0))\n  sylc(w0, wfun(c0), wss(c0, c1), wfun(c1))\n  funss(c0, c1)\n  funfv(c0, cv(hs0))\n  syl(w0, wceq(cfv(c1, cv(hs0)), cuni(cima(c1, csn(cv(hs0))))), wfun(c1))\n  funfv(c1, cv(hs0))\n  setrec1(c1, cv(hs0), csetrecs(c1), wa(w0, wss(cv(hs0), csetrecs(c1))))\n  eqid(csetrecs(c1))\n  a1i(wa(w0, wss(cv(hs0), csetrecs(c1))), wcel(cv(hs0), universe))\n  vex(hs0)\n  simpr(w0, wss(cv(hs0), csetrecs(c1)))\n  diff.hs0.c(csetrecs(c1))\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","pretty":"thm setrecsss(class c0, class c1, wff w0) {\n  ⊢ (w0 → setrecs(c0)⊆ setrecs(c1))\n  ⊣ (w0 → Fun(c1))\n  ⊣ (w0 → c0 ⊆ c1)\n} = {\n  setrec2v(hs0, setrecs(c0), setrecs(c1), c0, w0)\n  eqid(setrecs(c0))\n  alrimiv(hs0, w0, (hs0 ⊆ setrecs(c1)→(c0 ` hs0)⊆ setrecs(c1)))\n  ex(w0, hs0 ⊆ setrecs(c1), (c0 ` hs0)⊆ setrecs(c1))\n  sstrd((c0 ` hs0), setrecs(c1), (c1 ` hs0), (w0 ∧ hs0 ⊆ setrecs(c1)))\n  adantr(w0, hs0 ⊆ setrecs(c1), (c0 ` hs0)⊆(c1 ` hs0))\n  3sstr4d((c0 ` hs0), (c1 ` hs0), ⋃(c0 \" { hs0 }), ⋃(c1 \" { hs0 }), w0)\n  unissd((c0 \" { hs0 }), (c1 \" { hs0 }), w0)\n  syl(w0, (c0 \" { hs0 })⊆(c1 \" { hs0 }), c0 ⊆ c1)\n  imass1(c0, c1, { hs0 })\n  syl(w0, (c0 ` hs0)= ⋃(c0 \" { hs0 }), Fun(c0))\n  sylc(w0, Fun(c0), c0 ⊆ c1, Fun(c1))\n  funss(c0, c1)\n  funfv(c0, hs0)\n  syl(w0, (c1 ` hs0)= ⋃(c1 \" { hs0 }), Fun(c1))\n  funfv(c1, hs0)\n  setrec1(c1, hs0, setrecs(c1), (w0 ∧ hs0 ⊆ setrecs(c1)))\n  eqid(setrecs(c1))\n  a1i((w0 ∧ hs0 ⊆ setrecs(c1)), hs0 ∈ 𝕌)\n  vex(hs0)\n  simpr(w0, hs0 ⊆ setrecs(c1))\n  diff.hs0.c(setrecs(c1))\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","parent":["setrec2v","eqid","alrimiv","ex","sstrd","adantr","3sstr4d","unissd","syl","imass1","sylc","funss","funfv","setrec1","a1i","vex","simpr","diff.hs0.c","diff.hs0.w"],"children":["setrecsres"]},{"name":"setrecsres","content":"A recursively generated class is unaffected when its input function is restricted to subsets of the class. (Contributed by Emmett Weisz, 14-Mar-2022.)","origin":"thm setrecsres(class c0, class c1, wff w0) {\n  |- wi(w0, wceq(c0, csetrecs(cres(c1, cpw(c0)))))\n  -| wceq(c0, csetrecs(c1))\n  -| wi(w0, wfun(c1))\n} = {\n  eqssd(c0, csetrecs(cres(c1, cpw(c0))), w0)\n  setrec2v(hs0, c0, csetrecs(cres(c1, cpw(c0))), c1, w0)\n  alrimiv(hs0, w0, wi(wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wss(cfv(c1, cv(hs0)), csetrecs(cres(c1, cpw(c0))))))\n  ex(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wss(cfv(c1, cv(hs0)), csetrecs(cres(c1, cpw(c0)))))\n  eqsstr3d(cfv(c1, cv(hs0)), csetrecs(cres(c1, cpw(c0))), cfv(cres(c1, cpw(c0)), cv(hs0)), wa(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0))))))\n  syl(wa(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0))))), wceq(cfv(cres(c1, cpw(c0)), cv(hs0)), cfv(c1, cv(hs0))), wss(cv(hs0), c0))\n  sylan9ssr(cv(hs0), c0, csetrecs(cres(c1, cpw(c0))), w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))))\n  sylbir(wss(cv(hs0), c0), wceq(cfv(cres(c1, cpw(c0)), cv(hs0)), cfv(c1, cv(hs0))), wcel(cv(hs0), cpw(c0)))\n  selpw(hs0, c0)\n  fvres(cv(hs0), cpw(c0), c1)\n  adantl(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wss(cfv(cres(c1, cpw(c0)), cv(hs0)), csetrecs(cres(c1, cpw(c0)))))\n  setrec1(cres(c1, cpw(c0)), cv(hs0), csetrecs(cres(c1, cpw(c0))), wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))))\n  eqid(csetrecs(cres(c1, cpw(c0))))\n  a1i(wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))))\n  syl6sseqr(csetrecs(cres(c1, cpw(c0))), c0, csetrecs(c1), w0)\n  setrecsss(cres(c1, cpw(c0)), c1, w0)\n  a1i(w0, wss(cres(c1, cpw(c0)), c1))\n  resss(c1, cpw(c0))\n  diff.hs0.c(csetrecs(cres(c1, cpw(c0))))\n  diff.hs0.c(c1)\n  diff.hs0.w(w0)\n  diff.hs0.c(c0)\n}","pretty":"thm setrecsres(class c0, class c1, wff w0) {\n  ⊢ (w0 → c0 = setrecs((c1 |` P(c0))))\n  ⊣ c0 = setrecs(c1)\n  ⊣ (w0 → Fun(c1))\n} = {\n  eqssd(c0, setrecs((c1 |` P(c0))), w0)\n  setrec2v(hs0, c0, setrecs((c1 |` P(c0))), c1, w0)\n  alrimiv(hs0, w0, (hs0 ⊆ setrecs((c1 |` P(c0)))→(c1 ` hs0)⊆ setrecs((c1 |` P(c0)))))\n  ex(w0, hs0 ⊆ setrecs((c1 |` P(c0))), (c1 ` hs0)⊆ setrecs((c1 |` P(c0))))\n  eqsstr3d((c1 ` hs0), setrecs((c1 |` P(c0))), ((c1 |` P(c0))` hs0), (w0 ∧ hs0 ⊆ setrecs((c1 |` P(c0)))))\n  syl((w0 ∧ hs0 ⊆ setrecs((c1 |` P(c0)))), ((c1 |` P(c0))` hs0)=(c1 ` hs0), hs0 ⊆ c0)\n  sylan9ssr(hs0, c0, setrecs((c1 |` P(c0))), w0, hs0 ⊆ setrecs((c1 |` P(c0))))\n  sylbir(hs0 ⊆ c0, ((c1 |` P(c0))` hs0)=(c1 ` hs0), hs0 ∈ P(c0))\n  selpw(hs0, c0)\n  fvres(hs0, P(c0), c1)\n  adantl(w0, hs0 ⊆ setrecs((c1 |` P(c0))), ((c1 |` P(c0))` hs0)⊆ setrecs((c1 |` P(c0))))\n  setrec1((c1 |` P(c0)), hs0, setrecs((c1 |` P(c0))), hs0 ⊆ setrecs((c1 |` P(c0))))\n  eqid(setrecs((c1 |` P(c0))))\n  a1i(hs0 ⊆ setrecs((c1 |` P(c0))), hs0 ∈ 𝕌)\n  vex(hs0)\n  id(hs0 ⊆ setrecs((c1 |` P(c0))))\n  syl6sseqr(setrecs((c1 |` P(c0))), c0, setrecs(c1), w0)\n  setrecsss((c1 |` P(c0)), c1, w0)\n  a1i(w0, (c1 |` P(c0))⊆ c1)\n  resss(c1, P(c0))\n  diff.hs0.c(setrecs((c1 |` P(c0))))\n  diff.hs0.c(c1)\n  diff.hs0.w(w0)\n  diff.hs0.c(c0)\n}","parent":["eqssd","setrec2v","alrimiv","ex","eqsstr3d","syl","sylan9ssr","sylbir","selpw","fvres","adantl","setrec1","eqid","a1i","vex","id","syl6sseqr","setrecsss","resss","diff.hs0.c","diff.hs0.w"],"children":[]},{"name":"vsetrec","content":"Construct ` _V ` using set recursion. The proof indirectly uses ~ trcl , which relies on ` rec ` , but theoretically ` C ` in ~ trcl could be constructed using ` setrecs ` instead. The proof of this theorem uses the dummy variable ` a ` rather than ` x ` to avoid a distinct variable requirement between ` F ` and ` x ` . (Contributed by Emmett Weisz, 23-Jun-2021.)","origin":"thm vsetrec(setvar s0, class c0) {\n  |- wceq(csetrecs(c0), universe)\n  -| wceq(c0, cmpt(s0, universe, cpw(cv(s0))))\n} = {\n  mpg(hs0, wceq(csetrecs(c0), universe), wi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0))))\n  setind(hs0, csetrecs(c0))\n  mpi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0)), wcel(cv(hs0), cpw(cv(hs0))))\n  pwid(cv(hs0))\n  sseld(cv(hs0), cpw(cv(hs0)), csetrecs(c0), wss(cv(hs0), csetrecs(c0)))\n  syl5eqssr(cpw(cv(hs0)), csetrecs(c0), cfv(c0, cv(hs0)), wss(cv(hs0), csetrecs(c0)))\n  ax-mp(wceq(cfv(c0, cv(hs0)), cpw(cv(hs0))), wcel(cv(hs0), universe))\n  fvmpt(s0, cv(hs0), universe, c0, cpw(cv(hs0)), cpw(cv(s0)))\n  pweq(cv(s0), cv(hs0))\n  pwex(cv(hs0))\n  setrec1(c0, cv(hs0), csetrecs(c0), wss(cv(hs0), csetrecs(c0)))\n  eqid(csetrecs(c0))\n  a1i(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), csetrecs(c0)))\n  diff.hs0.c(csetrecs(c0))\n  diff.universe.s(s0)\n  diff.cpw.s(s0, cv(hs0))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm vsetrec(setvar s0, class c0) {\n  ⊢ setrecs(c0)= 𝕌\n  ⊣ c0 =(s0 ∈ 𝕌 ↦ P(s0))\n} = {\n  mpg(hs0, setrecs(c0)= 𝕌, (hs0 ⊆ setrecs(c0)→ hs0 ∈ setrecs(c0)))\n  setind(hs0, setrecs(c0))\n  mpi(hs0 ⊆ setrecs(c0), hs0 ∈ setrecs(c0), hs0 ∈ P(hs0))\n  pwid(hs0)\n  sseld(hs0, P(hs0), setrecs(c0), hs0 ⊆ setrecs(c0))\n  syl5eqssr(P(hs0), setrecs(c0), (c0 ` hs0), hs0 ⊆ setrecs(c0))\n  ax-mp((c0 ` hs0)= P(hs0), hs0 ∈ 𝕌)\n  fvmpt(s0, hs0, universe, c0, P(hs0), P(s0))\n  pweq(s0, hs0)\n  pwex(hs0)\n  setrec1(c0, hs0, setrecs(c0), hs0 ⊆ setrecs(c0))\n  eqid(setrecs(c0))\n  a1i(hs0 ⊆ setrecs(c0), hs0 ∈ 𝕌)\n  vex(hs0)\n  id(hs0 ⊆ setrecs(c0))\n  diff.hs0.c(setrecs(c0))\n  diff.universe.s(s0)\n  diff.cpw.s(s0, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["mpg","setind","mpi","pwid","sseld","syl5eqssr","ax-mp","fvmpt","pweq","pwex","setrec1","eqid","a1i","vex","id","diff.hs0.c","diff.universe.s","diff.cpw.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":[]},{"name":"0setrec","content":"If a function sends the empty set to itself, the function will not recursively generate any sets, regardless of its other values. (Contributed by Emmett Weisz, 23-Jun-2021.)","origin":"thm 0setrec(class c0, wff w0) {\n  |- wi(w0, wceq(csetrecs(c0), emptycls))\n  -| wi(w0, wceq(cfv(c0, emptycls), emptycls))\n} = {\n  syl(w0, wceq(csetrecs(c0), emptycls), wss(csetrecs(c0), emptycls))\n  setrec2v(hs0, csetrecs(c0), emptycls, c0, w0)\n  eqid(csetrecs(c0))\n  alrimiv(hs0, w0, wi(wss(cv(hs0), emptycls), wss(cfv(c0, cv(hs0)), emptycls)))\n  syl56(w0, wss(cv(hs0), emptycls), wss(cfv(c0, cv(hs0)), emptycls), wceq(cv(hs0), emptycls), wceq(cfv(c0, cv(hs0)), emptycls))\n  ss0(cv(hs0))\n  ex(w0, wceq(cv(hs0), emptycls), wceq(cfv(c0, cv(hs0)), emptycls))\n  sylan9eqr(cfv(c0, cv(hs0)), emptycls, cfv(c0, emptycls), w0, wceq(cv(hs0), emptycls))\n  fveq2(cv(hs0), emptycls, c0)\n  eqimss(cfv(c0, cv(hs0)), emptycls)\n  ss0(csetrecs(c0))\n  diff.hs0.c(emptycls)\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","pretty":"thm 0setrec(class c0, wff w0) {\n  ⊢ (w0 → setrecs(c0)= ∅)\n  ⊣ (w0 →(c0 ` ∅)= ∅)\n} = {\n  syl(w0, setrecs(c0)= ∅, setrecs(c0)⊆ ∅)\n  setrec2v(hs0, setrecs(c0), emptycls, c0, w0)\n  eqid(setrecs(c0))\n  alrimiv(hs0, w0, (hs0 ⊆ ∅ →(c0 ` hs0)⊆ ∅))\n  syl56(w0, hs0 ⊆ ∅, (c0 ` hs0)⊆ ∅, hs0 = ∅, (c0 ` hs0)= ∅)\n  ss0(hs0)\n  ex(w0, hs0 = ∅, (c0 ` hs0)= ∅)\n  sylan9eqr((c0 ` hs0), emptycls, (c0 ` ∅), w0, hs0 = ∅)\n  fveq2(hs0, emptycls, c0)\n  eqimss((c0 ` hs0), emptycls)\n  ss0(setrecs(c0))\n  diff.hs0.c(emptycls)\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","parent":["syl","setrec2v","eqid","alrimiv","syl56","ss0","ex","sylan9eqr","fveq2","eqimss","diff.hs0.c","diff.hs0.w"],"children":[]},{"name":"onsetreclem1","content":"Lemma for ~ onsetrec . (Contributed by Emmett Weisz, 22-Jun-2021.) (New usage is discouraged.)","origin":"thm onsetreclem1(setvar s0, setvar s1, class c0) {\n  |- wceq(cfv(c0, cv(s0)), cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))))\n  -| wceq(c0, cmpt(s1, universe, cpr(cuni(cv(s1)), csuc(cuni(cv(s1))))))\n  -| diffss(s0, s1)\n} = {\n  ax-mp(wceq(cfv(c0, cv(s0)), cpr(cuni(cv(s0)), csuc(cuni(cv(s0))))), wcel(cv(s0), universe))\n  vex(s0)\n  fvmpt(s1, cv(s0), universe, c0, cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), cpr(cuni(cv(s1)), csuc(cuni(cv(s1)))))\n  preq12d(cuni(cv(s1)), csuc(cuni(cv(s1))), cuni(cv(s0)), csuc(cuni(cv(s0))), wceq(cv(s1), cv(s0)))\n  syl(wceq(cv(s1), cv(s0)), wceq(csuc(cuni(cv(s1))), csuc(cuni(cv(s0)))), wceq(cuni(cv(s1)), cuni(cv(s0))))\n  unieq(cv(s1), cv(s0))\n  suceq(cuni(cv(s1)), cuni(cv(s0)))\n  prex(cuni(cv(s0)), csuc(cuni(cv(s0))))\n  diff.universe.s(s1)\n  diff.cpr.s(s1, cuni(cv(s0)), csuc(cuni(cv(s0))))\n  diff.csuc.s(s1, cuni(cv(s0)))\n  diff.cuni.s(s1, cv(s0))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm onsetreclem1(setvar s0, setvar s1, class c0) {\n  ⊢ (c0 ` s0)= { ⋃ s0, suc(⋃ s0)}\n  ⊣ c0 =(s1 ∈ 𝕌 ↦ { ⋃ s1, suc(⋃ s1)})\n  ⊣ d(s0, s1)\n} = {\n  ax-mp((c0 ` s0)= { ⋃ s0, suc(⋃ s0)}, s0 ∈ 𝕌)\n  vex(s0)\n  fvmpt(s1, s0, universe, c0, { ⋃ s0, suc(⋃ s0)}, { ⋃ s1, suc(⋃ s1)})\n  preq12d(⋃ s1, suc(⋃ s1), ⋃ s0, suc(⋃ s0), s1 = s0)\n  syl(s1 = s0, suc(⋃ s1)= suc(⋃ s0), ⋃ s1 = ⋃ s0)\n  unieq(s1, s0)\n  suceq(⋃ s1, ⋃ s0)\n  prex(⋃ s0, suc(⋃ s0))\n  diff.universe.s(s1)\n  diff.cpr.s(s1, ⋃ s0, suc(⋃ s0))\n  diff.csuc.s(s1, ⋃ s0)\n  diff.cuni.s(s1, s0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["ax-mp","vex","fvmpt","preq12d","syl","unieq","suceq","prex","diff.universe.s","diff.cpr.s","diff.csuc.s","diff.cuni.s","diff.cv.s","diffss.ex"],"children":["onsetreclem2","onsetreclem3"]},{"name":"onsetreclem2","content":"Lemma for ~ onsetrec . (Contributed by Emmett Weisz, 22-Jun-2021.) (New usage is discouraged.)","origin":"thm onsetreclem2(setvar s0, setvar s1, class c0) {\n  |- wi(wss(cv(s0), con0), wss(cfv(c0, cv(s0)), con0))\n  -| wceq(c0, cmpt(s1, universe, cpr(cuni(cv(s1)), csuc(cuni(cv(s1))))))\n  -| diffss(s0, s1)\n} = {\n  syl5eqss(cfv(c0, cv(s0)), con0, cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), wss(cv(s0), con0))\n  onsetreclem1(s0, s1, c0)\n  syl(wss(cv(s0), con0), wss(cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), con0), wcel(cuni(cv(s0)), con0))\n  ssonunii(cv(s0))\n  vex(s0)\n  mpdan(wcel(cuni(cv(s0)), con0), wss(cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), con0), wcel(csuc(cuni(cv(s0))), con0))\n  suceloni(cuni(cv(s0)))\n  prssi(cuni(cv(s0)), con0, csuc(cuni(cv(s0))))\n}","pretty":"thm onsetreclem2(setvar s0, setvar s1, class c0) {\n  ⊢ (s0 ⊆ On →(c0 ` s0)⊆ On)\n  ⊣ c0 =(s1 ∈ 𝕌 ↦ { ⋃ s1, suc(⋃ s1)})\n  ⊣ d(s0, s1)\n} = {\n  syl5eqss((c0 ` s0), con0, { ⋃ s0, suc(⋃ s0)}, s0 ⊆ On)\n  onsetreclem1(s0, s1, c0)\n  syl(s0 ⊆ On, { ⋃ s0, suc(⋃ s0)} ⊆ On, ⋃ s0 ∈ On)\n  ssonunii(s0)\n  vex(s0)\n  mpdan(⋃ s0 ∈ On, { ⋃ s0, suc(⋃ s0)} ⊆ On, suc(⋃ s0)∈ On)\n  suceloni(⋃ s0)\n  prssi(⋃ s0, con0, suc(⋃ s0))\n}","parent":["syl5eqss","onsetreclem1","syl","ssonunii","vex","mpdan","suceloni","prssi"],"children":["onsetrec"]},{"name":"onsetreclem3","content":"Lemma for ~ onsetrec . (Contributed by Emmett Weisz, 22-Jun-2021.) (New usage is discouraged.)","origin":"thm onsetreclem3(setvar s0, setvar s1, class c0) {\n  |- wi(wcel(cv(s0), con0), wcel(cv(s0), cfv(c0, cv(s0))))\n  -| wceq(c0, cmpt(s1, universe, cpr(cuni(cv(s1)), csuc(cuni(cv(s1))))))\n  -| diffss(s0, s1)\n} = {\n  syl6eleqr(cv(s0), cfv(c0, cv(s0)), cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), wcel(cv(s0), con0))\n  sylibr(wcel(cv(s0), con0), wcel(cv(s0), cpr(cuni(cv(s0)), csuc(cuni(cv(s0))))), wo(wceq(cv(s0), cuni(cv(s0))), wceq(cv(s0), csuc(cuni(cv(s0))))))\n  syl(wcel(cv(s0), con0), wo(wceq(cv(s0), cuni(cv(s0))), wceq(cv(s0), csuc(cuni(cv(s0))))), word(cv(s0)))\n  eloni(cv(s0))\n  orduniorsuc(cv(s0))\n  elpr(cv(s0), cuni(cv(s0)), csuc(cuni(cv(s0))))\n  vex(s0)\n  onsetreclem1(s0, s1, c0)\n}","pretty":"thm onsetreclem3(setvar s0, setvar s1, class c0) {\n  ⊢ (s0 ∈ On → s0 ∈(c0 ` s0))\n  ⊣ c0 =(s1 ∈ 𝕌 ↦ { ⋃ s1, suc(⋃ s1)})\n  ⊣ d(s0, s1)\n} = {\n  syl6eleqr(s0, (c0 ` s0), { ⋃ s0, suc(⋃ s0)}, s0 ∈ On)\n  sylibr(s0 ∈ On, s0 ∈ { ⋃ s0, suc(⋃ s0)}, (s0 = ⋃ s0 ∨ s0 = suc(⋃ s0)))\n  syl(s0 ∈ On, (s0 = ⋃ s0 ∨ s0 = suc(⋃ s0)), Ord(s0))\n  eloni(s0)\n  orduniorsuc(s0)\n  elpr(s0, ⋃ s0, suc(⋃ s0))\n  vex(s0)\n  onsetreclem1(s0, s1, c0)\n}","parent":["syl6eleqr","sylibr","syl","eloni","orduniorsuc","elpr","vex","onsetreclem1"],"children":["onsetrec"]},{"name":"onsetrec","content":"Construct ` On ` using set recursion. When ` x e. On ` , the function ` F ` constructs the least ordinal greater than any of the elements of ` x ` , which is ` U. x ` for a limit ordinal and ` suc U. x ` for a successor ordinal. For example, ` ( F `` { 1o , 2o } ) ` ` = { U. { 1o , 2o } , suc U. { 1o , 2o } } = { 2o , 3o } ` which contains ` 3o ` , and ` ( F `` _om ) = { U. _om , suc U. _om } = { _om , _om +o 1o } ` , which contains ` _om ` . If we start with the empty set and keep applying ` F ` transfinitely many times, all ordinal numbers will be generated. Any function ` F ` fulfilling lemmas ~ onsetreclem2 and ~ onsetreclem3 will recursively generate ` On ` ; for example, ` F = ( x e. _V |-> suc suc U. x } ) ` also works. Whether this function or the function in the theorem is used, taking this theorem as a definition of ` On ` is unsatisfying because it relies on the different properties of limit and successor ordinals. A different approach could be to let ` F = ( x e. _V |-> { y e. ~P x | Tr y } ) ` , based on ~ dfon2 . The proof of this theorem uses the dummy variable ` a ` rather than ` x ` to avoid a distinct variable condition between ` F ` and ` x ` . (Contributed by Emmett Weisz, 22-Jun-2021.)","origin":"thm onsetrec(setvar s0, class c0) {\n  |- wceq(csetrecs(c0), con0)\n  -| wceq(c0, cmpt(s0, universe, cpr(cuni(cv(s0)), csuc(cuni(cv(s0))))))\n} = {\n  mp2an(wceq(csetrecs(c0), con0), wss(csetrecs(c0), con0), wral(hs0, con0, wi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0)))))\n  mptru(wss(csetrecs(c0), con0))\n  setrec2v(hs0, csetrecs(c0), con0, c0, wtru)\n  a1i(wtru, wal(hs0, wi(wss(cv(hs0), con0), wss(cfv(c0, cv(hs0)), con0))))\n  ax-gen(hs0, wi(wss(cv(hs0), con0), wss(cfv(c0, cv(hs0)), con0)))\n  onsetreclem2(hs0, s0, c0)\n  rgen(hs0, con0, wi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0))))\n  com12(wcel(cv(hs0), con0), wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0)))\n  syl2im(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), con0), wcel(cv(hs0), csetrecs(c0)), wss(cfv(c0, cv(hs0)), csetrecs(c0)), wcel(cv(hs0), cfv(c0, cv(hs0))))\n  setrec1(c0, cv(hs0), csetrecs(c0), wss(cv(hs0), csetrecs(c0)))\n  eqid(csetrecs(c0))\n  a1i(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), csetrecs(c0)))\n  onsetreclem3(hs0, s0, c0)\n  ssel(cfv(c0, cv(hs0)), csetrecs(c0), cv(hs0))\n  tfi(hs0, csetrecs(c0))\n  diff.hs0.c(con0)\n  diff.hs0.c(c0)\n  diff.hs0.s(s0)\n  diff.hs0.c(csetrecs(c0))\n}","pretty":"thm onsetrec(setvar s0, class c0) {\n  ⊢ setrecs(c0)= On\n  ⊣ c0 =(s0 ∈ 𝕌 ↦ { ⋃ s0, suc(⋃ s0)})\n} = {\n  mp2an(setrecs(c0)= On, setrecs(c0)⊆ On, ∀(hs0 ∈ On,(hs0 ⊆ setrecs(c0)→ hs0 ∈ setrecs(c0))))\n  mptru(setrecs(c0)⊆ On)\n  setrec2v(hs0, setrecs(c0), con0, c0, wtru)\n  a1i(wtru, ∀(hs0,(hs0 ⊆ On →(c0 ` hs0)⊆ On)))\n  ax-gen(hs0, (hs0 ⊆ On →(c0 ` hs0)⊆ On))\n  onsetreclem2(hs0, s0, c0)\n  rgen(hs0, con0, (hs0 ⊆ setrecs(c0)→ hs0 ∈ setrecs(c0)))\n  com12(hs0 ∈ On, hs0 ⊆ setrecs(c0), hs0 ∈ setrecs(c0))\n  syl2im(hs0 ⊆ setrecs(c0), hs0 ∈ On, hs0 ∈ setrecs(c0), (c0 ` hs0)⊆ setrecs(c0), hs0 ∈(c0 ` hs0))\n  setrec1(c0, hs0, setrecs(c0), hs0 ⊆ setrecs(c0))\n  eqid(setrecs(c0))\n  a1i(hs0 ⊆ setrecs(c0), hs0 ∈ 𝕌)\n  vex(hs0)\n  id(hs0 ⊆ setrecs(c0))\n  onsetreclem3(hs0, s0, c0)\n  ssel((c0 ` hs0), setrecs(c0), hs0)\n  tfi(hs0, setrecs(c0))\n  diff.hs0.c(con0)\n  diff.hs0.c(c0)\n  diff.hs0.s(s0)\n  diff.hs0.c(setrecs(c0))\n}","parent":["mp2an","mptru","setrec2v","a1i","ax-gen","onsetreclem2","rgen","com12","syl2im","setrec1","eqid","vex","id","onsetreclem3","ssel","tfi","diff.hs0.c","diff.hs0.s"],"children":[]}]}