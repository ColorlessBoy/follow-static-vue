{"index":1566,"title":"Examples and properties of set recursion","content":"","blocks":[{"name":"elsetrecslem","content":"Lemma for ~ elsetrecs . Any element of ` setrecs ( F ) ` is generated by some subset of ` setrecs ( F ) ` . This is much weaker than ~ setrec2v . To see why this lemma also requires ~ setrec1 , consider what would happen if we replaced ` B ` with ` { A } ` . The antecedent would still hold, but the consequent would fail in general. Consider dispensing with the deduction form. (Contributed by Emmett Weisz, 11-Jul-2021.) (New usage is discouraged.)","origin":"thm elsetrecslem(setvar s0, class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))\n  -| wceq(c1, csetrecs(c2))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n} = {\n  sylibr(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))), wn(wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))))\n  nsyl(wcel(c0, c1), wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))), wss(c1, cdif(c1, csn(c0))))\n  con2i(wcel(c0, c1), wss(c1, cdif(c1, csn(c0))))\n  simprbi(wss(c1, cdif(c1, csn(c0))), wn(wcel(c0, c1)), wss(c1, c1))\n  ssdifsn(c1, c1, c0)\n  setrec2v(hs0, c1, cdif(c1, csn(c0)), c2, wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))))\n  alrimiv(hs0, wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))), wi(wss(cv(hs0), cdif(c1, csn(c0))), wss(cfv(c2, cv(hs0)), cdif(c1, csn(c0)))))\n  syl(wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))), wi(wss(cv(hs0), cdif(c1, csn(c0))), wss(cfv(c2, cv(hs0)), cdif(c1, csn(c0)))), wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))))\n  spv(s0, hs0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))), wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))))\n  notbid(wceq(cv(s0), cv(hs0)), wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))), wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0)))))\n  anbi12d(wceq(cv(s0), cv(hs0)), wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))), wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))\n  sseq1(cv(s0), cv(hs0), c1)\n  eleq2d(c0, cfv(c2, cv(s0)), cfv(c2, cv(hs0)), wceq(cv(s0), cv(hs0)))\n  fveq2(cv(s0), cv(hs0), c2)\n  3imtr4g(wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))), wss(cv(hs0), cdif(c1, csn(c0))), wss(cfv(c2, cv(hs0)), cdif(c1, csn(c0))), wa(wss(cv(hs0), c1), wn(wcel(c0, cv(hs0)))), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  adantrd(wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))), wss(cv(hs0), c1), wn(wcel(c0, cv(hs0))), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  sylbir(wn(wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))), wi(wss(cv(hs0), c1), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0)))))), wi(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  imnan(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))\n  a2i(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0)))), wa(wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0))))))\n  jctild(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0)))), wss(cfv(c2, cv(hs0)), c1), wn(wcel(c0, cfv(c2, cv(hs0)))))\n  idd(wss(cv(hs0), c1), wn(wcel(c0, cfv(c2, cv(hs0)))))\n  setrec1(c2, cv(hs0), c1, wss(cv(hs0), c1))\n  a1i(wss(cv(hs0), c1), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), c1))\n  ssdifsn(cv(hs0), c1, c0)\n  ssdifsn(cfv(c2, cv(hs0)), c1, c0)\n  df-ex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))\n  diff.hs0.c(cdif(c1, csn(c0)))\n  diff.hs0.c(c2)\n  diff.hs0.w(wal(s0, wn(wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))))))\n  diff.wn.s(s0, wa(wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0)))))\n  diff.wa.s(s0, wss(cv(hs0), c1), wcel(c0, cfv(c2, cv(hs0))))\n  diff.wss.s(s0, cv(hs0), c1)\n  diff.wcel.s(s0, c0, cfv(c2, cv(hs0)))\n  diff.cfv.s(s0, c2, cv(hs0))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm elsetrecslem(setvar s0, class c0, class c1, class c2) {\n  âŠ¢ (c0 âˆˆ c1 â†’ âˆƒ(s0,(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))))\n  âŠ£ c1 = setrecs(c2)\n  âŠ£ d(s0, c0)\n  âŠ£ d(s0, c1)\n  âŠ£ d(s0, c2)\n} = {\n  sylibr(c0 âˆˆ c1, âˆƒ(s0,(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))), Â¬ âˆ€(s0, Â¬(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))))\n  nsyl(c0 âˆˆ c1, âˆ€(s0, Â¬(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))), c1 âŠ†(c1 \\ { c0 }))\n  con2i(c0 âˆˆ c1, c1 âŠ†(c1 \\ { c0 }))\n  simprbi(c1 âŠ†(c1 \\ { c0 }), Â¬ c0 âˆˆ c1, c1 âŠ† c1)\n  ssdifsn(c1, c1, c0)\n  setrec2v(hs0, c1, (c1 \\ { c0 }), c2, âˆ€(s0, Â¬(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))))\n  alrimiv(hs0, âˆ€(s0, Â¬(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))), (hs0 âŠ†(c1 \\ { c0 })â†’(c2 ` hs0)âŠ†(c1 \\ { c0 })))\n  syl(âˆ€(s0, Â¬(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))), (hs0 âŠ†(c1 \\ { c0 })â†’(c2 ` hs0)âŠ†(c1 \\ { c0 })), Â¬(hs0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` hs0)))\n  spv(s0, hs0, Â¬(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0)), Â¬(hs0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` hs0)))\n  notbid(s0 = hs0, (s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0)), (hs0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` hs0)))\n  anbi12d(s0 = hs0, s0 âŠ† c1, c0 âˆˆ(c2 ` s0), hs0 âŠ† c1, c0 âˆˆ(c2 ` hs0))\n  sseq1(s0, hs0, c1)\n  eleq2d(c0, (c2 ` s0), (c2 ` hs0), s0 = hs0)\n  fveq2(s0, hs0, c2)\n  3imtr4g(Â¬(hs0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` hs0)), hs0 âŠ†(c1 \\ { c0 }), (c2 ` hs0)âŠ†(c1 \\ { c0 }), (hs0 âŠ† c1 âˆ§ Â¬ c0 âˆˆ hs0), ((c2 ` hs0)âŠ† c1 âˆ§ Â¬ c0 âˆˆ(c2 ` hs0)))\n  adantrd(Â¬(hs0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` hs0)), hs0 âŠ† c1, Â¬ c0 âˆˆ hs0, ((c2 ` hs0)âŠ† c1 âˆ§ Â¬ c0 âˆˆ(c2 ` hs0)))\n  sylbir(Â¬(hs0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` hs0)), (hs0 âŠ† c1 â†’((c2 ` hs0)âŠ† c1 âˆ§ Â¬ c0 âˆˆ(c2 ` hs0))), (hs0 âŠ† c1 â†’ Â¬ c0 âˆˆ(c2 ` hs0)))\n  imnan(hs0 âŠ† c1, c0 âˆˆ(c2 ` hs0))\n  a2i(hs0 âŠ† c1, Â¬ c0 âˆˆ(c2 ` hs0), ((c2 ` hs0)âŠ† c1 âˆ§ Â¬ c0 âˆˆ(c2 ` hs0)))\n  jctild(hs0 âŠ† c1, Â¬ c0 âˆˆ(c2 ` hs0), (c2 ` hs0)âŠ† c1, Â¬ c0 âˆˆ(c2 ` hs0))\n  idd(hs0 âŠ† c1, Â¬ c0 âˆˆ(c2 ` hs0))\n  setrec1(c2, hs0, c1, hs0 âŠ† c1)\n  a1i(hs0 âŠ† c1, hs0 âˆˆ ğ•Œ)\n  vex(hs0)\n  id(hs0 âŠ† c1)\n  ssdifsn(hs0, c1, c0)\n  ssdifsn((c2 ` hs0), c1, c0)\n  df-ex(s0, (s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0)))\n  diff.hs0.c((c1 \\ { c0 }))\n  diff.hs0.c(c2)\n  diff.hs0.w(âˆ€(s0, Â¬(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))))\n  diff.wn.s(s0, (hs0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` hs0)))\n  diff.wa.s(s0, hs0 âŠ† c1, c0 âˆˆ(c2 ` hs0))\n  diff.wss.s(s0, hs0, c1)\n  diff.wcel.s(s0, c0, (c2 ` hs0))\n  diff.cfv.s(s0, c2, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["sylibr","nsyl","con2i","simprbi","ssdifsn","setrec2v","alrimiv","syl","spv","notbid","anbi12d","sseq1","eleq2d","fveq2","3imtr4g","adantrd","sylbir","imnan","a2i","jctild","idd","setrec1","a1i","vex","id","df-ex","diff.hs0.c","diff.hs0.w","diff.wn.s","diff.wa.s","diff.wss.s","diff.wcel.s","diff.cfv.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":["elsetrecs"]},{"name":"elsetrecs","content":"A set ` A ` is an element of ` setrecs ( F ) ` iff ` A ` is generated by some subset of ` setrecs ( F ) ` . The proof requires both ~ setrec1 and ~ setrec2 , but this theorem is not strong enough to uniquely determine ` setrecs ( F ) ` . If ` F ` respects the subset relation, the theorem still holds if both occurrences of ` e. ` are replaced by ` C_ ` for a stronger version of the theorem. (Contributed by Emmett Weisz, 12-Jul-2021.)","origin":"thm elsetrecs(setvar s0, class c0, class c1, class c2) {\n  |- wb(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))\n  -| wceq(c1, csetrecs(c2))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n} = {\n  impbii(wcel(c0, c1), wex(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0))))))\n  elsetrecslem(s0, c0, c1, c2)\n  exlimiv(s0, wa(wss(cv(s0), c1), wcel(c0, cfv(c2, cv(s0)))), wcel(c0, c1))\n  sselda(c0, cfv(c2, cv(s0)), c1, wss(cv(s0), c1))\n  setrec1(c2, cv(s0), c1, wss(cv(s0), c1))\n  a1i(wss(cv(s0), c1), wcel(cv(s0), universe))\n  vex(s0)\n  id(wss(cv(s0), c1))\n  diff.wcel.s(s0, c0, c1)\n}","pretty":"thm elsetrecs(setvar s0, class c0, class c1, class c2) {\n  âŠ¢ (c0 âˆˆ c1 â†” âˆƒ(s0,(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))))\n  âŠ£ c1 = setrecs(c2)\n  âŠ£ d(s0, c0)\n  âŠ£ d(s0, c1)\n  âŠ£ d(s0, c2)\n} = {\n  impbii(c0 âˆˆ c1, âˆƒ(s0,(s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0))))\n  elsetrecslem(s0, c0, c1, c2)\n  exlimiv(s0, (s0 âŠ† c1 âˆ§ c0 âˆˆ(c2 ` s0)), c0 âˆˆ c1)\n  sselda(c0, (c2 ` s0), c1, s0 âŠ† c1)\n  setrec1(c2, s0, c1, s0 âŠ† c1)\n  a1i(s0 âŠ† c1, s0 âˆˆ ğ•Œ)\n  vex(s0)\n  id(s0 âŠ† c1)\n  diff.wcel.s(s0, c0, c1)\n}","parent":["impbii","elsetrecslem","exlimiv","sselda","setrec1","a1i","vex","id","diff.wcel.s"],"children":["elpg"]},{"name":"setrecsss","content":"The ` setrecs ` operator respects the subset relation between two functions ` F ` and ` G ` . (Contributed by Emmett Weisz, 13-Mar-2022.)","origin":"thm setrecsss(class c0, class c1, wff w0) {\n  |- wi(w0, wss(csetrecs(c0), csetrecs(c1)))\n  -| wi(w0, wfun(c1))\n  -| wi(w0, wss(c0, c1))\n} = {\n  setrec2v(hs0, csetrecs(c0), csetrecs(c1), c0, w0)\n  eqid(csetrecs(c0))\n  alrimiv(hs0, w0, wi(wss(cv(hs0), csetrecs(c1)), wss(cfv(c0, cv(hs0)), csetrecs(c1))))\n  ex(w0, wss(cv(hs0), csetrecs(c1)), wss(cfv(c0, cv(hs0)), csetrecs(c1)))\n  sstrd(cfv(c0, cv(hs0)), csetrecs(c1), cfv(c1, cv(hs0)), wa(w0, wss(cv(hs0), csetrecs(c1))))\n  adantr(w0, wss(cv(hs0), csetrecs(c1)), wss(cfv(c0, cv(hs0)), cfv(c1, cv(hs0))))\n  3sstr4d(cfv(c0, cv(hs0)), cfv(c1, cv(hs0)), cuni(cima(c0, csn(cv(hs0)))), cuni(cima(c1, csn(cv(hs0)))), w0)\n  unissd(cima(c0, csn(cv(hs0))), cima(c1, csn(cv(hs0))), w0)\n  syl(w0, wss(cima(c0, csn(cv(hs0))), cima(c1, csn(cv(hs0)))), wss(c0, c1))\n  imass1(c0, c1, csn(cv(hs0)))\n  syl(w0, wceq(cfv(c0, cv(hs0)), cuni(cima(c0, csn(cv(hs0))))), wfun(c0))\n  sylc(w0, wfun(c0), wss(c0, c1), wfun(c1))\n  funss(c0, c1)\n  funfv(c0, cv(hs0))\n  syl(w0, wceq(cfv(c1, cv(hs0)), cuni(cima(c1, csn(cv(hs0))))), wfun(c1))\n  funfv(c1, cv(hs0))\n  setrec1(c1, cv(hs0), csetrecs(c1), wa(w0, wss(cv(hs0), csetrecs(c1))))\n  eqid(csetrecs(c1))\n  a1i(wa(w0, wss(cv(hs0), csetrecs(c1))), wcel(cv(hs0), universe))\n  vex(hs0)\n  simpr(w0, wss(cv(hs0), csetrecs(c1)))\n  diff.hs0.c(csetrecs(c1))\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","pretty":"thm setrecsss(class c0, class c1, wff w0) {\n  âŠ¢ (w0 â†’ setrecs(c0)âŠ† setrecs(c1))\n  âŠ£ (w0 â†’ Fun(c1))\n  âŠ£ (w0 â†’ c0 âŠ† c1)\n} = {\n  setrec2v(hs0, setrecs(c0), setrecs(c1), c0, w0)\n  eqid(setrecs(c0))\n  alrimiv(hs0, w0, (hs0 âŠ† setrecs(c1)â†’(c0 ` hs0)âŠ† setrecs(c1)))\n  ex(w0, hs0 âŠ† setrecs(c1), (c0 ` hs0)âŠ† setrecs(c1))\n  sstrd((c0 ` hs0), setrecs(c1), (c1 ` hs0), (w0 âˆ§ hs0 âŠ† setrecs(c1)))\n  adantr(w0, hs0 âŠ† setrecs(c1), (c0 ` hs0)âŠ†(c1 ` hs0))\n  3sstr4d((c0 ` hs0), (c1 ` hs0), â‹ƒ(c0 \" { hs0 }), â‹ƒ(c1 \" { hs0 }), w0)\n  unissd((c0 \" { hs0 }), (c1 \" { hs0 }), w0)\n  syl(w0, (c0 \" { hs0 })âŠ†(c1 \" { hs0 }), c0 âŠ† c1)\n  imass1(c0, c1, { hs0 })\n  syl(w0, (c0 ` hs0)= â‹ƒ(c0 \" { hs0 }), Fun(c0))\n  sylc(w0, Fun(c0), c0 âŠ† c1, Fun(c1))\n  funss(c0, c1)\n  funfv(c0, hs0)\n  syl(w0, (c1 ` hs0)= â‹ƒ(c1 \" { hs0 }), Fun(c1))\n  funfv(c1, hs0)\n  setrec1(c1, hs0, setrecs(c1), (w0 âˆ§ hs0 âŠ† setrecs(c1)))\n  eqid(setrecs(c1))\n  a1i((w0 âˆ§ hs0 âŠ† setrecs(c1)), hs0 âˆˆ ğ•Œ)\n  vex(hs0)\n  simpr(w0, hs0 âŠ† setrecs(c1))\n  diff.hs0.c(setrecs(c1))\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","parent":["setrec2v","eqid","alrimiv","ex","sstrd","adantr","3sstr4d","unissd","syl","imass1","sylc","funss","funfv","setrec1","a1i","vex","simpr","diff.hs0.c","diff.hs0.w"],"children":["setrecsres"]},{"name":"setrecsres","content":"A recursively generated class is unaffected when its input function is restricted to subsets of the class. (Contributed by Emmett Weisz, 14-Mar-2022.)","origin":"thm setrecsres(class c0, class c1, wff w0) {\n  |- wi(w0, wceq(c0, csetrecs(cres(c1, cpw(c0)))))\n  -| wceq(c0, csetrecs(c1))\n  -| wi(w0, wfun(c1))\n} = {\n  eqssd(c0, csetrecs(cres(c1, cpw(c0))), w0)\n  setrec2v(hs0, c0, csetrecs(cres(c1, cpw(c0))), c1, w0)\n  alrimiv(hs0, w0, wi(wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wss(cfv(c1, cv(hs0)), csetrecs(cres(c1, cpw(c0))))))\n  ex(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wss(cfv(c1, cv(hs0)), csetrecs(cres(c1, cpw(c0)))))\n  eqsstr3d(cfv(c1, cv(hs0)), csetrecs(cres(c1, cpw(c0))), cfv(cres(c1, cpw(c0)), cv(hs0)), wa(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0))))))\n  syl(wa(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0))))), wceq(cfv(cres(c1, cpw(c0)), cv(hs0)), cfv(c1, cv(hs0))), wss(cv(hs0), c0))\n  sylan9ssr(cv(hs0), c0, csetrecs(cres(c1, cpw(c0))), w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))))\n  sylbir(wss(cv(hs0), c0), wceq(cfv(cres(c1, cpw(c0)), cv(hs0)), cfv(c1, cv(hs0))), wcel(cv(hs0), cpw(c0)))\n  selpw(hs0, c0)\n  fvres(cv(hs0), cpw(c0), c1)\n  adantl(w0, wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wss(cfv(cres(c1, cpw(c0)), cv(hs0)), csetrecs(cres(c1, cpw(c0)))))\n  setrec1(cres(c1, cpw(c0)), cv(hs0), csetrecs(cres(c1, cpw(c0))), wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))))\n  eqid(csetrecs(cres(c1, cpw(c0))))\n  a1i(wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), csetrecs(cres(c1, cpw(c0)))))\n  syl6sseqr(csetrecs(cres(c1, cpw(c0))), c0, csetrecs(c1), w0)\n  setrecsss(cres(c1, cpw(c0)), c1, w0)\n  a1i(w0, wss(cres(c1, cpw(c0)), c1))\n  resss(c1, cpw(c0))\n  diff.hs0.c(csetrecs(cres(c1, cpw(c0))))\n  diff.hs0.c(c1)\n  diff.hs0.w(w0)\n  diff.hs0.c(c0)\n}","pretty":"thm setrecsres(class c0, class c1, wff w0) {\n  âŠ¢ (w0 â†’ c0 = setrecs((c1 |` P(c0))))\n  âŠ£ c0 = setrecs(c1)\n  âŠ£ (w0 â†’ Fun(c1))\n} = {\n  eqssd(c0, setrecs((c1 |` P(c0))), w0)\n  setrec2v(hs0, c0, setrecs((c1 |` P(c0))), c1, w0)\n  alrimiv(hs0, w0, (hs0 âŠ† setrecs((c1 |` P(c0)))â†’(c1 ` hs0)âŠ† setrecs((c1 |` P(c0)))))\n  ex(w0, hs0 âŠ† setrecs((c1 |` P(c0))), (c1 ` hs0)âŠ† setrecs((c1 |` P(c0))))\n  eqsstr3d((c1 ` hs0), setrecs((c1 |` P(c0))), ((c1 |` P(c0))` hs0), (w0 âˆ§ hs0 âŠ† setrecs((c1 |` P(c0)))))\n  syl((w0 âˆ§ hs0 âŠ† setrecs((c1 |` P(c0)))), ((c1 |` P(c0))` hs0)=(c1 ` hs0), hs0 âŠ† c0)\n  sylan9ssr(hs0, c0, setrecs((c1 |` P(c0))), w0, hs0 âŠ† setrecs((c1 |` P(c0))))\n  sylbir(hs0 âŠ† c0, ((c1 |` P(c0))` hs0)=(c1 ` hs0), hs0 âˆˆ P(c0))\n  selpw(hs0, c0)\n  fvres(hs0, P(c0), c1)\n  adantl(w0, hs0 âŠ† setrecs((c1 |` P(c0))), ((c1 |` P(c0))` hs0)âŠ† setrecs((c1 |` P(c0))))\n  setrec1((c1 |` P(c0)), hs0, setrecs((c1 |` P(c0))), hs0 âŠ† setrecs((c1 |` P(c0))))\n  eqid(setrecs((c1 |` P(c0))))\n  a1i(hs0 âŠ† setrecs((c1 |` P(c0))), hs0 âˆˆ ğ•Œ)\n  vex(hs0)\n  id(hs0 âŠ† setrecs((c1 |` P(c0))))\n  syl6sseqr(setrecs((c1 |` P(c0))), c0, setrecs(c1), w0)\n  setrecsss((c1 |` P(c0)), c1, w0)\n  a1i(w0, (c1 |` P(c0))âŠ† c1)\n  resss(c1, P(c0))\n  diff.hs0.c(setrecs((c1 |` P(c0))))\n  diff.hs0.c(c1)\n  diff.hs0.w(w0)\n  diff.hs0.c(c0)\n}","parent":["eqssd","setrec2v","alrimiv","ex","eqsstr3d","syl","sylan9ssr","sylbir","selpw","fvres","adantl","setrec1","eqid","a1i","vex","id","syl6sseqr","setrecsss","resss","diff.hs0.c","diff.hs0.w"],"children":[]},{"name":"vsetrec","content":"Construct ` _V ` using set recursion. The proof indirectly uses ~ trcl , which relies on ` rec ` , but theoretically ` C ` in ~ trcl could be constructed using ` setrecs ` instead. The proof of this theorem uses the dummy variable ` a ` rather than ` x ` to avoid a distinct variable requirement between ` F ` and ` x ` . (Contributed by Emmett Weisz, 23-Jun-2021.)","origin":"thm vsetrec(setvar s0, class c0) {\n  |- wceq(csetrecs(c0), universe)\n  -| wceq(c0, cmpt(s0, universe, cpw(cv(s0))))\n} = {\n  mpg(hs0, wceq(csetrecs(c0), universe), wi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0))))\n  setind(hs0, csetrecs(c0))\n  mpi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0)), wcel(cv(hs0), cpw(cv(hs0))))\n  pwid(cv(hs0))\n  sseld(cv(hs0), cpw(cv(hs0)), csetrecs(c0), wss(cv(hs0), csetrecs(c0)))\n  syl5eqssr(cpw(cv(hs0)), csetrecs(c0), cfv(c0, cv(hs0)), wss(cv(hs0), csetrecs(c0)))\n  ax-mp(wceq(cfv(c0, cv(hs0)), cpw(cv(hs0))), wcel(cv(hs0), universe))\n  fvmpt(s0, cv(hs0), universe, c0, cpw(cv(hs0)), cpw(cv(s0)))\n  pweq(cv(s0), cv(hs0))\n  pwex(cv(hs0))\n  setrec1(c0, cv(hs0), csetrecs(c0), wss(cv(hs0), csetrecs(c0)))\n  eqid(csetrecs(c0))\n  a1i(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), csetrecs(c0)))\n  diff.hs0.c(csetrecs(c0))\n  diff.universe.s(s0)\n  diff.cpw.s(s0, cv(hs0))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm vsetrec(setvar s0, class c0) {\n  âŠ¢ setrecs(c0)= ğ•Œ\n  âŠ£ c0 =(s0 âˆˆ ğ•Œ â†¦ P(s0))\n} = {\n  mpg(hs0, setrecs(c0)= ğ•Œ, (hs0 âŠ† setrecs(c0)â†’ hs0 âˆˆ setrecs(c0)))\n  setind(hs0, setrecs(c0))\n  mpi(hs0 âŠ† setrecs(c0), hs0 âˆˆ setrecs(c0), hs0 âˆˆ P(hs0))\n  pwid(hs0)\n  sseld(hs0, P(hs0), setrecs(c0), hs0 âŠ† setrecs(c0))\n  syl5eqssr(P(hs0), setrecs(c0), (c0 ` hs0), hs0 âŠ† setrecs(c0))\n  ax-mp((c0 ` hs0)= P(hs0), hs0 âˆˆ ğ•Œ)\n  fvmpt(s0, hs0, universe, c0, P(hs0), P(s0))\n  pweq(s0, hs0)\n  pwex(hs0)\n  setrec1(c0, hs0, setrecs(c0), hs0 âŠ† setrecs(c0))\n  eqid(setrecs(c0))\n  a1i(hs0 âŠ† setrecs(c0), hs0 âˆˆ ğ•Œ)\n  vex(hs0)\n  id(hs0 âŠ† setrecs(c0))\n  diff.hs0.c(setrecs(c0))\n  diff.universe.s(s0)\n  diff.cpw.s(s0, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["mpg","setind","mpi","pwid","sseld","syl5eqssr","ax-mp","fvmpt","pweq","pwex","setrec1","eqid","a1i","vex","id","diff.hs0.c","diff.universe.s","diff.cpw.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":[]},{"name":"0setrec","content":"If a function sends the empty set to itself, the function will not recursively generate any sets, regardless of its other values. (Contributed by Emmett Weisz, 23-Jun-2021.)","origin":"thm 0setrec(class c0, wff w0) {\n  |- wi(w0, wceq(csetrecs(c0), emptycls))\n  -| wi(w0, wceq(cfv(c0, emptycls), emptycls))\n} = {\n  syl(w0, wceq(csetrecs(c0), emptycls), wss(csetrecs(c0), emptycls))\n  setrec2v(hs0, csetrecs(c0), emptycls, c0, w0)\n  eqid(csetrecs(c0))\n  alrimiv(hs0, w0, wi(wss(cv(hs0), emptycls), wss(cfv(c0, cv(hs0)), emptycls)))\n  syl56(w0, wss(cv(hs0), emptycls), wss(cfv(c0, cv(hs0)), emptycls), wceq(cv(hs0), emptycls), wceq(cfv(c0, cv(hs0)), emptycls))\n  ss0(cv(hs0))\n  ex(w0, wceq(cv(hs0), emptycls), wceq(cfv(c0, cv(hs0)), emptycls))\n  sylan9eqr(cfv(c0, cv(hs0)), emptycls, cfv(c0, emptycls), w0, wceq(cv(hs0), emptycls))\n  fveq2(cv(hs0), emptycls, c0)\n  eqimss(cfv(c0, cv(hs0)), emptycls)\n  ss0(csetrecs(c0))\n  diff.hs0.c(emptycls)\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","pretty":"thm 0setrec(class c0, wff w0) {\n  âŠ¢ (w0 â†’ setrecs(c0)= âˆ…)\n  âŠ£ (w0 â†’(c0 ` âˆ…)= âˆ…)\n} = {\n  syl(w0, setrecs(c0)= âˆ…, setrecs(c0)âŠ† âˆ…)\n  setrec2v(hs0, setrecs(c0), emptycls, c0, w0)\n  eqid(setrecs(c0))\n  alrimiv(hs0, w0, (hs0 âŠ† âˆ… â†’(c0 ` hs0)âŠ† âˆ…))\n  syl56(w0, hs0 âŠ† âˆ…, (c0 ` hs0)âŠ† âˆ…, hs0 = âˆ…, (c0 ` hs0)= âˆ…)\n  ss0(hs0)\n  ex(w0, hs0 = âˆ…, (c0 ` hs0)= âˆ…)\n  sylan9eqr((c0 ` hs0), emptycls, (c0 ` âˆ…), w0, hs0 = âˆ…)\n  fveq2(hs0, emptycls, c0)\n  eqimss((c0 ` hs0), emptycls)\n  ss0(setrecs(c0))\n  diff.hs0.c(emptycls)\n  diff.hs0.c(c0)\n  diff.hs0.w(w0)\n}","parent":["syl","setrec2v","eqid","alrimiv","syl56","ss0","ex","sylan9eqr","fveq2","eqimss","diff.hs0.c","diff.hs0.w"],"children":[]},{"name":"onsetreclem1","content":"Lemma for ~ onsetrec . (Contributed by Emmett Weisz, 22-Jun-2021.) (New usage is discouraged.)","origin":"thm onsetreclem1(setvar s0, setvar s1, class c0) {\n  |- wceq(cfv(c0, cv(s0)), cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))))\n  -| wceq(c0, cmpt(s1, universe, cpr(cuni(cv(s1)), csuc(cuni(cv(s1))))))\n  -| diffss(s0, s1)\n} = {\n  ax-mp(wceq(cfv(c0, cv(s0)), cpr(cuni(cv(s0)), csuc(cuni(cv(s0))))), wcel(cv(s0), universe))\n  vex(s0)\n  fvmpt(s1, cv(s0), universe, c0, cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), cpr(cuni(cv(s1)), csuc(cuni(cv(s1)))))\n  preq12d(cuni(cv(s1)), csuc(cuni(cv(s1))), cuni(cv(s0)), csuc(cuni(cv(s0))), wceq(cv(s1), cv(s0)))\n  syl(wceq(cv(s1), cv(s0)), wceq(csuc(cuni(cv(s1))), csuc(cuni(cv(s0)))), wceq(cuni(cv(s1)), cuni(cv(s0))))\n  unieq(cv(s1), cv(s0))\n  suceq(cuni(cv(s1)), cuni(cv(s0)))\n  prex(cuni(cv(s0)), csuc(cuni(cv(s0))))\n  diff.universe.s(s1)\n  diff.cpr.s(s1, cuni(cv(s0)), csuc(cuni(cv(s0))))\n  diff.csuc.s(s1, cuni(cv(s0)))\n  diff.cuni.s(s1, cv(s0))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm onsetreclem1(setvar s0, setvar s1, class c0) {\n  âŠ¢ (c0 ` s0)= { â‹ƒ s0, suc(â‹ƒ s0)}\n  âŠ£ c0 =(s1 âˆˆ ğ•Œ â†¦ { â‹ƒ s1, suc(â‹ƒ s1)})\n  âŠ£ d(s0, s1)\n} = {\n  ax-mp((c0 ` s0)= { â‹ƒ s0, suc(â‹ƒ s0)}, s0 âˆˆ ğ•Œ)\n  vex(s0)\n  fvmpt(s1, s0, universe, c0, { â‹ƒ s0, suc(â‹ƒ s0)}, { â‹ƒ s1, suc(â‹ƒ s1)})\n  preq12d(â‹ƒ s1, suc(â‹ƒ s1), â‹ƒ s0, suc(â‹ƒ s0), s1 = s0)\n  syl(s1 = s0, suc(â‹ƒ s1)= suc(â‹ƒ s0), â‹ƒ s1 = â‹ƒ s0)\n  unieq(s1, s0)\n  suceq(â‹ƒ s1, â‹ƒ s0)\n  prex(â‹ƒ s0, suc(â‹ƒ s0))\n  diff.universe.s(s1)\n  diff.cpr.s(s1, â‹ƒ s0, suc(â‹ƒ s0))\n  diff.csuc.s(s1, â‹ƒ s0)\n  diff.cuni.s(s1, s0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["ax-mp","vex","fvmpt","preq12d","syl","unieq","suceq","prex","diff.universe.s","diff.cpr.s","diff.csuc.s","diff.cuni.s","diff.cv.s","diffss.ex"],"children":["onsetreclem2","onsetreclem3"]},{"name":"onsetreclem2","content":"Lemma for ~ onsetrec . (Contributed by Emmett Weisz, 22-Jun-2021.) (New usage is discouraged.)","origin":"thm onsetreclem2(setvar s0, setvar s1, class c0) {\n  |- wi(wss(cv(s0), con0), wss(cfv(c0, cv(s0)), con0))\n  -| wceq(c0, cmpt(s1, universe, cpr(cuni(cv(s1)), csuc(cuni(cv(s1))))))\n  -| diffss(s0, s1)\n} = {\n  syl5eqss(cfv(c0, cv(s0)), con0, cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), wss(cv(s0), con0))\n  onsetreclem1(s0, s1, c0)\n  syl(wss(cv(s0), con0), wss(cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), con0), wcel(cuni(cv(s0)), con0))\n  ssonunii(cv(s0))\n  vex(s0)\n  mpdan(wcel(cuni(cv(s0)), con0), wss(cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), con0), wcel(csuc(cuni(cv(s0))), con0))\n  suceloni(cuni(cv(s0)))\n  prssi(cuni(cv(s0)), con0, csuc(cuni(cv(s0))))\n}","pretty":"thm onsetreclem2(setvar s0, setvar s1, class c0) {\n  âŠ¢ (s0 âŠ† On â†’(c0 ` s0)âŠ† On)\n  âŠ£ c0 =(s1 âˆˆ ğ•Œ â†¦ { â‹ƒ s1, suc(â‹ƒ s1)})\n  âŠ£ d(s0, s1)\n} = {\n  syl5eqss((c0 ` s0), con0, { â‹ƒ s0, suc(â‹ƒ s0)}, s0 âŠ† On)\n  onsetreclem1(s0, s1, c0)\n  syl(s0 âŠ† On, { â‹ƒ s0, suc(â‹ƒ s0)} âŠ† On, â‹ƒ s0 âˆˆ On)\n  ssonunii(s0)\n  vex(s0)\n  mpdan(â‹ƒ s0 âˆˆ On, { â‹ƒ s0, suc(â‹ƒ s0)} âŠ† On, suc(â‹ƒ s0)âˆˆ On)\n  suceloni(â‹ƒ s0)\n  prssi(â‹ƒ s0, con0, suc(â‹ƒ s0))\n}","parent":["syl5eqss","onsetreclem1","syl","ssonunii","vex","mpdan","suceloni","prssi"],"children":["onsetrec"]},{"name":"onsetreclem3","content":"Lemma for ~ onsetrec . (Contributed by Emmett Weisz, 22-Jun-2021.) (New usage is discouraged.)","origin":"thm onsetreclem3(setvar s0, setvar s1, class c0) {\n  |- wi(wcel(cv(s0), con0), wcel(cv(s0), cfv(c0, cv(s0))))\n  -| wceq(c0, cmpt(s1, universe, cpr(cuni(cv(s1)), csuc(cuni(cv(s1))))))\n  -| diffss(s0, s1)\n} = {\n  syl6eleqr(cv(s0), cfv(c0, cv(s0)), cpr(cuni(cv(s0)), csuc(cuni(cv(s0)))), wcel(cv(s0), con0))\n  sylibr(wcel(cv(s0), con0), wcel(cv(s0), cpr(cuni(cv(s0)), csuc(cuni(cv(s0))))), wo(wceq(cv(s0), cuni(cv(s0))), wceq(cv(s0), csuc(cuni(cv(s0))))))\n  syl(wcel(cv(s0), con0), wo(wceq(cv(s0), cuni(cv(s0))), wceq(cv(s0), csuc(cuni(cv(s0))))), word(cv(s0)))\n  eloni(cv(s0))\n  orduniorsuc(cv(s0))\n  elpr(cv(s0), cuni(cv(s0)), csuc(cuni(cv(s0))))\n  vex(s0)\n  onsetreclem1(s0, s1, c0)\n}","pretty":"thm onsetreclem3(setvar s0, setvar s1, class c0) {\n  âŠ¢ (s0 âˆˆ On â†’ s0 âˆˆ(c0 ` s0))\n  âŠ£ c0 =(s1 âˆˆ ğ•Œ â†¦ { â‹ƒ s1, suc(â‹ƒ s1)})\n  âŠ£ d(s0, s1)\n} = {\n  syl6eleqr(s0, (c0 ` s0), { â‹ƒ s0, suc(â‹ƒ s0)}, s0 âˆˆ On)\n  sylibr(s0 âˆˆ On, s0 âˆˆ { â‹ƒ s0, suc(â‹ƒ s0)}, (s0 = â‹ƒ s0 âˆ¨ s0 = suc(â‹ƒ s0)))\n  syl(s0 âˆˆ On, (s0 = â‹ƒ s0 âˆ¨ s0 = suc(â‹ƒ s0)), Ord(s0))\n  eloni(s0)\n  orduniorsuc(s0)\n  elpr(s0, â‹ƒ s0, suc(â‹ƒ s0))\n  vex(s0)\n  onsetreclem1(s0, s1, c0)\n}","parent":["syl6eleqr","sylibr","syl","eloni","orduniorsuc","elpr","vex","onsetreclem1"],"children":["onsetrec"]},{"name":"onsetrec","content":"Construct ` On ` using set recursion. When ` x e. On ` , the function ` F ` constructs the least ordinal greater than any of the elements of ` x ` , which is ` U. x ` for a limit ordinal and ` suc U. x ` for a successor ordinal. For example, ` ( F `` { 1o , 2o } ) ` ` = { U. { 1o , 2o } , suc U. { 1o , 2o } } = { 2o , 3o } ` which contains ` 3o ` , and ` ( F `` _om ) = { U. _om , suc U. _om } = { _om , _om +o 1o } ` , which contains ` _om ` . If we start with the empty set and keep applying ` F ` transfinitely many times, all ordinal numbers will be generated. Any function ` F ` fulfilling lemmas ~ onsetreclem2 and ~ onsetreclem3 will recursively generate ` On ` ; for example, ` F = ( x e. _V |-> suc suc U. x } ) ` also works. Whether this function or the function in the theorem is used, taking this theorem as a definition of ` On ` is unsatisfying because it relies on the different properties of limit and successor ordinals. A different approach could be to let ` F = ( x e. _V |-> { y e. ~P x | Tr y } ) ` , based on ~ dfon2 . The proof of this theorem uses the dummy variable ` a ` rather than ` x ` to avoid a distinct variable condition between ` F ` and ` x ` . (Contributed by Emmett Weisz, 22-Jun-2021.)","origin":"thm onsetrec(setvar s0, class c0) {\n  |- wceq(csetrecs(c0), con0)\n  -| wceq(c0, cmpt(s0, universe, cpr(cuni(cv(s0)), csuc(cuni(cv(s0))))))\n} = {\n  mp2an(wceq(csetrecs(c0), con0), wss(csetrecs(c0), con0), wral(hs0, con0, wi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0)))))\n  mptru(wss(csetrecs(c0), con0))\n  setrec2v(hs0, csetrecs(c0), con0, c0, wtru)\n  a1i(wtru, wal(hs0, wi(wss(cv(hs0), con0), wss(cfv(c0, cv(hs0)), con0))))\n  ax-gen(hs0, wi(wss(cv(hs0), con0), wss(cfv(c0, cv(hs0)), con0)))\n  onsetreclem2(hs0, s0, c0)\n  rgen(hs0, con0, wi(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0))))\n  com12(wcel(cv(hs0), con0), wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), csetrecs(c0)))\n  syl2im(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), con0), wcel(cv(hs0), csetrecs(c0)), wss(cfv(c0, cv(hs0)), csetrecs(c0)), wcel(cv(hs0), cfv(c0, cv(hs0))))\n  setrec1(c0, cv(hs0), csetrecs(c0), wss(cv(hs0), csetrecs(c0)))\n  eqid(csetrecs(c0))\n  a1i(wss(cv(hs0), csetrecs(c0)), wcel(cv(hs0), universe))\n  vex(hs0)\n  id(wss(cv(hs0), csetrecs(c0)))\n  onsetreclem3(hs0, s0, c0)\n  ssel(cfv(c0, cv(hs0)), csetrecs(c0), cv(hs0))\n  tfi(hs0, csetrecs(c0))\n  diff.hs0.c(con0)\n  diff.hs0.c(c0)\n  diff.hs0.s(s0)\n  diff.hs0.c(csetrecs(c0))\n}","pretty":"thm onsetrec(setvar s0, class c0) {\n  âŠ¢ setrecs(c0)= On\n  âŠ£ c0 =(s0 âˆˆ ğ•Œ â†¦ { â‹ƒ s0, suc(â‹ƒ s0)})\n} = {\n  mp2an(setrecs(c0)= On, setrecs(c0)âŠ† On, âˆ€(hs0 âˆˆ On,(hs0 âŠ† setrecs(c0)â†’ hs0 âˆˆ setrecs(c0))))\n  mptru(setrecs(c0)âŠ† On)\n  setrec2v(hs0, setrecs(c0), con0, c0, wtru)\n  a1i(wtru, âˆ€(hs0,(hs0 âŠ† On â†’(c0 ` hs0)âŠ† On)))\n  ax-gen(hs0, (hs0 âŠ† On â†’(c0 ` hs0)âŠ† On))\n  onsetreclem2(hs0, s0, c0)\n  rgen(hs0, con0, (hs0 âŠ† setrecs(c0)â†’ hs0 âˆˆ setrecs(c0)))\n  com12(hs0 âˆˆ On, hs0 âŠ† setrecs(c0), hs0 âˆˆ setrecs(c0))\n  syl2im(hs0 âŠ† setrecs(c0), hs0 âˆˆ On, hs0 âˆˆ setrecs(c0), (c0 ` hs0)âŠ† setrecs(c0), hs0 âˆˆ(c0 ` hs0))\n  setrec1(c0, hs0, setrecs(c0), hs0 âŠ† setrecs(c0))\n  eqid(setrecs(c0))\n  a1i(hs0 âŠ† setrecs(c0), hs0 âˆˆ ğ•Œ)\n  vex(hs0)\n  id(hs0 âŠ† setrecs(c0))\n  onsetreclem3(hs0, s0, c0)\n  ssel((c0 ` hs0), setrecs(c0), hs0)\n  tfi(hs0, setrecs(c0))\n  diff.hs0.c(con0)\n  diff.hs0.c(c0)\n  diff.hs0.s(s0)\n  diff.hs0.c(setrecs(c0))\n}","parent":["mp2an","mptru","setrec2v","a1i","ax-gen","onsetreclem2","rgen","com12","syl2im","setrec1","eqid","vex","id","onsetreclem3","ssel","tfi","diff.hs0.c","diff.hs0.s"],"children":[]}]}