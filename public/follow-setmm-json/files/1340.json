{"index":1340,"title":"_Begriffsschrift_ Chapter I","content":"Section 2 introduces the turnstile ` |- ` which turns an idea which may be true ` ph ` into an assertion that it does hold true ` |- ph ` . Section 5 introduces implication, ` ( ph -> ps ) ` . Section 6 introduces the single rule of interference relied upon, modus ponens ~ ax-mp . Section 7 introduces negation and with in synonyms for or ` ( -. ph -> ps ) ` , and ` -. ( ph -> -. ps ) ` , and two for exclusive-or corresponding to ~ df-or , ~ df-an , ~ dfxor4 , ~ dfxor5 . Section 8 introduces the problematic notation for identity of conceptual content which must be separated into cases for biimplication ` ( ph <-> ps ) ` or class equality ` A = B ` in this adaptation. Section 10 introduces \"truth functions\" for one or two variables in equally troubling notation, as the arguments may be understood to be logical predicates or collections. Here f( ` ph ` ) is interpreted to mean ` if- ( ph , ps , ch ) ` where the content of the \"function\" is specified by the latter two argments or logical equivalent, while g( ` A ` ) is read as ` A e. G ` and h( ` A , B ` ) as ` A H B ` . This necessarily introduces a need for set theory as both ` A e. G ` and ` A H B ` cannot hold unless ` A ` is a set. (Also ` B ` .) Section 11 introduces notation for generality, but there is no standard notation for generality when the variable is a proposition because it was realized after Frege that the universe of all possible propositions includes paradoxical constructions leading to the failure of naive set theory. So adopting f( ` ph ` ) as ` if- ( ph , ps , ch ) ` would result in the translation of ` A. ph ` f ( ` ph ` ) as ` ( ps /\\ ch ) ` . For collections, we must generalize over set variables or run into the same problems; this leads to ` A. A ` g( ` A ` ) being translated as ` A. a a e. G ` and so forth. Under this interpreation the text of section 11 gives us ~ sp (or ~ simpl and ~ simpr and ~ anifp in the propositional case) and statements similar to ~ cbvalivw , ~ ax-gen , ~ alrimiv , and ~ alrimdv . These last four introduce a generality and have no useful definition in terms of propositional variables. Section 12 introduces some combinations of primitive symbols and their human language counterparts. Using class notation, these can also be expressed without dummy variables. All are A, ` A. x x e. A ` , ` -. E. x -. x e. A ` ~ alex , ` A = _V ` ~ eqv ; Some are not B, ` -. A. x x e. B ` , ` E. x -. x e. B ` ~ exnal , ` B C. _V ` ~ pssv , ` B =/= _V ` ~ nev ; There are no C, ` A. x -. x e. C ` , ` -. E. x x e. C ` ~ alnex , ` C = (/) ` ~ eq0 ; There exist D, ` -. A. x -. x e. D ` , ` E. x x e. D ` ~ df-ex , ` (/) C. D ` ~ 0pss , ` D =/= (/) ` ~ n0 . Notation for relations between expressions also can be written in various ways. All E are P, ` A. x ( x e. E -> x e. P ) ` , ` -. E. x ( x e. E /\\ -. x e. P ) ` ~ dfss6 , ` E = ( E i^i P ) ` ~ df-ss , ` E C_ P ` ~ dfss2 ; No F are P, ` A. x ( x e. F -> -. x e. P ) ` , ` -. E. x ( x e. F /\\ x e. P ) ` ~ alinexa , ` ( F i^i P ) = (/) ` ~ disj1 ; Some G are not P, ` -. A. x ( x e. G -> x e. P ) ` , ` E. x ( x e. G /\\ -. x e. P ) ` ~ exanali , ` ( G i^i P ) C. G ` ~ nssinpss , ` -. G C_ P ` ~ nss ; Some H are P, ` -. A. x ( x e. H -> -. x e. P ) ` , ` E. x ( x e. H /\\ x e. P ) ` ~ bj-exnalimn , ` (/) C. ( H i^i P ) ` ~ 0pssin , ` ( H i^i P ) =/= (/) ` ~ ndisj .","blocks":[{"name":"dfxor4","content":"Express exclusive-or in terms of implication and negation. Statement in [Frege1879] p. 12. (Contributed by RP, 14-Apr-2020.)","origin":"thm dfxor4(wff w0, wff w1) {\n  |- wb(wxo(w0, w1), wn(wi(wi(wn(w0), w1), wn(wi(w0, wn(w1))))))\n} = {\n  3bitri(wxo(w0, w1), wn(wi(wi(wn(w0), w1), wn(wi(w0, wn(w1))))), wa(wo(w0, w1), wn(wa(w0, w1))), wa(wi(wn(w0), w1), wi(w0, wn(w1))))\n  xor2(w0, w1)\n  anbi12i(wo(w0, w1), wn(wa(w0, w1)), wi(wn(w0), w1), wi(w0, wn(w1)))\n  df-or(w0, w1)\n  bicomi(wn(wa(w0, w1)), wi(w0, wn(w1)))\n  imnan(w0, w1)\n  df-an(wi(wn(w0), w1), wi(w0, wn(w1)))\n}","pretty":"thm dfxor4(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)↔ ¬((¬ w0 → w1)→ ¬(w0 → ¬ w1)))\n} = {\n  3bitri((w0 ⊻ w1), ¬((¬ w0 → w1)→ ¬(w0 → ¬ w1)), ((w0 ∨ w1)∧ ¬(w0 ∧ w1)), ((¬ w0 → w1)∧(w0 → ¬ w1)))\n  xor2(w0, w1)\n  anbi12i((w0 ∨ w1), ¬(w0 ∧ w1), (¬ w0 → w1), (w0 → ¬ w1))\n  df-or(w0, w1)\n  bicomi(¬(w0 ∧ w1), (w0 → ¬ w1))\n  imnan(w0, w1)\n  df-an((¬ w0 → w1), (w0 → ¬ w1))\n}","parent":["3bitri","xor2","anbi12i","df-or","bicomi","imnan","df-an"],"children":["dfxor5"]},{"name":"dfxor5","content":"Express exclusive-or in terms of implication and negation. Statement in [Frege1879] p. 12. (Contributed by RP, 14-Apr-2020.)","origin":"thm dfxor5(wff w0, wff w1) {\n  |- wb(wxo(w0, w1), wn(wi(wi(w0, wn(w1)), wn(wi(wn(w0), w1)))))\n} = {\n  xchbinx(wxo(w0, w1), wi(wi(w0, wn(w1)), wn(wi(wn(w0), w1))), wi(wi(wn(w0), w1), wn(wi(w0, wn(w1)))))\n  dfxor4(w0, w1)\n  con2b(wi(wn(w0), w1), wi(w0, wn(w1)))\n}","pretty":"thm dfxor5(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)↔ ¬((w0 → ¬ w1)→ ¬(¬ w0 → w1)))\n} = {\n  xchbinx((w0 ⊻ w1), ((w0 → ¬ w1)→ ¬(¬ w0 → w1)), ((¬ w0 → w1)→ ¬(w0 → ¬ w1)))\n  dfxor4(w0, w1)\n  con2b((¬ w0 → w1), (w0 → ¬ w1))\n}","parent":["xchbinx","dfxor4","con2b"],"children":[]},{"name":"df3or2","content":"Express triple-or in terms of implication and negation. Statement in [Frege1879] p. 11. (Contributed by RP, 25-Jul-2020.)","origin":"thm df3or2(wff w0, wff w1, wff w2) {\n  |- wb(w3o(w0, w1, w2), wi(wn(w0), wi(wn(w1), w2)))\n} = {\n  bitri(w3o(w0, w1, w2), wi(wn(w0), wi(wn(w1), w2)), wo(wo(w0, w1), w2))\n  df-3or(w0, w1, w2)\n  bitri(wo(wo(w0, w1), w2), wi(wn(w0), wi(wn(w1), w2)), wi(wn(wo(w0, w1)), w2))\n  df-or(wo(w0, w1), w2)\n  bitri(wi(wn(wo(w0, w1)), w2), wi(wn(w0), wi(wn(w1), w2)), wi(wa(wn(w0), wn(w1)), w2))\n  imbi1i(wn(wo(w0, w1)), w2, wa(wn(w0), wn(w1)))\n  ioran(w0, w1)\n  impexp(wn(w0), wn(w1), w2)\n}","pretty":"thm df3or2(wff w0, wff w1, wff w2) {\n  ⊢ ((w0 ∨ w1 ∨ w2)↔(¬ w0 →(¬ w1 → w2)))\n} = {\n  bitri((w0 ∨ w1 ∨ w2), (¬ w0 →(¬ w1 → w2)), ((w0 ∨ w1)∨ w2))\n  df-3or(w0, w1, w2)\n  bitri(((w0 ∨ w1)∨ w2), (¬ w0 →(¬ w1 → w2)), (¬(w0 ∨ w1)→ w2))\n  df-or((w0 ∨ w1), w2)\n  bitri((¬(w0 ∨ w1)→ w2), (¬ w0 →(¬ w1 → w2)), ((¬ w0 ∧ ¬ w1)→ w2))\n  imbi1i(¬(w0 ∨ w1), w2, (¬ w0 ∧ ¬ w1))\n  ioran(w0, w1)\n  impexp(¬ w0, ¬ w1, w2)\n}","parent":["bitri","df-3or","df-or","imbi1i","ioran","impexp"],"children":[]},{"name":"df3an2","content":"Express triple-and in terms of implication and negation. Statement in [Frege1879] p. 12. (Contributed by RP, 25-Jul-2020.)","origin":"thm df3an2(wff w0, wff w1, wff w2) {\n  |- wb(w3a(w0, w1, w2), wn(wi(w0, wi(w1, wn(w2)))))\n} = {\n  bitri(w3a(w0, w1, w2), wn(wi(w0, wi(w1, wn(w2)))), wa(wa(w0, w1), w2))\n  df-3an(w0, w1, w2)\n  xchbinx(wa(wa(w0, w1), w2), wi(w0, wi(w1, wn(w2))), wi(wa(w0, w1), wn(w2)))\n  df-an(wa(w0, w1), w2)\n  impexp(w0, w1, wn(w2))\n}","pretty":"thm df3an2(wff w0, wff w1, wff w2) {\n  ⊢ ((w0 ∧ w1 ∧ w2)↔ ¬(w0 →(w1 → ¬ w2)))\n} = {\n  bitri((w0 ∧ w1 ∧ w2), ¬(w0 →(w1 → ¬ w2)), ((w0 ∧ w1)∧ w2))\n  df-3an(w0, w1, w2)\n  xchbinx(((w0 ∧ w1)∧ w2), (w0 →(w1 → ¬ w2)), ((w0 ∧ w1)→ ¬ w2))\n  df-an((w0 ∧ w1), w2)\n  impexp(w0, w1, ¬ w2)\n}","parent":["bitri","df-3an","xchbinx","df-an","impexp"],"children":[]},{"name":"nev","content":"Express that not every set is in a class. (Contributed by RP, 16-Apr-2020.)","origin":"thm nev(setvar s0, class c0) {\n  |- wb(wne(c0, universe), wn(wal(s0, wcel(cv(s0), c0))))\n  -| diffsc(s0, c0)\n} = {\n  necon3abii(c0, universe, wal(s0, wcel(cv(s0), c0)))\n  eqv(s0, c0)\n}","pretty":"thm nev(setvar s0, class c0) {\n  ⊢ (c0 ≠ 𝕌 ↔ ¬ ∀(s0, s0 ∈ c0))\n  ⊣ d(s0, c0)\n} = {\n  necon3abii(c0, universe, ∀(s0, s0 ∈ c0))\n  eqv(s0, c0)\n}","parent":["necon3abii","eqv"],"children":[]},{"name":"0pssin","content":"Express that an intersection is not empty. (Contributed by RP, 16-Apr-2020.)","origin":"thm 0pssin(setvar s0, class c0, class c1) {\n  |- wb(wpss(emptycls, cin(c0, c1)), wex(s0, wa(wcel(cv(s0), c0), wcel(cv(s0), c1))))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n} = {\n  bitri(wpss(emptycls, cin(c0, c1)), wex(s0, wa(wcel(cv(s0), c0), wcel(cv(s0), c1))), wne(cin(c0, c1), emptycls))\n  0pss(cin(c0, c1))\n  ndisj(s0, c0, c1)\n}","pretty":"thm 0pssin(setvar s0, class c0, class c1) {\n  ⊢ (∅ ⊊(c0 ⋂ c1)↔ ∃(s0,(s0 ∈ c0 ∧ s0 ∈ c1)))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n} = {\n  bitri(∅ ⊊(c0 ⋂ c1), ∃(s0,(s0 ∈ c0 ∧ s0 ∈ c1)), (c0 ⋂ c1)≠ ∅)\n  0pss((c0 ⋂ c1))\n  ndisj(s0, c0, c1)\n}","parent":["bitri","0pss","ndisj"],"children":[]}]}