{"index":681,"title":"The edge function extractor for extensible structures","content":"","blocks":[{"name":"cedgf","content":"Extend class notation with an edge function.","origin":"const class cedgf { .ef }","pretty":"","parent":[],"children":[]},{"name":"diff.cedgf.s","content":"","origin":"axiom diff.cedgf.s(setvar s0) {\n  |- diffsc(s0, cedgf)\n}","pretty":"axiom diff.cedgf.s(setvar s0) {\n  ⊢ d(s0, .ef)\n}","parent":[],"children":[]},{"name":"diff.cedgf.c","content":"","origin":"axiom diff.cedgf.c(class c0) {\n  |- diffcc(cedgf, c0)\n}","pretty":"axiom diff.cedgf.c(class c0) {\n  ⊢ d(.ef, c0)\n}","parent":[],"children":[]},{"name":"diff.cedgf.w","content":"","origin":"axiom diff.cedgf.w(wff w0) {\n  |- diffcw(cedgf, w0)\n}","pretty":"axiom diff.cedgf.w(wff w0) {\n  ⊢ d(.ef, w0)\n}","parent":[],"children":[]},{"name":"df-edgf","content":"Define the edge function (indexed edges) of a graph. (Contributed by AV, 18-Jan-2020.)","origin":"axiom df-edgf() {\n  |- wceq(cedgf, cslot(cdc(nat1, nat8)))\n}","pretty":"axiom df-edgf() {\n  ⊢ .ef = Slot(cdc(1, 8))\n}","parent":[],"children":["edgfid","edgfndxnn","edgfndxid","baseltedgf","iedgval0"]},{"name":"edgfid","content":"Utility theorem: index-independent form of ~ df-edgf . (Contributed by AV, 16-Nov-2021.)","origin":"thm edgfid() {\n  |- wceq(cedgf, cslot(cfv(cedgf, cnx)))\n} = {\n  ndxid(cedgf, cdc(nat1, nat8))\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","pretty":"thm edgfid() {\n  ⊢ .ef = Slot((.ef ` ndx))\n} = {\n  ndxid(cedgf, cdc(1, 8))\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","parent":["ndxid","df-edgf","decnncl","1nn0","8nn"],"children":["edgfiedgval","setsiedg"]},{"name":"edgfndxnn","content":"The index value of the edge function extractor is a positive integer. This property should be ensured for every concrete coding because otherwise it could not be used in an extensible structure (slots must be positive integers). (Contributed by AV, 21-Sep-2020.)","origin":"thm edgfndxnn() {\n  |- wcel(cfv(cedgf, cnx), cn)\n} = {\n  eqeltri(cfv(cedgf, cnx), cn, cdc(nat1, nat8))\n  ndxarg(cedgf, cdc(nat1, nat8))\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","pretty":"thm edgfndxnn() {\n  ⊢ (.ef ` ndx)∈ ℕ\n} = {\n  eqeltri((.ef ` ndx), cn, cdc(1, 8))\n  ndxarg(cedgf, cdc(1, 8))\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","parent":["eqeltri","ndxarg","df-edgf","decnncl","1nn0","8nn"],"children":["struct2grstr","struct2grvtx"]},{"name":"edgfndxid","content":"The value of the edge function extractor is the value of the corresponding slot of the structure. (Contributed by AV, 21-Sep-2020.)","origin":"thm edgfndxid(class c0, class c1) {\n  |- wi(wcel(c0, c1), wceq(cfv(cedgf, c0), cfv(c0, cfv(cedgf, cnx))))\n} = {\n  eqcomd(cfv(cedgf, c0), cfv(c0, cfv(cedgf, cnx)), wcel(c0, c1))\n  strndxid(c0, cedgf, c1, cdc(nat1, nat8), wcel(c0, c1))\n  id(wcel(c0, c1))\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","pretty":"thm edgfndxid(class c0, class c1) {\n  ⊢ (c0 ∈ c1 →(.ef ` c0)=(c0 `(.ef ` ndx)))\n} = {\n  eqcomd((.ef ` c0), (c0 `(.ef ` ndx)), c0 ∈ c1)\n  strndxid(c0, cedgf, c1, cdc(1, 8), c0 ∈ c1)\n  id(c0 ∈ c1)\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","parent":["eqcomd","strndxid","id","df-edgf","decnncl","1nn0","8nn"],"children":["structiedg0val","snstriedgval"]},{"name":"baseltedgf","content":"The index value of the ` Base ` slot is less than the index value of the ` .ef ` slot. (Contributed by AV, 21-Sep-2020.)","origin":"thm baseltedgf() {\n  |- wbr(cfv(cbs, cnx), clt, cfv(cedgf, cnx))\n} = {\n  3brtr4i(cfv(cbs, cnx), clt, cfv(cedgf, cnx), nat1, cdc(nat1, nat8))\n  declti(nat1, nat1, nat8)\n  8nn0()\n  1lt10()\n  ndxarg(cbs, nat1)\n  df-base()\n  1nn()\n  ndxarg(cedgf, cdc(nat1, nat8))\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","pretty":"thm baseltedgf() {\n  ⊢ (Base ` ndx)[<](.ef ` ndx)\n} = {\n  3brtr4i((Base ` ndx), clt, (.ef ` ndx), nat1, cdc(1, 8))\n  declti(nat1, nat1, nat8)\n  8nn0()\n  1lt10()\n  ndxarg(cbs, nat1)\n  df-base()\n  1nn()\n  ndxarg(cedgf, cdc(1, 8))\n  df-edgf()\n  decnncl(nat1, nat8)\n  1nn0()\n  8nn()\n}","parent":["3brtr4i","declti","8nn0","1lt10","ndxarg","df-base","1nn","df-edgf","decnncl","1nn0","8nn"],"children":["slotsbaseefdif","struct2grstr","struct2grvtx"]},{"name":"slotsbaseefdif","content":"The slots ` Base ` and ` .ef ` are different. (Contributed by AV, 21-Sep-2020.)","origin":"thm slotsbaseefdif() {\n  |- wne(cfv(cbs, cnx), cfv(cedgf, cnx))\n} = {\n  ltneii(cfv(cbs, cnx), cfv(cedgf, cnx))\n  nnrei(cfv(cbs, cnx))\n  basendxnn()\n  baseltedgf()\n}","pretty":"thm slotsbaseefdif() {\n  ⊢ (Base ` ndx)≠(.ef ` ndx)\n} = {\n  ltneii((Base ` ndx), (.ef ` ndx))\n  nnrei((Base ` ndx))\n  basendxnn()\n  baseltedgf()\n}","parent":["ltneii","nnrei","basendxnn","baseltedgf"],"children":["funvtxval","funiedgval","structiedg0val","structgrssvtxlem","setsvtx","snstriedgval"]}]}