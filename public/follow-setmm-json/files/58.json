{"index":58,"title":"Axiom scheme ax-8 (Left Equality for Binary Predicate)","content":"","blocks":[{"name":"wcel","content":"Extend wff definition to include the membership connective between classes. For a general discussion of the theory of classes, see ~ mmset.html#class . (The purpose of introducing ` wff A e. B ` here is to allow us to express, i.e., \"prove\", the ~ wel of predicate calculus in terms of the ~ wcel of set theory, so that we do not \"overload\" the ` e. ` connective with two syntax definitions. This is done to prevent ambiguity that would complicate some Metamath parsers. The class variables ` A ` and ` B ` are introduced temporarily for the purpose of this definition but otherwise not used in predicate calculus. See ~ df-clab for more information on the set theory usage of ~ wcel .)","origin":"prop wff wcel(class c0, class c1) { c0 ∈ c1 }","pretty":"","parent":[],"children":[]},{"name":"diff.wcel.s","content":"","origin":"axiom diff.wcel.s(setvar sBase, class c0, class c1) {\n  |- diffsw(sBase, wcel(c0, c1))\n  -| diffsc(sBase, c0)\n  -| diffsc(sBase, c1)\n}","pretty":"axiom diff.wcel.s(setvar sBase, class c0, class c1) {\n  ⊢ d(sBase, c0 ∈ c1)\n  ⊣ d(sBase, c0)\n  ⊣ d(sBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wcel.c","content":"","origin":"axiom diff.wcel.c(class cBase, class c0, class c1) {\n  |- diffcw(cBase, wcel(c0, c1))\n  -| diffcc(cBase, c0)\n  -| diffcc(cBase, c1)\n}","pretty":"axiom diff.wcel.c(class cBase, class c0, class c1) {\n  ⊢ d(cBase, c0 ∈ c1)\n  ⊣ d(cBase, c0)\n  ⊣ d(cBase, c1)\n}","parent":[],"children":[]},{"name":"diff.wcel.w","content":"","origin":"axiom diff.wcel.w(wff wBase, class c0, class c1) {\n  |- diffww(wBase, wcel(c0, c1))\n  -| diffcw(c0, wBase)\n  -| diffcw(c1, wBase)\n}","pretty":"axiom diff.wcel.w(wff wBase, class c0, class c1) {\n  ⊢ d(wBase, c0 ∈ c1)\n  ⊣ d(c0, wBase)\n  ⊣ d(c1, wBase)\n}","parent":[],"children":[]},{"name":"ax-8","content":"Axiom of Left Equality for Binary Predicate. One of the equality and substitution axioms for a non-logical predicate in our predicate calculus with equality. It substitutes equal variables into the left-hand side of an arbitrary binary predicate ` e. ` , which we will use for the set membership relation when set theory is introduced. This axiom scheme is a sub-scheme of Axiom Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our notation. Also appears as Axiom scheme C12' in [Megill] p. 448 (p. 16 of the preprint). \"Non-logical\" means that the predicate is not a primitive of predicate calculus proper but instead is an extension to it. \"Binary\" means that the predicate has two arguments. In a system of predicate calculus with equality, like ours, equality is not usually considered to be a non-logical predicate. In systems of predicate calculus without equality, it typically would be. We prove in ~ ax8 that this axiom can be recovered from its weakened version ~ ax8v where ` x ` and ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-8 should be ~ ax8v . See the comment of ~ ax8v for more details on these matters. (Contributed by NM, 30-Jun-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax8 instead. (New usage is discouraged.)","origin":"axiom ax-8(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n}","pretty":"axiom ax-8(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 ∈ s2 → s1 ∈ s2))\n}","parent":[],"children":["ax8v"]},{"name":"ax8v","content":"Weakened version of ~ ax-8 , with a disjoint variable condition on ` x , y ` . This should be the only proof referencing ~ ax-8 , and it should be referenced only by its two weakened versions ~ ax8v1 and ~ ax8v2 , from which ~ ax-8 is then rederived as ~ ax8 , which shows that either ~ ax8v or the conjunction of ~ ax8v1 and ~ ax8v2 is sufficient. (Contributed by BJ, 7-Dec-2020.) Use ~ ax8 instead. (New usage is discouraged.)","origin":"thm ax8v(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n  -| diffss(s0, s1)\n} = {\n  a1ii(wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2)))), diffss(s0, s1))\n  ax-8(s0, s1, s2)\n}","pretty":"thm ax8v(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 ∈ s2 → s1 ∈ s2))\n  ⊣ d(s0, s1)\n} = {\n  a1ii((s0 = s1 →(s0 ∈ s2 → s1 ∈ s2)), d(s0, s1))\n  ax-8(s0, s1, s2)\n}","parent":["a1ii","ax-8"],"children":["ax8v1","ax8v2"]},{"name":"ax8v1","content":"First of two weakened versions of ~ ax8v , with an extra disjoint variable condition on ` x , z ` , see comments there. (Contributed by BJ, 7-Dec-2020.)","origin":"thm ax8v1(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n} = {\n  a1ii(wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2)))), diffss(s0, s2))\n  ax8v(s0, s1, s2)\n}","pretty":"thm ax8v1(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 ∈ s2 → s1 ∈ s2))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n} = {\n  a1ii((s0 = s1 →(s0 ∈ s2 → s1 ∈ s2)), d(s0, s2))\n  ax8v(s0, s1, s2)\n}","parent":["a1ii","ax8v"],"children":["ax8","bj-cleljusti","bj-ax9-2"]},{"name":"ax8v2","content":"Second of two weakened versions of ~ ax8v , with an extra disjoint variable condition on ` y , z ` see comments there. (Contributed by BJ, 7-Dec-2020.)","origin":"thm ax8v2(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n} = {\n  a1ii(wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2)))), diffss(s1, s2))\n  ax8v(s0, s1, s2)\n}","pretty":"thm ax8v2(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 ∈ s2 → s1 ∈ s2))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, s2)\n} = {\n  a1ii((s0 = s1 →(s0 ∈ s2 → s1 ∈ s2)), d(s1, s2))\n  ax8v(s0, s1, s2)\n}","parent":["a1ii","ax8v"],"children":["ax8","bj-ax9-2"]},{"name":"ax8","content":"Proof of ~ ax-8 from ~ ax8v1 and ~ ax8v2 , proving sufficiency of the conjunction of the latter two weakened versions of ~ ax8v , which is itself a weakened version of ~ ax-8 . (Contributed by BJ, 7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.)","origin":"thm ax8(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n} = {\n  sylbi(wceq(cv(s0), cv(s1)), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))), wex(hs0, wa(wceq(cv(hs0), cv(s0)), wceq(cv(hs0), cv(s1)))))\n  equvinv(s0, s1, hs0)\n  exlimiv(hs0, wa(wceq(cv(hs0), cv(s0)), wceq(cv(hs0), cv(s1))), wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n  sylan9(wceq(cv(hs0), cv(s0)), wceq(cv(hs0), cv(s1)), wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2)), wcel(cv(hs0), cv(s2)))\n  equcoms(hs0, s0, wi(wcel(cv(s0), cv(s2)), wcel(cv(hs0), cv(s2))))\n  ax8v2(s0, hs0, s2)\n  ax8v1(hs0, s1, s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s1, hs0)\n  diff.hs0.w(wi(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n  diff.hs0.s(s2)\n  diff.hs0.s(s1)\n}","pretty":"thm ax8(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 ∈ s2 → s1 ∈ s2))\n} = {\n  sylbi(s0 = s1, (s0 ∈ s2 → s1 ∈ s2), ∃(hs0,(hs0 = s0 ∧ hs0 = s1)))\n  equvinv(s0, s1, hs0)\n  exlimiv(hs0, (hs0 = s0 ∧ hs0 = s1), (s0 ∈ s2 → s1 ∈ s2))\n  sylan9(hs0 = s0, hs0 = s1, s0 ∈ s2, s1 ∈ s2, hs0 ∈ s2)\n  equcoms(hs0, s0, (s0 ∈ s2 → hs0 ∈ s2))\n  ax8v2(s0, hs0, s2)\n  ax8v1(hs0, s1, s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diffss.ex(s1, hs0)\n  diff.hs0.w((s0 ∈ s2 → s1 ∈ s2))\n  diff.hs0.s(s2)\n  diff.hs0.s(s1)\n}","parent":["sylbi","equvinv","exlimiv","sylan9","equcoms","ax8v2","ax8v1","diffss.ex","diff.hs0.s","diff.hs0.w"],"children":["elequ1","el","axextdfeq","ax8dfeq","exnel","bj-ax89","bj-el"]},{"name":"elequ1","content":"An identity law for the non-logical predicate. (Contributed by NM, 30-Jun-1993.)","origin":"thm elequ1(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wb(wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2))))\n} = {\n  impbid(wceq(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)), wcel(cv(s1), cv(s2)))\n  ax8(s0, s1, s2)\n  equcoms(s0, s1, wi(wcel(cv(s1), cv(s2)), wcel(cv(s0), cv(s2))))\n  ax8(s1, s0, s2)\n}","pretty":"thm elequ1(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(s0 ∈ s2 ↔ s1 ∈ s2))\n} = {\n  impbid(s0 = s1, s0 ∈ s2, s1 ∈ s2)\n  ax8(s0, s1, s2)\n  equcoms(s0, s1, (s1 ∈ s2 → s0 ∈ s2))\n  ax8(s1, s0, s2)\n}","parent":["impbid","ax8","equcoms"],"children":["cleljust","ax12wdemo","cleljustALT","cleljustALT2","dveel1","axc14","elsb3","axsep","nalset","zfpow","zfun","tz7.48lem","unxpdomlem1","pssnn","zfinf","aceq0","dfac3","dfac5lem2","dfac5lem3","dfac2a","zfac","nd1","axextnd","axrepndlem1","axrepndlem2","axunndlem1","axunnd","axpowndlem2","axpowndlem3","axpowndlem4","axregndlem1","axregnd","zfcndun","zfcndpow","zfcndinf","zfcndac","fpwwe2lem12","axgroth3","axgroth4","nqereu","mdetunilem9","madugsum","neiptopnei","2ndc1stc","nrmr0reg","alexsubALTlem4","xrsmopn","itg2cn","itgcn","sqff1o","dya2iocuni","bnj849","erdsze","untsucf","untangtr","dfon2lem3","dfon2lem6","dfon2lem7","dfon2","axextdist","distel","neibastop2lem","bj-elequ12","bj-axsep","bj-nfeel2","bj-ru0","prtlem5","ax12el","pw2f1ocnv","aomclem8","lcosslsp"]},{"name":"cleljust","content":"When the class variables in definition ~ df-clel are replaced with setvar variables, this theorem of predicate calculus is the result. This theorem provides part of the justification for the consistency of that definition, which \"overloads\" the setvar variables in ~ wel with the class variables in ~ wcel . (Contributed by NM, 28-Jan-2004.) Revised to use ~ equsexvw in order to remove dependencies on ~ ax-10 , ~ ax-12 , ~ ax-13 . Note that there is no disjoint variable condition on ` x , y ` , that is, on the variables of the left-hand side, as should be the case for definitions. (Revised by BJ, 29-Dec-2020.)","origin":"thm cleljust(setvar s0, setvar s1, setvar s2) {\n  |- wb(wcel(cv(s0), cv(s1)), wex(s2, wa(wceq(cv(s2), cv(s0)), wcel(cv(s2), cv(s1)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  bicomi(wcel(cv(s0), cv(s1)), wex(s2, wa(wceq(cv(s2), cv(s0)), wcel(cv(s2), cv(s1)))))\n  equsexvw(s2, s0, wcel(cv(s2), cv(s1)), wcel(cv(s0), cv(s1)))\n  elequ1(s2, s0, s1)\n  diff.wcel.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm cleljust(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 ∈ s1 ↔ ∃(s2,(s2 = s0 ∧ s2 ∈ s1)))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  bicomi(s0 ∈ s1, ∃(s2,(s2 = s0 ∧ s2 ∈ s1)))\n  equsexvw(s2, s0, s2 ∈ s1, s0 ∈ s1)\n  elequ1(s2, s0, s1)\n  diff.wcel.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["bicomi","equsexvw","elequ1","diff.wcel.s","diff.cv.s","diffss.ex"],"children":["bj-dfclel"]}]}