{"index":49,"title":"Non-freeness predicate","content":"","blocks":[{"name":"wnf","content":"Extend wff definition to include the not-free predicate.","origin":"prop wff wnf(setvar s0, wff w0) { F/(s0, w0) }","pretty":"","parent":[],"children":[]},{"name":"diff.wnf.s","content":"","origin":"axiom diff.wnf.s(setvar sBase, setvar s0, wff w0) {\n  |- diffsw(sBase, wnf(s0, w0))\n  -| diffss(sBase, s0)\n  -| diffsw(sBase, w0)\n}","pretty":"axiom diff.wnf.s(setvar sBase, setvar s0, wff w0) {\n  ⊢ d(sBase, F/(s0, w0))\n  ⊣ d(sBase, s0)\n  ⊣ d(sBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wnf.c","content":"","origin":"axiom diff.wnf.c(class cBase, setvar s0, wff w0) {\n  |- diffcw(cBase, wnf(s0, w0))\n  -| diffsc(s0, cBase)\n  -| diffcw(cBase, w0)\n}","pretty":"axiom diff.wnf.c(class cBase, setvar s0, wff w0) {\n  ⊢ d(cBase, F/(s0, w0))\n  ⊣ d(s0, cBase)\n  ⊣ d(cBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wnf.w","content":"","origin":"axiom diff.wnf.w(wff wBase, setvar s0, wff w0) {\n  |- diffww(wBase, wnf(s0, w0))\n  -| diffsw(s0, wBase)\n  -| diffww(wBase, w0)\n}","pretty":"axiom diff.wnf.w(wff wBase, setvar s0, wff w0) {\n  ⊢ d(wBase, F/(s0, w0))\n  ⊣ d(s0, wBase)\n  ⊣ d(wBase, w0)\n}","parent":[],"children":[]},{"name":"df-nf","content":"Define the not-free predicate for wffs. This is read \" ` x ` is not free in ` ph ` \". Not-free means that the value of ` x ` cannot affect the value of ` ph ` , e.g., any occurrence of ` x ` in ` ph ` is effectively bound by a \"for all\" or something that expands to one (such as \"there exists\"). In particular, substitution for a variable not free in a wff does not affect its value ( ~ sbf ). An example of where this is used is ~ stdpc5 . See ~ nf5 for an alternate definition which involves nested quantifiers on the same variable. Not-free is a commonly used constraint, so it is useful to have a notation for it. Surprisingly, there is no common formal notation for it, so here we devise one. Our definition lets us work with the not-free notion within the logic itself rather than as a metalogical side condition. To be precise, our definition really means \"effectively not free\", because it is slightly less restrictive than the usual textbook definition for not-free (which only considers syntactic freedom). For example, ` x ` is effectively not free in the formula ` x = x ` (see ~ nfequid ), even though ` x ` would be considered free in the usual textbook definition, because the value of ` x ` in the formula ` x = x ` cannot affect the truth of that formula (and thus substitutions will not change the result). This definition of not-free tightly ties to the quantifier ` A. x ` . At this state (no axioms restricting quantifiers yet) 'non-free' appears quite arbitrary. Its intended semantics expresses single-valuedness (constness) across a parameter, but is only evolved as much as later axioms assign properties to quantifiers. It seems the definition here is best suited in situations, where axioms are only partially in effect. In particular, this definition more easily carries over to other logic models with weaker axiomization. The reverse implication of the definiens (the right hand side of the biconditional) always holds, see ~ 19.2 . This predicate only applies to wffs. See ~ df-nfc for a not-free predicate for class variables. (Contributed by Mario Carneiro, 24-Sep-2016.) Convert to definition. (Revised by BJ, 6-May-2019.)","origin":"axiom df-nf(setvar s0, wff w0) {\n  |- wb(wnf(s0, w0), wi(wex(s0, w0), wal(s0, w0)))\n}","pretty":"axiom df-nf(setvar s0, wff w0) {\n  ⊢ (F/(s0, w0)↔(∃(s0, w0)→ ∀(s0, w0)))\n}","parent":[],"children":["nf2","nfi","nfri","nfd","nfrd","nfbiit","nfbidv","nfnf1","nf5r","nfbidf","nf5","nf6","nfnf","sbnf2","bj-nfimt","bj-ssbft","bj-nnfnfTEMP","bj-nfnnfTEMP"]},{"name":"nf2","content":"Alternate definition of non-freeness. (Contributed by BJ, 16-Sep-2021.)","origin":"thm nf2(setvar s0, wff w0) {\n  |- wb(wnf(s0, w0), wo(wal(s0, w0), wn(wex(s0, w0))))\n} = {\n  3bitri(wnf(s0, w0), wo(wal(s0, w0), wn(wex(s0, w0))), wi(wex(s0, w0), wal(s0, w0)), wo(wn(wex(s0, w0)), wal(s0, w0)))\n  df-nf(s0, w0)\n  imor(wex(s0, w0), wal(s0, w0))\n  orcom(wn(wex(s0, w0)), wal(s0, w0))\n}","pretty":"thm nf2(setvar s0, wff w0) {\n  ⊢ (F/(s0, w0)↔(∀(s0, w0)∨ ¬ ∃(s0, w0)))\n} = {\n  3bitri(F/(s0, w0), (∀(s0, w0)∨ ¬ ∃(s0, w0)), (∃(s0, w0)→ ∀(s0, w0)), (¬ ∃(s0, w0)∨ ∀(s0, w0)))\n  df-nf(s0, w0)\n  imor(∃(s0, w0), ∀(s0, w0))\n  orcom(¬ ∃(s0, w0), ∀(s0, w0))\n}","parent":["3bitri","df-nf","imor","orcom"],"children":["nf3"]},{"name":"nf3","content":"Alternate definition of non-freeness. (Contributed by BJ, 16-Sep-2021.)","origin":"thm nf3(setvar s0, wff w0) {\n  |- wb(wnf(s0, w0), wo(wal(s0, w0), wal(s0, wn(w0))))\n} = {\n  bitr4i(wnf(s0, w0), wo(wal(s0, w0), wal(s0, wn(w0))), wo(wal(s0, w0), wn(wex(s0, w0))))\n  nf2(s0, w0)\n  orbi2i(wal(s0, w0), wal(s0, wn(w0)), wn(wex(s0, w0)))\n  alnex(s0, w0)\n}","pretty":"thm nf3(setvar s0, wff w0) {\n  ⊢ (F/(s0, w0)↔(∀(s0, w0)∨ ∀(s0, ¬ w0)))\n} = {\n  bitr4i(F/(s0, w0), (∀(s0, w0)∨ ∀(s0, ¬ w0)), (∀(s0, w0)∨ ¬ ∃(s0, w0)))\n  nf2(s0, w0)\n  orbi2i(∀(s0, w0), ∀(s0, ¬ w0), ¬ ∃(s0, w0))\n  alnex(s0, w0)\n}","parent":["bitr4i","nf2","orbi2i","alnex"],"children":["nf4","nfnbi","nfim1","dfnf5"]},{"name":"nf4","content":"Alternate definition of non-freeness. This definition uses only primitive symbols ( ` -> , -. , A. ` ). (Contributed by BJ, 16-Sep-2021.)","origin":"thm nf4(setvar s0, wff w0) {\n  |- wb(wnf(s0, w0), wi(wn(wal(s0, w0)), wal(s0, wn(w0))))\n} = {\n  bitri(wnf(s0, w0), wi(wn(wal(s0, w0)), wal(s0, wn(w0))), wo(wal(s0, w0), wal(s0, wn(w0))))\n  nf3(s0, w0)\n  df-or(wal(s0, w0), wal(s0, wn(w0)))\n}","pretty":"thm nf4(setvar s0, wff w0) {\n  ⊢ (F/(s0, w0)↔(¬ ∀(s0, w0)→ ∀(s0, ¬ w0)))\n} = {\n  bitri(F/(s0, w0), (¬ ∀(s0, w0)→ ∀(s0, ¬ w0)), (∀(s0, w0)∨ ∀(s0, ¬ w0)))\n  nf3(s0, w0)\n  df-or(∀(s0, w0), ∀(s0, ¬ w0))\n}","parent":["bitri","nf3","df-or"],"children":[]},{"name":"nfi","content":"Deduce that ` x ` is not free in ` ph ` from the definition. (Contributed by Wolf Lammen, 15-Sep-2021.)","origin":"thm nfi(setvar s0, wff w0) {\n  |- wnf(s0, w0)\n  -| wi(wex(s0, w0), wal(s0, w0))\n} = {\n  mpbir(wnf(s0, w0), wi(wex(s0, w0), wal(s0, w0)))\n  df-nf(s0, w0)\n}","pretty":"thm nfi(setvar s0, wff w0) {\n  ⊢ F/(s0, w0)\n  ⊣ (∃(s0, w0)→ ∀(s0, w0))\n} = {\n  mpbir(F/(s0, w0), (∃(s0, w0)→ ∀(s0, w0)))\n  df-nf(s0, w0)\n}","parent":["mpbir","df-nf"],"children":["nfv"]},{"name":"nfri","content":"Consequence of the definition of not-free. (Contributed by Wolf Lammen, 16-Sep-2021.)","origin":"thm nfri(setvar s0, wff w0) {\n  |- wi(wex(s0, w0), wal(s0, w0))\n  -| wnf(s0, w0)\n} = {\n  mpbi(wi(wex(s0, w0), wal(s0, w0)), wnf(s0, w0))\n  df-nf(s0, w0)\n}","pretty":"thm nfri(setvar s0, wff w0) {\n  ⊢ (∃(s0, w0)→ ∀(s0, w0))\n  ⊣ F/(s0, w0)\n} = {\n  mpbi((∃(s0, w0)→ ∀(s0, w0)), F/(s0, w0))\n  df-nf(s0, w0)\n}","parent":["mpbi","df-nf"],"children":["nf5ri"]},{"name":"nfd","content":"Deduce that ` x ` is not free in ` ps ` in a context. (Contributed by Wolf Lammen, 16-Sep-2021.)","origin":"thm nfd(setvar s0, wff w0, wff w1) {\n  |- wi(w0, wnf(s0, w1))\n  -| wi(w0, wi(wex(s0, w1), wal(s0, w1)))\n} = {\n  sylibr(w0, wnf(s0, w1), wi(wex(s0, w1), wal(s0, w1)))\n  df-nf(s0, w1)\n}","pretty":"thm nfd(setvar s0, wff w0, wff w1) {\n  ⊢ (w0 → F/(s0, w1))\n  ⊣ (w0 →(∃(s0, w1)→ ∀(s0, w1)))\n} = {\n  sylibr(w0, F/(s0, w1), (∃(s0, w1)→ ∀(s0, w1)))\n  df-nf(s0, w1)\n}","parent":["sylibr","df-nf"],"children":["nftht","nfntht","nfimd","nf5-1","axc16nf","nfald","nfeqf2","nfeqf2OLD"]},{"name":"nfrd","content":"Consequence of the definition of not-free in a context. (Contributed by Wolf Lammen, 15-Oct-2021.)","origin":"thm nfrd(setvar s0, wff w0, wff w1) {\n  |- wi(w0, wi(wex(s0, w1), wal(s0, w1)))\n  -| wi(w0, wnf(s0, w1))\n} = {\n  sylib(w0, wi(wex(s0, w1), wal(s0, w1)), wnf(s0, w1))\n  df-nf(s0, w1)\n}","pretty":"thm nfrd(setvar s0, wff w0, wff w1) {\n  ⊢ (w0 →(∃(s0, w1)→ ∀(s0, w1)))\n  ⊣ (w0 → F/(s0, w1))\n} = {\n  sylib(w0, (∃(s0, w1)→ ∀(s0, w1)), F/(s0, w1))\n  df-nf(s0, w1)\n}","parent":["sylib","df-nf"],"children":["19.38a","19.38b","nfimd","19.9d","nfald","exists2","eusv2i","bj-exlalrim","bj-nfimt"]},{"name":"nftht","content":"Closed form of ~ nfth . (Contributed by Wolf Lammen, 19-Aug-2018.) (Proof shortened by BJ, 16-Sep-2021.) (Proof shortened by Wolf Lammen, 3-Sep-2022.)","origin":"thm nftht(setvar s0, wff w0) {\n  |- wi(wal(s0, w0), wnf(s0, w0))\n} = {\n  nfd(s0, wal(s0, w0), w0)\n  ax-1(wal(s0, w0), wex(s0, w0))\n}","pretty":"thm nftht(setvar s0, wff w0) {\n  ⊢ (∀(s0, w0)→ F/(s0, w0))\n} = {\n  nfd(s0, ∀(s0, w0), w0)\n  ax-1(∀(s0, w0), ∃(s0, w0))\n}","parent":["nfd","ax-1"],"children":["nfth","nfim1","wl-nax6nfr","wl-nfeqfb"]},{"name":"nfntht","content":"Closed form of ~ nfnth . (Contributed by BJ, 16-Sep-2021.) (Proof shortened by Wolf Lammen, 4-Sep-2022.)","origin":"thm nfntht(setvar s0, wff w0) {\n  |- wi(wn(wex(s0, w0)), wnf(s0, w0))\n} = {\n  nfd(s0, wn(wex(s0, w0)), w0)\n  pm2.21(wex(s0, w0), wal(s0, w0))\n}","pretty":"thm nfntht(setvar s0, wff w0) {\n  ⊢ (¬ ∃(s0, w0)→ F/(s0, w0))\n} = {\n  nfd(s0, ¬ ∃(s0, w0), w0)\n  pm2.21(∃(s0, w0), ∀(s0, w0))\n}","parent":["nfd","pm2.21"],"children":["nfntht2"]},{"name":"nfntht2","content":"Closed form of ~ nfnth . (Contributed by BJ, 16-Sep-2021.) (Proof shortened by Wolf Lammen, 4-Sep-2022.)","origin":"thm nfntht2(setvar s0, wff w0) {\n  |- wi(wal(s0, wn(w0)), wnf(s0, w0))\n} = {\n  sylbi(wal(s0, wn(w0)), wnf(s0, w0), wn(wex(s0, w0)))\n  alnex(s0, w0)\n  nfntht(s0, w0)\n}","pretty":"thm nfntht2(setvar s0, wff w0) {\n  ⊢ (∀(s0, ¬ w0)→ F/(s0, w0))\n} = {\n  sylbi(∀(s0, ¬ w0), F/(s0, w0), ¬ ∃(s0, w0))\n  alnex(s0, w0)\n  nfntht(s0, w0)\n}","parent":["sylbi","alnex","nfntht"],"children":["nfnth"]}]}