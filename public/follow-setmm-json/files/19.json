{"index":19,"title":"Equality predicate for use by df-tru","content":"Even though it isn't ordinarily part of propositional calculus, the equality predicate ` = ` is introduced here so that the soundness of definition ~ df-tru can be checked by the same algorithm as is used for predicate calculus. Its first real use is in theorem ~ weq in the predicate calculus section below. For those who want propositional calculus to be self-contained i.e. to use wff variables only, the alternate definition ~ dftru2 may be adopted and this subsection moved down to just above ~ weq below. However, the use of ~ dftru2 as a definition requires a more elaborate definition checking algorithm that we prefer to avoid.","blocks":[{"name":"diff.wal.s","content":"","origin":"axiom diff.wal.s(setvar sBase, setvar s0, wff w0) {\n  |- diffsw(sBase, wal(s0, w0))\n  -| diffss(sBase, s0)\n  -| diffsw(sBase, w0)\n}","pretty":"axiom diff.wal.s(setvar sBase, setvar s0, wff w0) {\n  ⊢ d(sBase, ∀(s0, w0))\n  ⊣ d(sBase, s0)\n  ⊣ d(sBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wal.c","content":"","origin":"axiom diff.wal.c(class cBase, setvar s0, wff w0) {\n  |- diffcw(cBase, wal(s0, w0))\n  -| diffsc(s0, cBase)\n  -| diffcw(cBase, w0)\n}","pretty":"axiom diff.wal.c(class cBase, setvar s0, wff w0) {\n  ⊢ d(cBase, ∀(s0, w0))\n  ⊣ d(s0, cBase)\n  ⊣ d(cBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wal.w","content":"","origin":"axiom diff.wal.w(wff wBase, setvar s0, wff w0) {\n  |- diffww(wBase, wal(s0, w0))\n  -| diffsw(s0, wBase)\n  -| diffww(wBase, w0)\n}","pretty":"axiom diff.wal.w(wff wBase, setvar s0, wff w0) {\n  ⊢ d(wBase, ∀(s0, w0))\n  ⊣ d(s0, wBase)\n  ⊣ d(wBase, w0)\n}","parent":[],"children":[]},{"name":"cv","content":"This syntax construction states that a variable ` x ` , which has been declared to be a setvar variable by $f statement vx, is also a class expression. This can be justified informally as follows. We know that the class builder ` { y | y e. x } ` is a class by ~ cab . Since (when ` y ` is distinct from ` x ` ) we have ` x = { y | y e. x } ` by ~ cvjust , we can argue that the syntax \" ` class x ` \" can be viewed as an abbreviation for \" ` class { y | y e. x } ` \". See the discussion under the definition of class in [Jech] p. 4 showing that \"Every set can be considered to be a class\". While it is tempting and perhaps occasionally useful to view ~ cv as a \"type conversion\" from a setvar variable to a class variable, keep in mind that ~ cv is intrinsically no different from any other class-building syntax such as ~ cab , ~ cun , or ~ c0 . For a general discussion of the theory of classes and the role of ~ cv , see ~ mmset.html#class . (The description above applies to set theory, not predicate calculus. The purpose of introducing ` class x ` here, and not in set theory where it belongs, is to allow us to express, i.e., \"prove\", the ~ weq of predicate calculus from the ~ wceq of set theory, so that we do not overload the ` = ` connective with two syntax definitions. This is done to prevent ambiguity that would complicate some Metamath parsers.)","origin":"prop class cv(setvar s0) { s0 }","pretty":"","parent":[],"children":[]},{"name":"diff.cv.s","content":"","origin":"axiom diff.cv.s(setvar sBase, setvar s0) {\n  |- diffsc(sBase, cv(s0))\n  -| diffss(sBase, s0)\n}","pretty":"axiom diff.cv.s(setvar sBase, setvar s0) {\n  ⊢ d(sBase, s0)\n  ⊣ d(sBase, s0)\n}","parent":[],"children":[]},{"name":"diff.cv.c","content":"","origin":"axiom diff.cv.c(class cBase, setvar s0) {\n  |- diffcc(cBase, cv(s0))\n  -| diffsc(s0, cBase)\n}","pretty":"axiom diff.cv.c(class cBase, setvar s0) {\n  ⊢ d(cBase, s0)\n  ⊣ d(s0, cBase)\n}","parent":[],"children":[]},{"name":"diff.cv.w","content":"","origin":"axiom diff.cv.w(wff wBase, setvar s0) {\n  |- diffcw(cv(s0), wBase)\n  -| diffsw(s0, wBase)\n}","pretty":"axiom diff.cv.w(wff wBase, setvar s0) {\n  ⊢ d(s0, wBase)\n  ⊣ d(s0, wBase)\n}","parent":[],"children":[]},{"name":"wceq","content":"Extend wff definition to include class equality. For a general discussion of the theory of classes, see ~ mmset.html#class . (The purpose of introducing ` wff A = B ` here, and not in set theory where it belongs, is to allow us to express, i.e., \"prove\", the ~ weq of predicate calculus in terms of the ~ wceq of set theory, so that we do not \"overload\" the ` = ` connective with two syntax definitions. This is done to prevent ambiguity that would complicate some Metamath parsers. For example, some parsers - although not the Metamath program - stumble on the fact that the ` = ` in ` x = y ` could be the ` = ` of either ~ weq or ~ wceq , although mathematically it makes no difference. The class variables ` A ` and ` B ` are introduced temporarily for the purpose of this definition but otherwise not used in predicate calculus. See ~ df-cleq for more information on the set theory usage of ~ wceq .)","origin":"prop wff wceq(class c0, class c1) { c0 = c1 }","pretty":"","parent":[],"children":[]}]}