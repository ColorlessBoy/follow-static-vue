{"index":50,"title":"Rule scheme ax-gen (Generalization)","content":"","blocks":[{"name":"ax-gen","content":"Rule of (universal) generalization. In our axiomatization, this is the only postulated (that is, axiomatic) rule of inference of predicate calculus (together with the rule of modus ponens ~ ax-mp of propositional calculus). See, e.g., Rule 2 of [Hamilton] p. 74. This rule says that if something is unconditionally true, then it is true for all values of a variable. For example, if we have proved ` x = x ` , then we can conclude ` A. x x = x ` or even ` A. y x = x ` . Theorem ~ altru shows the special case ` A. x T. ` . The converse rule of inference ~ spi (universal instantiation, or universal specialization) shows that we can also go the other way: in other words, we can add or remove universal quantifiers from the beginning of any theorem as required. Note that the closed form ` ( ph -> A. x ph ) ` need not hold (but may hold in special cases, see ~ ax-5 ). (Contributed by NM, 3-Jan-1993.)","origin":"axiom ax-gen(setvar s0, wff w0) {\n  |- wal(s0, w0)\n  -| w0\n}","pretty":"axiom ax-gen(setvar s0, wff w0) {\n  ⊢ ∀(s0, w0)\n  ⊣ w0\n}","parent":[],"children":["gen2","mpg","mpgbi","mpgbir","hbth","altru","alfal","stdpc6","sbt","ax13dgen3","cesareOLD","camestresOLD","calemesOLD","ceqsalg","ceqsralv","vtocl2","mosub","sbcth","sbciegf","csbiegf","sbcnestg","csbnestg","csbnest1g","mpteq2ia","mpteq2da","al0ssb","ssopab2i","relssi","xpidtr","funcnvsn","caovmo","ordom","wfrfun","tfrlem7","pssnn","findcard","findcard2","fiint","inf0","axinf2","trcl","axac3","brdom3","axpowndlem4","axregndlem2","axinfnd","wfgru","nqerf","uzrdgfni","ltweuz","trclfvcotr","fclim","letsr","distop","fctop","cctop","ulmdm","upgr0eopALT","disjin","disjin2","bnj1023","bnj1109","bnj907","hbimg","frrlem5c","fnsingle","funimage","funpartfun","hftr","filnetlem3","bj-genr","bj-genl","bj-genan","bj-cbvalim","bj-cbvexim","bj-ax12v","bj-ceqsalg0","bj-ceqsalgALT","bj-ceqsalgvALT","bj-nnfth","bj-vtoclgfALT","vtoclefex","rdgeqoa","riscer","disjALTV0","ax12eq","cdleme32fva","dfrcl2","pm11.11","sbc3orgVD","ordelordALTVD","trsbcVD","undif3VD","sbcssgVD","csbingVD","onfrALTlem1VD","onfrALTVD","csbsngVD","csbxpgVD","csbresgVD","csbrngVD","csbima12gALTVD","csbunigVD","csbfv12gALTVD","19.41rgVD","unisnALT","refsum2cnlem1","mptssid","dvnprodlem3","sge00","eusnsn","aiota0def","sprssspr","spcdvw","setrec2lem2","onsetrec"]},{"name":"gen2","content":"Generalization applied twice. (Contributed by NM, 30-Apr-1998.)","origin":"thm gen2(setvar s0, setvar s1, wff w0) {\n  |- wal(s0, wal(s1, w0))\n  -| w0\n} = {\n  ax-gen(s0, wal(s1, w0))\n  ax-gen(s1, w0)\n}","pretty":"thm gen2(setvar s0, setvar s1, wff w0) {\n  ⊢ ∀(s0, ∀(s1, w0))\n  ⊣ w0\n} = {\n  ax-gen(s0, ∀(s1, w0))\n  ax-gen(s1, w0)\n}","parent":["ax-gen"],"children":["axextmo","bm1.1OLD","vtocl3","moeq","eueqOLD","csbie2","mosneq","eusv1","moop2","mosubop","eqrelriv","opabid2","xpidtr","fvmptopab","funoprab","mpt2fun","fnoprab","elovmpt2","wfrfun","tfrlem7","hartogs","card2on","epinid0","cnvepnep","tskwe","ondomon","fi1uzind","brfi1indALT","climeu","letsr","ulmdm","wlkRes","ajmoi","helch","hsn0elch","chintcli","adjmo","nlelchi","hmopidmchi","bnj978","bnj1052","bnj1030","frrlem5c","fnsingle","funimage","funpartfun","imagesset","funtransport","funray","funline","filnetlem3","bj-cbvalimi","bj-cbveximi","ax11-pm","ax11-pm2","bj-dfclel","bj-dfcleq","bj-snsetex","wl-equsal1i","mbfresfi","riscer","vvdifopab","opabf","cnvcosseq","symrelcoss3","cotrintab","pm11.11","fun2dmnopgexmpl","ichid","ichcircshi","icheq"]},{"name":"mpg","content":"Modus ponens combined with generalization. (Contributed by NM, 24-May-1994.)","origin":"thm mpg(setvar s0, wff w0, wff w1) {\n  |- w0\n  -| wi(wal(s0, w1), w0)\n  -| w1\n} = {\n  ax-mp(w0, wal(s0, w1))\n  ax-gen(s0, w1)\n}","pretty":"thm mpg(setvar s0, wff w0, wff w1) {\n  ⊢ w0\n  ⊣ (∀(s0, w1)→ w0)\n  ⊣ w1\n} = {\n  ax-mp(w0, ∀(s0, w1))\n  ax-gen(s0, w1)\n}","parent":["ax-mp","ax-gen"],"children":["nfth","nfnth","alimi","al2imi","albii","eximi","exbii","nfbii","sbtALT","equsb1vOLD","nf5i","hbn","chvar","equsb1","equsb2","nfsb4","sbtr","equsb1ALT","nfsb4ALT","moimiOLD","mobii","eubii","2eumo","vtoclf","vtocl","vtocl2","vtocl3","spcimgf","spcgf","euxfr2","axsep","axnulALT","csbex","dtrucor","eusv2nf","axprlem3","ssopab2i","iotabii","opabiotafun","eufnfv","snnex","pwnex","tz9.13","unir1","axac2","axpowndlem3","uzrdgfni","uvtx01vtx","setinds","hbng","bj-axd2d","bj-exalimsi","bj-hbsb3","bj-nfs1","bj-chvarv","bj-chvarvv","bj-axsep","bj-dtrucor","bj-vexw","bj-issetw","bj-abf","bj-vtoclf","bj-snsetex","ax4fromc4","ax10fromc7","ax6fromc10","equid1","setindtrs","frege97","frege109","pm11.11","sbeqal1i","axc5c4c711toc7","axc5c4c711to11","iotaequ","setrec2lem2","vsetrec"]},{"name":"mpgbi","content":"Modus ponens on biconditional combined with generalization. (Contributed by NM, 24-May-1994.) (Proof shortened by Stefan Allan, 28-Oct-2008.)","origin":"thm mpgbi(setvar s0, wff w0, wff w1) {\n  |- w0\n  -| wb(wal(s0, w1), w0)\n  -| w1\n} = {\n  mpbi(w0, wal(s0, w1))\n  ax-gen(s0, w1)\n}","pretty":"thm mpgbi(setvar s0, wff w0, wff w1) {\n  ⊢ w0\n  ⊣ (∀(s0, w1)↔ w0)\n  ⊣ w1\n} = {\n  mpbi(w0, ∀(s0, w1))\n  ax-gen(s0, w1)\n}","parent":["mpbi","ax-gen"],"children":["nex","exlimi","axi12","axi12OLD","axbnd","abbiiOLDOLD","nalset","bnj1304","bnj1052","bnj1030","bj-nuliota","spr0nelg"]},{"name":"mpgbir","content":"Modus ponens on biconditional combined with generalization. (Contributed by NM, 24-May-1994.) (Proof shortened by Stefan Allan, 28-Oct-2008.)","origin":"thm mpgbir(setvar s0, wff w0, wff w1) {\n  |- w0\n  -| wb(w0, wal(s0, w1))\n  -| w1\n} = {\n  mpbir(w0, wal(s0, w1))\n  ax-gen(s0, w1)\n}","pretty":"thm mpgbir(setvar s0, wff w0, wff w1) {\n  ⊢ w0\n  ⊣ (w0 ↔ ∀(s0, w1))\n  ⊣ w1\n} = {\n  mpbir(w0, ∀(s0, w1))\n  ax-gen(s0, w1)\n}","parent":["mpbir","ax-gen"],"children":["cvjust","eqriv","abbi2iOLD","nfci","abid2f","rgen","rabeqc","ssriv","ss2abi","nel0","rab0","abf","ssmin","intab","iunab","iinab","sndisj","disjxsn","intid","fr0","relssi","dmi","onfr","funopabeq","isarep2","opabiotafun","fvopab3ig","opabex","caovmo","ordom","tz7.44lem1","dfsup2","zfregfr","dfom3","trcl","tc2","rankf","rankval4","uniwun","dfnn2","dfuzi","fzodisj","fzodisjsn","cycsubg","efger","ajfuni","funadj","rabexgfGS","abrexdomjm","ballotth","bnj1133","dfon3","fnsingle","dfiota3","hftr","bj-abbi2i","bj-rabtrALT","bj-df-v","wl-rgen","wl-rgenw","wl-ralel","ismblfin","abrexdom","cllem0","cotrintab","brtrclfv2","snhesn","psshepw","k0004val0","compab","onfrALT","dvcosre","alimp-surprise"]},{"name":"nex","content":"Generalization rule for negated wff. (Contributed by NM, 18-May-1994.)","origin":"thm nex(setvar s0, wff w0) {\n  |- wn(wex(s0, w0))\n  -| wn(w0)\n} = {\n  mpgbi(s0, wn(wex(s0, w0)), wn(w0))\n  alnex(s0, w0)\n}","pretty":"thm nex(setvar s0, wff w0) {\n  ⊢ ¬ ∃(s0, w0)\n  ⊣ ¬ w0\n} = {\n  mpgbi(s0, ¬ ∃(s0, w0), ¬ w0)\n  alnex(s0, w0)\n}","parent":["mpgbi","alnex"],"children":["ru","noel","axnulALT","notzfaus","dtrucor2","opelopabsb","0nelxp","0xp","dm0","cnv0","co02","dffv3","mpt20","canth2","brdom3","ruc","meet0","join0","0g0","ustn0","bnj1523","linedegen","nexntru","nexfal","unqsym1","amosym1","subsym1","bj-dtrucor2v","bj-ru1","bj-0nelsngl","bj-ccinftydisj","disjALTV0","nsb"]},{"name":"nfth","content":"No variable is (effectively) free in a theorem. (Contributed by Mario Carneiro, 11-Aug-2016.) ~ df-nf changed. (Revised by Wolf Lammen, 12-Sep-2021.)","origin":"thm nfth(setvar s0, wff w0) {\n  |- wnf(s0, w0)\n  -| w0\n} = {\n  mpg(s0, wnf(s0, w0), w0)\n  nftht(s0, w0)\n}","pretty":"thm nfth(setvar s0, wff w0) {\n  ⊢ F/(s0, w0)\n  ⊣ w0\n} = {\n  mpg(s0, F/(s0, w0), w0)\n  nftht(s0, w0)\n}","parent":["mpg","nftht"],"children":["nftru","nfequid","sbc2ie","iunxdif3","infcvgaux1i","exnel","elrnmpt1sf","ellimcabssub0"]},{"name":"nfnth","content":"No variable is (effectively) free in a non-theorem. (Contributed by Mario Carneiro, 6-Dec-2016.) ~ df-nf changed. (Revised by Wolf Lammen, 12-Sep-2021.)","origin":"thm nfnth(setvar s0, wff w0) {\n  |- wnf(s0, w0)\n  -| wn(w0)\n} = {\n  mpg(s0, wnf(s0, w0), wn(w0))\n  nfntht2(s0, w0)\n}","pretty":"thm nfnth(setvar s0, wff w0) {\n  ⊢ F/(s0, w0)\n  ⊣ ¬ w0\n} = {\n  mpg(s0, F/(s0, w0), ¬ w0)\n  nfntht2(s0, w0)\n}","parent":["mpg","nfntht2"],"children":["nffal","nd1","nd2"]},{"name":"hbth","content":"No variable is (effectively) free in a theorem. This and later \"hypothesis-building\" lemmas, with labels starting \"hb...\", allow us to construct proofs of formulas of the form ` |- ( ph -> A. x ph ) ` from smaller formulas of this form. These are useful for constructing hypotheses that state \" ` x ` is (effectively) not free in ` ph ` \". (Contributed by NM, 11-May-1993.) This hb* idiom is generally being replaced by the nf* idiom (see ~ nfth ), but keeps its interest in some cases. (Revised by BJ, 23-Sep-2022.)","origin":"thm hbth(setvar s0, wff w0) {\n  |- wi(w0, wal(s0, w0))\n  -| w0\n} = {\n  a1i(w0, wal(s0, w0))\n  ax-gen(s0, w0)\n}","pretty":"thm hbth(setvar s0, wff w0) {\n  ⊢ (w0 → ∀(s0, w0))\n  ⊣ w0\n} = {\n  a1i(w0, ∀(s0, w0))\n  ax-gen(s0, w0)\n}","parent":["a1i","ax-gen"],"children":["spfalw"]},{"name":"nftru","content":"The true constant has no free variables. (This can also be proven in one step with ~ nfv , but this proof does not use ~ ax-5 .) (Contributed by Mario Carneiro, 6-Oct-2016.)","origin":"thm nftru(setvar s0) {\n  |- wnf(s0, wtru)\n} = {\n  nfth(s0, wtru)\n  tru()\n}","pretty":"thm nftru(setvar s0) {\n  ⊢ F/(s0, T)\n} = {\n  nfth(s0, wtru)\n  tru()\n}","parent":["nfth","tru"],"children":["nfmo","nfeu","2mo","nfceqiOLD","dvelimc","nfral","nfrex","nfreu","nfrmo","nfrab","rabtru","nfsbc","nfcsb","nfdisj","reusv1","reusv2lem1","nfiota","nfriota","nfixp","eqri","esumnul","hasheuni","wl-cbvalnae","wl-equsal","limsup10ex","liminf10ex","liminfvalxr","liminf0","stowei","ioosshoi","vonioolem2"]},{"name":"nffal","content":"The false constant has no free variables (see ~ nftru ). (Contributed by BJ, 6-May-2019.)","origin":"thm nffal(setvar s0) {\n  |- wnf(s0, wfal)\n} = {\n  nfnth(s0, wfal)\n  fal()\n}","pretty":"thm nffal(setvar s0) {\n  ⊢ F/(s0, F)\n} = {\n  nfnth(s0, wfal)\n  fal()\n}","parent":["nfnth","fal"],"children":[]},{"name":"sptruw","content":"Version of ~ sp when ` ph ` is true. Instance of ~ a1i . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 23-Apr-2017.)","origin":"thm sptruw(setvar s0, wff w0) {\n  |- wi(wal(s0, w0), w0)\n  -| w0\n} = {\n  a1i(wal(s0, w0), w0)\n}","pretty":"thm sptruw(setvar s0, wff w0) {\n  ⊢ (∀(s0, w0)→ w0)\n  ⊣ w0\n} = {\n  a1i(∀(s0, w0), w0)\n}","parent":["a1i"],"children":[]},{"name":"altru","content":"For all sets, ` T. ` is true. (Contributed by Anthony Hart, 13-Sep-2011.)","origin":"thm altru(setvar s0) {\n  |- wal(s0, wtru)\n} = {\n  ax-gen(s0, wtru)\n  tru()\n}","pretty":"thm altru(setvar s0) {\n  ⊢ ∀(s0, T)\n} = {\n  ax-gen(s0, wtru)\n  tru()\n}","parent":["ax-gen","tru"],"children":[]},{"name":"alfal","content":"For all sets, ` -. F. ` is true. (Contributed by Anthony Hart, 13-Sep-2011.)","origin":"thm alfal(setvar s0) {\n  |- wal(s0, wn(wfal))\n} = {\n  ax-gen(s0, wn(wfal))\n  fal()\n}","pretty":"thm alfal(setvar s0) {\n  ⊢ ∀(s0, ¬ F)\n} = {\n  ax-gen(s0, ¬ F)\n  fal()\n}","parent":["ax-gen","fal"],"children":["nalfal"]}]}