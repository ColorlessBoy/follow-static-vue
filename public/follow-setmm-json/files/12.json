{"index":12,"title":"The conditional operator for propositions","content":"This subsection introduces the conditional operator for propositions, denoted by ` if- ( ph , ps , ch ) ` (see ~ df-ifp ). It is the analogue for propositions of the conditional operator for classes, denoted by ` if ( ph , A , B ) ` (see ~ df-if ).","blocks":[{"name":"wif","content":"Extend class notation to include the conditional operator for propositions.","origin":"prop wff wif(wff w0, wff w1, wff w2) { if(w0, w1, w2) }","pretty":"","parent":[],"children":[]},{"name":"diff.wif.s","content":"","origin":"axiom diff.wif.s(setvar sBase, wff w0, wff w1, wff w2) {\n  |- diffsw(sBase, wif(w0, w1, w2))\n  -| diffsw(sBase, w0)\n  -| diffsw(sBase, w1)\n  -| diffsw(sBase, w2)\n}","pretty":"axiom diff.wif.s(setvar sBase, wff w0, wff w1, wff w2) {\n  ⊢ d(sBase, if(w0, w1, w2))\n  ⊣ d(sBase, w0)\n  ⊣ d(sBase, w1)\n  ⊣ d(sBase, w2)\n}","parent":[],"children":[]},{"name":"diff.wif.c","content":"","origin":"axiom diff.wif.c(class cBase, wff w0, wff w1, wff w2) {\n  |- diffcw(cBase, wif(w0, w1, w2))\n  -| diffcw(cBase, w0)\n  -| diffcw(cBase, w1)\n  -| diffcw(cBase, w2)\n}","pretty":"axiom diff.wif.c(class cBase, wff w0, wff w1, wff w2) {\n  ⊢ d(cBase, if(w0, w1, w2))\n  ⊣ d(cBase, w0)\n  ⊣ d(cBase, w1)\n  ⊣ d(cBase, w2)\n}","parent":[],"children":[]},{"name":"diff.wif.w","content":"","origin":"axiom diff.wif.w(wff wBase, wff w0, wff w1, wff w2) {\n  |- diffww(wBase, wif(w0, w1, w2))\n  -| diffww(wBase, w0)\n  -| diffww(wBase, w1)\n  -| diffww(wBase, w2)\n}","pretty":"axiom diff.wif.w(wff wBase, wff w0, wff w1, wff w2) {\n  ⊢ d(wBase, if(w0, w1, w2))\n  ⊣ d(wBase, w0)\n  ⊣ d(wBase, w1)\n  ⊣ d(wBase, w2)\n}","parent":[],"children":[]},{"name":"df-ifp","content":"Definition of the conditional operator for propositions. The expression ` if- ( ph , ps , ch ) ` is read \"if ` ph ` then ` ps ` else ` ch ` \". See ~ dfifp2 , ~ dfifp3 , ~ dfifp4 , ~ dfifp5 , ~ dfifp6 and ~ dfifp7 for alternate definitions. This definition (in the form of ~ dfifp2 ) appears in Section II.24 of [Church] p. 129 (Definition D12 page 132), where it is called \"conditioned disjunction\". Church's ` [ ps , ph , ch ] ` corresponds to our ` if- ( ph , ps , ch ) ` (note the permutation of the first two variables). This form was chosen as the definition rather than ~ dfifp2 for compatibility with intuitionistic logic development: with this form, it is clear that ` if- ( ph , ps , ch ) ` implies decidability of ` ph ` , which is most often what is wanted. Church uses the conditional operator as an intermediate step to prove completeness of some systems of connectives. The first result is that the system ` { if- , T. , F. } ` is complete: for the induction step, consider a formula of n+1 variables; single out one variable, say ` ph ` ; when one sets ` ph ` to True (resp. False), then what remains is a formula of n variables, so by the induction hypothesis it is equivalent to a formula using only the connectives ` if- , T. , F. ` , say ` ps ` (resp. ` ch ` ); therefore, the formula ` if- ( ph , ps , ch ) ` is equivalent to the initial formula of n+1 variables. Now, since ` { -> , -. } ` and similar systems suffice to express the connectives ` if- , T. , F. ` , they are also complete. (Contributed by BJ, 22-Jun-2019.)","origin":"axiom df-ifp(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wo(wa(w0, w1), wa(wn(w0), w2)))\n}","pretty":"axiom df-ifp(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔((w0 ∧ w1)∨(¬ w0 ∧ w2)))\n}","parent":[],"children":["dfifp2","dfifp6","ifpor","casesifp","ifpbi123d","1fpid3","wlk1walk","upgriswlk","bj-df-ifc","ifpdfan","ifpnot23","upgrwlkupwlk"]},{"name":"dfifp2","content":"Alternate definition of the conditional operator for propositions. The value of ` if- ( ph , ps , ch ) ` is \"if ` ph ` then ` ps ` , and if not ` ph ` then ` ch ` \". This version of the definition uses only primitive symbols ( ` -> , -. , A. ` ). This is the definition used in Section II.24 of [Church] p. 129 (Definition D12 page 132) (see comment of ~ df-ifp ). (Contributed by BJ, 22-Jun-2019.)","origin":"thm dfifp2(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wa(wi(w0, w1), wi(wn(w0), w2)))\n} = {\n  bitri(wif(w0, w1, w2), wa(wi(w0, w1), wi(wn(w0), w2)), wo(wa(w0, w1), wa(wn(w0), w2)))\n  df-ifp(w0, w1, w2)\n  cases2(w0, w1, w2)\n}","pretty":"thm dfifp2(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔((w0 → w1)∧(¬ w0 → w2)))\n} = {\n  bitri(if(w0, w1, w2), ((w0 → w1)∧(¬ w0 → w2)), ((w0 ∧ w1)∨(¬ w0 ∧ w2)))\n  df-ifp(w0, w1, w2)\n  cases2(w0, w1, w2)\n}","parent":["bitri","df-ifp","cases2"],"children":["dfifp3","dfifp5","ifpn","ifpimpda","ifpbi2","ifpbi3","ifpbi23","ifpbi1","ifpbi12","ifpbi13","ifpbi123","ifpimimb","ifpororb","ifpbibib","frege54cor0a"]},{"name":"dfifp3","content":"Alternate definition of the conditional operator for propositions. (Contributed by BJ, 30-Sep-2019.)","origin":"thm dfifp3(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wa(wi(w0, w1), wo(w0, w2)))\n} = {\n  bitri(wif(w0, w1, w2), wa(wi(w0, w1), wo(w0, w2)), wa(wi(w0, w1), wi(wn(w0), w2)))\n  dfifp2(w0, w1, w2)\n  anbi2i(wi(w0, w1), wi(wn(w0), w2), wo(w0, w2))\n  pm4.64(w0, w2)\n}","pretty":"thm dfifp3(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔((w0 → w1)∧(w0 ∨ w2)))\n} = {\n  bitri(if(w0, w1, w2), ((w0 → w1)∧(w0 ∨ w2)), ((w0 → w1)∧(¬ w0 → w2)))\n  dfifp2(w0, w1, w2)\n  anbi2i((w0 → w1), (¬ w0 → w2), (w0 ∨ w2))\n  pm4.64(w0, w2)\n}","parent":["bitri","dfifp2","anbi2i","pm4.64"],"children":["dfifp4","ifptru"]},{"name":"dfifp4","content":"Alternate definition of the conditional operator for propositions. (Contributed by BJ, 30-Sep-2019.)","origin":"thm dfifp4(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wa(wo(wn(w0), w1), wo(w0, w2)))\n} = {\n  bitri(wif(w0, w1, w2), wa(wo(wn(w0), w1), wo(w0, w2)), wa(wi(w0, w1), wo(w0, w2)))\n  dfifp3(w0, w1, w2)\n  anbi1i(wi(w0, w1), wo(w0, w2), wo(wn(w0), w1))\n  imor(w0, w1)\n}","pretty":"thm dfifp4(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔((¬ w0 ∨ w1)∧(w0 ∨ w2)))\n} = {\n  bitri(if(w0, w1, w2), ((¬ w0 ∨ w1)∧(w0 ∨ w2)), ((w0 → w1)∧(w0 ∨ w2)))\n  dfifp3(w0, w1, w2)\n  anbi1i((w0 → w1), (w0 ∨ w2), (¬ w0 ∨ w1))\n  imor(w0, w1)\n}","parent":["bitri","dfifp3","anbi1i","imor"],"children":["anifp","ifpan123g","ifpan23","ifpdfor2","ifpdfor","ifpim1","ifpnot","ifpid2","ifpim2","ifpnot23","ifpidg","ifpim123g","ifpimim"]},{"name":"dfifp5","content":"Alternate definition of the conditional operator for propositions. (Contributed by BJ, 2-Oct-2019.)","origin":"thm dfifp5(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wa(wo(wn(w0), w1), wi(wn(w0), w2)))\n} = {\n  bitri(wif(w0, w1, w2), wa(wo(wn(w0), w1), wi(wn(w0), w2)), wa(wi(w0, w1), wi(wn(w0), w2)))\n  dfifp2(w0, w1, w2)\n  anbi1i(wi(w0, w1), wi(wn(w0), w2), wo(wn(w0), w1))\n  imor(w0, w1)\n}","pretty":"thm dfifp5(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔((¬ w0 ∨ w1)∧(¬ w0 → w2)))\n} = {\n  bitri(if(w0, w1, w2), ((¬ w0 ∨ w1)∧(¬ w0 → w2)), ((w0 → w1)∧(¬ w0 → w2)))\n  dfifp2(w0, w1, w2)\n  anbi1i((w0 → w1), (¬ w0 → w2), (¬ w0 ∨ w1))\n  imor(w0, w1)\n}","parent":["bitri","dfifp2","anbi1i","imor"],"children":[]},{"name":"dfifp6","content":"Alternate definition of the conditional operator for propositions. (Contributed by BJ, 2-Oct-2019.)","origin":"thm dfifp6(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wo(wa(w0, w1), wn(wi(w2, w0))))\n} = {\n  bitri(wif(w0, w1, w2), wo(wa(w0, w1), wn(wi(w2, w0))), wo(wa(w0, w1), wa(wn(w0), w2)))\n  df-ifp(w0, w1, w2)\n  orbi2i(wa(w0, w1), wa(wn(w0), w2), wn(wi(w2, w0)))\n  bitri(wa(wn(w0), w2), wn(wi(w2, w0)), wa(w2, wn(w0)))\n  ancom(wn(w0), w2)\n  annim(w2, w0)\n}","pretty":"thm dfifp6(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔((w0 ∧ w1)∨ ¬(w2 → w0)))\n} = {\n  bitri(if(w0, w1, w2), ((w0 ∧ w1)∨ ¬(w2 → w0)), ((w0 ∧ w1)∨(¬ w0 ∧ w2)))\n  df-ifp(w0, w1, w2)\n  orbi2i((w0 ∧ w1), (¬ w0 ∧ w2), ¬(w2 → w0))\n  bitri((¬ w0 ∧ w2), ¬(w2 → w0), (w2 ∧ ¬ w0))\n  ancom(¬ w0, w2)\n  annim(w2, w0)\n}","parent":["bitri","df-ifp","orbi2i","ancom","annim"],"children":["dfifp7","ifpdfan2"]},{"name":"dfifp7","content":"Alternate definition of the conditional operator for propositions. (Contributed by BJ, 2-Oct-2019.)","origin":"thm dfifp7(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wi(wi(w2, w0), wa(w0, w1)))\n} = {\n  3bitr4i(wif(w0, w1, w2), wi(wi(w2, w0), wa(w0, w1)), wo(wa(w0, w1), wn(wi(w2, w0))), wo(wn(wi(w2, w0)), wa(w0, w1)))\n  orcom(wa(w0, w1), wn(wi(w2, w0)))\n  dfifp6(w0, w1, w2)\n  imor(wi(w2, w0), wa(w0, w1))\n}","pretty":"thm dfifp7(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔((w2 → w0)→(w0 ∧ w1)))\n} = {\n  3bitr4i(if(w0, w1, w2), ((w2 → w0)→(w0 ∧ w1)), ((w0 ∧ w1)∨ ¬(w2 → w0)), (¬(w2 → w0)∨(w0 ∧ w1)))\n  orcom((w0 ∧ w1), ¬(w2 → w0))\n  dfifp6(w0, w1, w2)\n  imor((w2 → w0), (w0 ∧ w1))\n}","parent":["3bitr4i","orcom","dfifp6","imor"],"children":[]},{"name":"anifp","content":"The conditional operator is implied by the conjunction of its possible outputs. Dual statement of ~ ifpor . (Contributed by BJ, 30-Sep-2019.)","origin":"thm anifp(wff w0, wff w1, wff w2) {\n  |- wi(wa(w0, w1), wif(w2, w0, w1))\n} = {\n  sylibr(wa(w0, w1), wif(w2, w0, w1), wa(wo(wn(w2), w0), wo(w2, w1)))\n  anim12i(w0, w1, wo(wn(w2), w0), wo(w2, w1))\n  olc(w0, wn(w2))\n  olc(w1, w2)\n  dfifp4(w2, w0, w1)\n}","pretty":"thm anifp(wff w0, wff w1, wff w2) {\n  ⊢ ((w0 ∧ w1)→ if(w2, w0, w1))\n} = {\n  sylibr((w0 ∧ w1), if(w2, w0, w1), ((¬ w2 ∨ w0)∧(w2 ∨ w1)))\n  anim12i(w0, w1, (¬ w2 ∨ w0), (w2 ∨ w1))\n  olc(w0, ¬ w2)\n  olc(w1, w2)\n  dfifp4(w2, w0, w1)\n}","parent":["sylibr","anim12i","olc","dfifp4"],"children":["bj-consensus","bj-consensusALT","axfrege58a"]},{"name":"ifpor","content":"The conditional operator implies the disjunction of its possible outputs. Dual statement of ~ anifp . (Contributed by BJ, 1-Oct-2019.)","origin":"thm ifpor(wff w0, wff w1, wff w2) {\n  |- wi(wif(w0, w1, w2), wo(w1, w2))\n} = {\n  sylbi(wif(w0, w1, w2), wo(w1, w2), wo(wa(w0, w1), wa(wn(w0), w2)))\n  df-ifp(w0, w1, w2)\n  orim12i(wa(w0, w1), wa(wn(w0), w2), w1, w2)\n  simpr(w0, w1)\n  simpr(wn(w0), w2)\n}","pretty":"thm ifpor(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)→(w1 ∨ w2))\n} = {\n  sylbi(if(w0, w1, w2), (w1 ∨ w2), ((w0 ∧ w1)∨(¬ w0 ∧ w2)))\n  df-ifp(w0, w1, w2)\n  orim12i((w0 ∧ w1), (¬ w0 ∧ w2), w1, w2)\n  simpr(w0, w1)\n  simpr(¬ w0, w2)\n}","parent":["sylbi","df-ifp","orim12i","simpr"],"children":["axpr"]},{"name":"ifpn","content":"Conditional operator for the negation of a proposition. (Contributed by BJ, 30-Sep-2019.)","origin":"thm ifpn(wff w0, wff w1, wff w2) {\n  |- wb(wif(w0, w1, w2), wif(wn(w0), w2, w1))\n} = {\n  3bitr4i(wif(w0, w1, w2), wif(wn(w0), w2, w1), wa(wi(w0, w1), wi(wn(w0), w2)), wa(wi(wn(w0), w2), wi(wn(wn(w0)), w1)))\n  anbi2ci(wi(w0, w1), wi(wn(w0), w2), wi(wn(wn(w0)), w1))\n  imbi1i(w0, w1, wn(wn(w0)))\n  notnotb(w0)\n  dfifp2(w0, w1, w2)\n  dfifp2(wn(w0), w2, w1)\n}","pretty":"thm ifpn(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)↔ if(¬ w0, w2, w1))\n} = {\n  3bitr4i(if(w0, w1, w2), if(¬ w0, w2, w1), ((w0 → w1)∧(¬ w0 → w2)), ((¬ w0 → w2)∧(¬ ¬ w0 → w1)))\n  anbi2ci((w0 → w1), (¬ w0 → w2), (¬ ¬ w0 → w1))\n  imbi1i(w0, w1, ¬ ¬ w0)\n  notnotb(w0)\n  dfifp2(w0, w1, w2)\n  dfifp2(¬ w0, w2, w1)\n}","parent":["3bitr4i","anbi2ci","imbi1i","notnotb","dfifp2"],"children":["ifpfal","ifpdfbi","ifpxorcor"]},{"name":"ifptru","content":"Value of the conditional operator for propositions when its first argument is true. Analogue for propositions of ~ iftrue . This is essentially ~ dedlema . (Contributed by BJ, 20-Sep-2019.) (Proof shortened by Wolf Lammen, 10-Jul-2020.)","origin":"thm ifptru(wff w0, wff w1, wff w2) {\n  |- wi(w0, wb(wif(w0, w1, w2), w1))\n} = {\n  bitr2d(w0, wif(w0, w1, w2), w1, wi(w0, w1))\n  biimt(w0, w1)\n  syl6bbr(w0, wi(w0, w1), wif(w0, w1, w2), wa(wi(w0, w1), wo(w0, w2)))\n  biantrud(w0, wi(w0, w1), wo(w0, w2))\n  orc(w0, w2)\n  dfifp3(w0, w1, w2)\n}","pretty":"thm ifptru(wff w0, wff w1, wff w2) {\n  ⊢ (w0 →(if(w0, w1, w2)↔ w1))\n} = {\n  bitr2d(w0, if(w0, w1, w2), w1, (w0 → w1))\n  biimt(w0, w1)\n  syl6bbr(w0, (w0 → w1), if(w0, w1, w2), ((w0 → w1)∧(w0 ∨ w2)))\n  biantrud(w0, (w0 → w1), (w0 ∨ w2))\n  orc(w0, w2)\n  dfifp3(w0, w1, w2)\n}","parent":["bitr2d","biimt","syl6bbr","biantrud","orc","dfifp3"],"children":["ifpfal","ifpid","elimh","elimhOLD","dedt","dedtOLD","axprlem3","axprlem4","wlkl1loop","lfgrwlkprop","eupth2lem3lem3"]},{"name":"ifpfal","content":"Value of the conditional operator for propositions when its first argument is false. Analogue for propositions of ~ iffalse . This is essentially ~ dedlemb . (Contributed by BJ, 20-Sep-2019.) (Proof shortened by Wolf Lammen, 25-Jun-2020.)","origin":"thm ifpfal(wff w0, wff w1, wff w2) {\n  |- wi(wn(w0), wb(wif(w0, w1, w2), w2))\n} = {\n  syl5bb(wn(w0), wif(w0, w1, w2), w2, wif(wn(w0), w2, w1))\n  ifpn(w0, w1, w2)\n  ifptru(wn(w0), w2, w1)\n}","pretty":"thm ifpfal(wff w0, wff w1, wff w2) {\n  ⊢ (¬ w0 →(if(w0, w1, w2)↔ w2))\n} = {\n  syl5bb(¬ w0, if(w0, w1, w2), w2, if(¬ w0, w2, w1))\n  ifpn(w0, w1, w2)\n  ifptru(¬ w0, w2, w1)\n}","parent":["syl5bb","ifpn","ifptru"],"children":["ifpid","elimh","elimhOLD","axprlem3","axprlem5","wlkdlem4","lfgriswlk","2pthnloop","eupth2lem3lem4"]},{"name":"ifpid","content":"Value of the conditional operator for propositions when the same proposition is returned in either case. Analogue for propositions of ~ ifid . This is essentially ~ pm4.42 . (Contributed by BJ, 20-Sep-2019.)","origin":"thm ifpid(wff w0, wff w1) {\n  |- wb(wif(w0, w1, w1), w1)\n} = {\n  pm2.61i(wb(wif(w0, w1, w1), w1), w0)\n  ifptru(w0, w1, w1)\n  ifpfal(w0, w1, w1)\n}","pretty":"thm ifpid(wff w0, wff w1) {\n  ⊢ (if(w0, w1, w1)↔ w1)\n} = {\n  pm2.61i((if(w0, w1, w1)↔ w1), w0)\n  ifptru(w0, w1, w1)\n  ifpfal(w0, w1, w1)\n}","parent":["pm2.61i","ifptru","ifpfal"],"children":[]},{"name":"casesifp","content":"Version of ~ cases expressed using ` if- ` . Case disjunction according to the value of ` ph ` . One can see this as a proof that the two hypotheses characterize the conditional operator for propositions. For the converses, see ~ ifptru and ~ ifpfal . (Contributed by BJ, 20-Sep-2019.)","origin":"thm casesifp(wff w0, wff w1, wff w2, wff w3) {\n  |- wb(w0, wif(w1, w2, w3))\n  -| wi(w1, wb(w0, w2))\n  -| wi(wn(w1), wb(w0, w3))\n} = {\n  bitr4i(w0, wif(w1, w2, w3), wo(wa(w1, w2), wa(wn(w1), w3)))\n  cases(w0, w1, w2, w3)\n  df-ifp(w1, w2, w3)\n}","pretty":"thm casesifp(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ (w0 ↔ if(w1, w2, w3))\n  ⊣ (w1 →(w0 ↔ w2))\n  ⊣ (¬ w1 →(w0 ↔ w3))\n} = {\n  bitr4i(w0, if(w1, w2, w3), ((w1 ∧ w2)∨(¬ w1 ∧ w3)))\n  cases(w0, w1, w2, w3)\n  df-ifp(w1, w2, w3)\n}","parent":["bitr4i","cases","df-ifp"],"children":["hadifp","cadifp"]},{"name":"ifpbi123d","content":"Equality deduction for conditional operator for propositions. (Contributed by AV, 30-Dec-2020.)","origin":"thm ifpbi123d(wff w0, wff w1, wff w2, wff w3, wff w4, wff w5, wff w6) {\n  |- wi(w0, wb(wif(w1, w2, w3), wif(w4, w5, w6)))\n  -| wi(w0, wb(w1, w4))\n  -| wi(w0, wb(w2, w5))\n  -| wi(w0, wb(w3, w6))\n} = {\n  3bitr4g(w0, wif(w1, w2, w3), wif(w4, w5, w6), wo(wa(w1, w2), wa(wn(w1), w3)), wo(wa(w4, w5), wa(wn(w4), w6)))\n  orbi12d(w0, wa(w1, w2), wa(wn(w1), w3), wa(w4, w5), wa(wn(w4), w6))\n  anbi12d(w0, w1, w2, w4, w5)\n  anbi12d(w0, wn(w1), w3, wn(w4), w6)\n  notbid(w0, w1, w4)\n  df-ifp(w1, w2, w3)\n  df-ifp(w4, w5, w6)\n}","pretty":"thm ifpbi123d(wff w0, wff w1, wff w2, wff w3, wff w4, wff w5, wff w6) {\n  ⊢ (w0 →(if(w1, w2, w3)↔ if(w4, w5, w6)))\n  ⊣ (w0 →(w1 ↔ w4))\n  ⊣ (w0 →(w2 ↔ w5))\n  ⊣ (w0 →(w3 ↔ w6))\n} = {\n  3bitr4g(w0, if(w1, w2, w3), if(w4, w5, w6), ((w1 ∧ w2)∨(¬ w1 ∧ w3)), ((w4 ∧ w5)∨(¬ w4 ∧ w6)))\n  orbi12d(w0, (w1 ∧ w2), (¬ w1 ∧ w3), (w4 ∧ w5), (¬ w4 ∧ w6))\n  anbi12d(w0, w1, w2, w4, w5)\n  anbi12d(w0, ¬ w1, w3, ¬ w4, w6)\n  notbid(w0, w1, w4)\n  df-ifp(w1, w2, w3)\n  df-ifp(w4, w5, w6)\n}","parent":["3bitr4g","orbi12d","anbi12d","notbid","df-ifp"],"children":["wkslem1","wkslem2","wksfval","iswlk","wlkres","wlkresOLD","redwlk","wlkp1lem8","crctcshwlkn0lem4","crctcshwlkn0lem5","crctcshwlkn0lem6","1wlkdlem4"]},{"name":"ifpimpda","content":"Separation of the values of the conditional operator for propositions. (Contributed by AV, 30-Dec-2020.) (Proof shortened by Wolf Lammen, 27-Feb-2021.)","origin":"thm ifpimpda(wff w0, wff w1, wff w2, wff w3) {\n  |- wi(w0, wif(w1, w2, w3))\n  -| wi(wa(w0, w1), w2)\n  -| wi(wa(w0, wn(w1)), w3)\n} = {\n  sylanbrc(w0, wif(w1, w2, w3), wi(w1, w2), wi(wn(w1), w3))\n  ex(w0, w1, w2)\n  ex(w0, wn(w1), w3)\n  dfifp2(w1, w2, w3)\n}","pretty":"thm ifpimpda(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ (w0 → if(w1, w2, w3))\n  ⊣ ((w0 ∧ w1)→ w2)\n  ⊣ ((w0 ∧ ¬ w1)→ w3)\n} = {\n  sylanbrc(w0, if(w1, w2, w3), (w1 → w2), (¬ w1 → w3))\n  ex(w0, w1, w2)\n  ex(w0, ¬ w1, w3)\n  dfifp2(w1, w2, w3)\n}","parent":["sylanbrc","ex","dfifp2"],"children":["ifpprsnss","wlkp1lem8","1wlkdlem4"]},{"name":"1fpid3","content":"The value of the conditional operator for propositions is its third argument if the first and second argument imply the third argument. (Contributed by AV, 4-Apr-2021.)","origin":"thm 1fpid3(wff w0, wff w1, wff w2) {\n  |- wi(wif(w0, w1, w2), w2)\n  -| wi(wa(w0, w1), w2)\n} = {\n  sylbi(wif(w0, w1, w2), w2, wo(wa(w0, w1), wa(wn(w0), w2)))\n  df-ifp(w0, w1, w2)\n  jaoi(wa(w0, w1), wa(wn(w0), w2), w2)\n  simpr(wn(w0), w2)\n}","pretty":"thm 1fpid3(wff w0, wff w1, wff w2) {\n  ⊢ (if(w0, w1, w2)→ w2)\n  ⊣ ((w0 ∧ w1)→ w2)\n} = {\n  sylbi(if(w0, w1, w2), w2, ((w0 ∧ w1)∨(¬ w0 ∧ w2)))\n  df-ifp(w0, w1, w2)\n  jaoi((w0 ∧ w1), (¬ w0 ∧ w2), w2)\n  simpr(¬ w0, w2)\n}","parent":["sylbi","df-ifp","jaoi","simpr"],"children":["ifpsnprss"]}]}