{"index":16,"title":"Logical \"xor\"","content":"","blocks":[{"name":"wxo","content":"Extend wff definition to include exclusive disjunction (\"xor\").","origin":"prop wff wxo(wff w0, wff w1) { (w0 ⊻ w1) }","pretty":"","parent":[],"children":[]},{"name":"diff.wxo.s","content":"","origin":"axiom diff.wxo.s(setvar sBase, wff w0, wff w1) {\n  |- diffsw(sBase, wxo(w0, w1))\n  -| diffsw(sBase, w0)\n  -| diffsw(sBase, w1)\n}","pretty":"axiom diff.wxo.s(setvar sBase, wff w0, wff w1) {\n  ⊢ d(sBase,(w0 ⊻ w1))\n  ⊣ d(sBase, w0)\n  ⊣ d(sBase, w1)\n}","parent":[],"children":[]},{"name":"diff.wxo.c","content":"","origin":"axiom diff.wxo.c(class cBase, wff w0, wff w1) {\n  |- diffcw(cBase, wxo(w0, w1))\n  -| diffcw(cBase, w0)\n  -| diffcw(cBase, w1)\n}","pretty":"axiom diff.wxo.c(class cBase, wff w0, wff w1) {\n  ⊢ d(cBase,(w0 ⊻ w1))\n  ⊣ d(cBase, w0)\n  ⊣ d(cBase, w1)\n}","parent":[],"children":[]},{"name":"diff.wxo.w","content":"","origin":"axiom diff.wxo.w(wff wBase, wff w0, wff w1) {\n  |- diffww(wBase, wxo(w0, w1))\n  -| diffww(wBase, w0)\n  -| diffww(wBase, w1)\n}","pretty":"axiom diff.wxo.w(wff wBase, wff w0, wff w1) {\n  ⊢ d(wBase,(w0 ⊻ w1))\n  ⊣ d(wBase, w0)\n  ⊣ d(wBase, w1)\n}","parent":[],"children":[]},{"name":"df-xor","content":"Define exclusive disjunction (logical \"xor\"). Return true if either the left or right, but not both, are true. After we define the constant true ` T. ` ( ~ df-tru ) and the constant false ` F. ` ( ~ df-fal ), we will be able to prove these truth table values: ` ( ( T. \\/_ T. ) <-> F. ) ` ( ~ truxortru ), ` ( ( T. \\/_ F. ) <-> T. ) ` ( ~ truxorfal ), ` ( ( F. \\/_ T. ) <-> T. ) ` ( ~ falxortru ), and ` ( ( F. \\/_ F. ) <-> F. ) ` ( ~ falxorfal ). Contrast with ` /\\ ` ( ~ df-an ), ` \\/ ` ( ~ df-or ), ` -> ` ( ~ wi ), and ` -/\\ ` ( ~ df-nan ). (Contributed by FL, 22-Nov-2010.)","origin":"axiom df-xor(wff w0, wff w1) {\n  |- wb(wxo(w0, w1), wn(wb(w0, w1)))\n}","pretty":"axiom df-xor(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)↔ ¬(w0 ↔ w1))\n}","parent":[],"children":["xnor","xorcom","xorass","excxor","xor2","xorneg2","xorbi12i","xorbi12d","anxordi","xorexmid","truxortru","truxorfal","falxorfal","hadbi","elsymdifxor","sadadd2lem2","f1omvdco3","tsxo3","tsxo4","ifpxorxorb","or3or","axorbtnotaiffb","axorbciffatcxorb","aisbnaxb","abnotbtaxb","abnotataxb","afv2orxorb"]},{"name":"xnor","content":"Two ways to write XNOR. (Contributed by Mario Carneiro, 4-Sep-2016.)","origin":"thm xnor(wff w0, wff w1) {\n  |- wb(wb(w0, w1), wn(wxo(w0, w1)))\n} = {\n  con2bii(wb(w0, w1), wxo(w0, w1))\n  df-xor(w0, w1)\n}","pretty":"thm xnor(wff w0, wff w1) {\n  ⊢ ((w0 ↔ w1)↔ ¬(w0 ⊻ w1))\n} = {\n  con2bii((w0 ↔ w1), (w0 ⊻ w1))\n  df-xor(w0, w1)\n}","parent":["con2bii","df-xor"],"children":["xorass","xorneg2","hadbi","had0","tsxo1","tsxo2"]},{"name":"xorcom","content":"The connector ` \\/_ ` is commutative. (Contributed by Mario Carneiro, 4-Sep-2016.)","origin":"thm xorcom(wff w0, wff w1) {\n  |- wb(wxo(w0, w1), wxo(w1, w0))\n} = {\n  3bitr4i(wxo(w0, w1), wxo(w1, w0), wn(wb(w0, w1)), wn(wb(w1, w0)))\n  notbii(wb(w0, w1), wb(w1, w0))\n  bicom(w0, w1)\n  df-xor(w0, w1)\n  df-xor(w1, w0)\n}","pretty":"thm xorcom(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)↔(w1 ⊻ w0))\n} = {\n  3bitr4i((w0 ⊻ w1), (w1 ⊻ w0), ¬(w0 ↔ w1), ¬(w1 ↔ w0))\n  notbii((w0 ↔ w1), (w1 ↔ w0))\n  bicom(w0, w1)\n  df-xor(w0, w1)\n  df-xor(w1, w0)\n}","parent":["3bitr4i","notbii","bicom","df-xor"],"children":["xorneg1","falxortru","hadcoma","hadcomb","cadcoma"]},{"name":"xorass","content":"The connector ` \\/_ ` is associative. (Contributed by FL, 22-Nov-2010.) (Proof shortened by Andrew Salmon, 8-Jun-2011.) (Proof shortened by Wolf Lammen, 20-Jun-2020.)","origin":"thm xorass(wff w0, wff w1, wff w2) {\n  |- wb(wxo(wxo(w0, w1), w2), wxo(w0, wxo(w1, w2)))\n} = {\n  3bitr4i(wxo(wxo(w0, w1), w2), wxo(w0, wxo(w1, w2)), wn(wb(wxo(w0, w1), w2)), wn(wb(w0, wxo(w1, w2))))\n  3bitr2ri(wn(wb(wxo(w0, w1), w2)), wn(wb(w0, wxo(w1, w2))), wb(w0, wn(wxo(w1, w2))), wb(wn(wxo(w0, w1)), w2))\n  xor3(w0, wxo(w1, w2))\n  3bitr3i(wb(wn(wxo(w0, w1)), w2), wb(w0, wn(wxo(w1, w2))), wb(wb(w0, w1), w2), wb(w0, wb(w1, w2)))\n  biass(w0, w1, w2)\n  bibi1i(wb(w0, w1), w2, wn(wxo(w0, w1)))\n  xnor(w0, w1)\n  bibi2i(w0, wb(w1, w2), wn(wxo(w1, w2)))\n  xnor(w1, w2)\n  nbbn(wxo(w0, w1), w2)\n  df-xor(wxo(w0, w1), w2)\n  df-xor(w0, wxo(w1, w2))\n}","pretty":"thm xorass(wff w0, wff w1, wff w2) {\n  ⊢ (((w0 ⊻ w1)⊻ w2)↔(w0 ⊻(w1 ⊻ w2)))\n} = {\n  3bitr4i(((w0 ⊻ w1)⊻ w2), (w0 ⊻(w1 ⊻ w2)), ¬((w0 ⊻ w1)↔ w2), ¬(w0 ↔(w1 ⊻ w2)))\n  3bitr2ri(¬((w0 ⊻ w1)↔ w2), ¬(w0 ↔(w1 ⊻ w2)), (w0 ↔ ¬(w1 ⊻ w2)), (¬(w0 ⊻ w1)↔ w2))\n  xor3(w0, (w1 ⊻ w2))\n  3bitr3i((¬(w0 ⊻ w1)↔ w2), (w0 ↔ ¬(w1 ⊻ w2)), ((w0 ↔ w1)↔ w2), (w0 ↔(w1 ↔ w2)))\n  biass(w0, w1, w2)\n  bibi1i((w0 ↔ w1), w2, ¬(w0 ⊻ w1))\n  xnor(w0, w1)\n  bibi2i(w0, (w1 ↔ w2), ¬(w1 ⊻ w2))\n  xnor(w1, w2)\n  nbbn((w0 ⊻ w1), w2)\n  df-xor((w0 ⊻ w1), w2)\n  df-xor(w0, (w1 ⊻ w2))\n}","parent":["3bitr4i","3bitr2ri","xor3","3bitr3i","biass","bibi1i","xnor","bibi2i","nbbn","df-xor"],"children":["hadass","symdifass"]},{"name":"excxor","content":"This tautology shows that xor is really exclusive. (Contributed by FL, 22-Nov-2010.)","origin":"thm excxor(wff w0, wff w1) {\n  |- wb(wxo(w0, w1), wo(wa(w0, wn(w1)), wa(wn(w0), w1)))\n} = {\n  3bitri(wxo(w0, w1), wo(wa(w0, wn(w1)), wa(wn(w0), w1)), wn(wb(w0, w1)), wo(wa(w0, wn(w1)), wa(w1, wn(w0))))\n  df-xor(w0, w1)\n  xor(w0, w1)\n  orbi2i(wa(w0, wn(w1)), wa(w1, wn(w0)), wa(wn(w0), w1))\n  ancom(w1, wn(w0))\n}","pretty":"thm excxor(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)↔((w0 ∧ ¬ w1)∨(¬ w0 ∧ w1)))\n} = {\n  3bitri((w0 ⊻ w1), ((w0 ∧ ¬ w1)∨(¬ w0 ∧ w1)), ¬(w0 ↔ w1), ((w0 ∧ ¬ w1)∨(w1 ∧ ¬ w0)))\n  df-xor(w0, w1)\n  xor(w0, w1)\n  orbi2i((w0 ∧ ¬ w1), (w1 ∧ ¬ w0), (¬ w0 ∧ w1))\n  ancom(w1, ¬ w0)\n}","parent":["3bitri","df-xor","xor","orbi2i","ancom"],"children":["f1omvdco2","psgnunilem5","psgnunilem5OLD","or3or"]},{"name":"xor2","content":"Two ways to express \"exclusive or\". (Contributed by Mario Carneiro, 4-Sep-2016.)","origin":"thm xor2(wff w0, wff w1) {\n  |- wb(wxo(w0, w1), wa(wo(w0, w1), wn(wa(w0, w1))))\n} = {\n  bitri(wxo(w0, w1), wa(wo(w0, w1), wn(wa(w0, w1))), wn(wb(w0, w1)))\n  df-xor(w0, w1)\n  nbi2(w0, w1)\n}","pretty":"thm xor2(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)↔((w0 ∨ w1)∧ ¬(w0 ∧ w1)))\n} = {\n  bitri((w0 ⊻ w1), ((w0 ∨ w1)∧ ¬(w0 ∧ w1)), ¬(w0 ↔ w1))\n  df-xor(w0, w1)\n  nbi2(w0, w1)\n}","parent":["bitri","df-xor","nbi2"],"children":["xoror","xornan","cador","saddisjlem","ifpdfxor","dfxor4","nanorxor"]},{"name":"xoror","content":"XOR implies OR. (Contributed by BJ, 19-Apr-2019.)","origin":"thm xoror(wff w0, wff w1) {\n  |- wi(wxo(w0, w1), wo(w0, w1))\n} = {\n  simplbi(wxo(w0, w1), wo(w0, w1), wn(wa(w0, w1)))\n  xor2(w0, w1)\n}","pretty":"thm xoror(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)→(w0 ∨ w1))\n} = {\n  simplbi((w0 ⊻ w1), (w0 ∨ w1), ¬(w0 ∧ w1))\n  xor2(w0, w1)\n}","parent":["simplbi","xor2"],"children":["mtpxor","afv2orxorb"]},{"name":"xornan","content":"XOR implies NAND. (Contributed by BJ, 19-Apr-2019.)","origin":"thm xornan(wff w0, wff w1) {\n  |- wi(wxo(w0, w1), wn(wa(w0, w1)))\n} = {\n  simprbi(wxo(w0, w1), wn(wa(w0, w1)), wo(w0, w1))\n  xor2(w0, w1)\n}","pretty":"thm xornan(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)→ ¬(w0 ∧ w1))\n} = {\n  simprbi((w0 ⊻ w1), ¬(w0 ∧ w1), (w0 ∨ w1))\n  xor2(w0, w1)\n}","parent":["simprbi","xor2"],"children":["xornan2","mptxor"]},{"name":"xornan2","content":"XOR implies NAND (written with the ` -/\\ ` connector). (Contributed by BJ, 19-Apr-2019.)","origin":"thm xornan2(wff w0, wff w1) {\n  |- wi(wxo(w0, w1), wnan(w0, w1))\n} = {\n  sylibr(wxo(w0, w1), wnan(w0, w1), wn(wa(w0, w1)))\n  xornan(w0, w1)\n  df-nan(w0, w1)\n}","pretty":"thm xornan2(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ w1)→(w0 ⊼ w1))\n} = {\n  sylibr((w0 ⊻ w1), (w0 ⊼ w1), ¬(w0 ∧ w1))\n  xornan(w0, w1)\n  df-nan(w0, w1)\n}","parent":["sylibr","xornan","df-nan"],"children":[]},{"name":"xorneg2","content":"The connector ` \\/_ ` is negated under negation of one argument. (Contributed by Mario Carneiro, 4-Sep-2016.) (Proof shortened by Wolf Lammen, 27-Jun-2020.)","origin":"thm xorneg2(wff w0, wff w1) {\n  |- wb(wxo(w0, wn(w1)), wn(wxo(w0, w1)))\n} = {\n  3bitr2i(wxo(w0, wn(w1)), wn(wxo(w0, w1)), wn(wb(w0, wn(w1))), wb(w0, w1))\n  df-xor(w0, wn(w1))\n  pm5.18(w0, w1)\n  xnor(w0, w1)\n}","pretty":"thm xorneg2(wff w0, wff w1) {\n  ⊢ ((w0 ⊻ ¬ w1)↔ ¬(w0 ⊻ w1))\n} = {\n  3bitr2i((w0 ⊻ ¬ w1), ¬(w0 ⊻ w1), ¬(w0 ↔ ¬ w1), (w0 ↔ w1))\n  df-xor(w0, ¬ w1)\n  pm5.18(w0, w1)\n  xnor(w0, w1)\n}","parent":["3bitr2i","df-xor","pm5.18","xnor"],"children":["xorneg1","xorneg"]},{"name":"xorneg1","content":"The connector ` \\/_ ` is negated under negation of one argument. (Contributed by Mario Carneiro, 4-Sep-2016.) (Proof shortened by Wolf Lammen, 27-Jun-2020.)","origin":"thm xorneg1(wff w0, wff w1) {\n  |- wb(wxo(wn(w0), w1), wn(wxo(w0, w1)))\n} = {\n  bitri(wxo(wn(w0), w1), wn(wxo(w0, w1)), wxo(w1, wn(w0)))\n  xorcom(wn(w0), w1)\n  xchbinx(wxo(w1, wn(w0)), wxo(w0, w1), wxo(w1, w0))\n  xorneg2(w1, w0)\n  xorcom(w1, w0)\n}","pretty":"thm xorneg1(wff w0, wff w1) {\n  ⊢ ((¬ w0 ⊻ w1)↔ ¬(w0 ⊻ w1))\n} = {\n  bitri((¬ w0 ⊻ w1), ¬(w0 ⊻ w1), (w1 ⊻ ¬ w0))\n  xorcom(¬ w0, w1)\n  xchbinx((w1 ⊻ ¬ w0), (w0 ⊻ w1), (w1 ⊻ w0))\n  xorneg2(w1, w0)\n  xorcom(w1, w0)\n}","parent":["bitri","xorcom","xchbinx","xorneg2"],"children":["xorneg"]},{"name":"xorneg","content":"The connector ` \\/_ ` is unchanged under negation of both arguments. (Contributed by Mario Carneiro, 4-Sep-2016.)","origin":"thm xorneg(wff w0, wff w1) {\n  |- wb(wxo(wn(w0), wn(w1)), wxo(w0, w1))\n} = {\n  bitr4i(wxo(wn(w0), wn(w1)), wxo(w0, w1), wn(wxo(w0, wn(w1))))\n  xorneg1(w0, wn(w1))\n  con2bii(wxo(w0, w1), wxo(w0, wn(w1)))\n  xorneg2(w0, w1)\n}","pretty":"thm xorneg(wff w0, wff w1) {\n  ⊢ ((¬ w0 ⊻ ¬ w1)↔(w0 ⊻ w1))\n} = {\n  bitr4i((¬ w0 ⊻ ¬ w1), (w0 ⊻ w1), ¬(w0 ⊻ ¬ w1))\n  xorneg1(w0, ¬ w1)\n  con2bii((w0 ⊻ w1), (w0 ⊻ ¬ w1))\n  xorneg2(w0, w1)\n}","parent":["bitr4i","xorneg1","con2bii","xorneg2"],"children":[]},{"name":"xorbi12i","content":"Equality property for XOR. (Contributed by Mario Carneiro, 4-Sep-2016.)","origin":"thm xorbi12i(wff w0, wff w1, wff w2, wff w3) {\n  |- wb(wxo(w0, w1), wxo(w2, w3))\n  -| wb(w0, w2)\n  -| wb(w1, w3)\n} = {\n  3bitr4i(wxo(w0, w1), wxo(w2, w3), wn(wb(w0, w1)), wn(wb(w2, w3)))\n  notbii(wb(w0, w1), wb(w2, w3))\n  bibi12i(w0, w1, w2, w3)\n  df-xor(w0, w1)\n  df-xor(w2, w3)\n}","pretty":"thm xorbi12i(wff w0, wff w1, wff w2, wff w3) {\n  ⊢ ((w0 ⊻ w1)↔(w2 ⊻ w3))\n  ⊣ (w0 ↔ w2)\n  ⊣ (w1 ↔ w3)\n} = {\n  3bitr4i((w0 ⊻ w1), (w2 ⊻ w3), ¬(w0 ↔ w1), ¬(w2 ↔ w3))\n  notbii((w0 ↔ w1), (w2 ↔ w3))\n  bibi12i(w0, w1, w2, w3)\n  df-xor(w0, w1)\n  df-xor(w2, w3)\n}","parent":["3bitr4i","notbii","bibi12i","df-xor"],"children":["hadcoma","hadcomb","symdifass"]},{"name":"xorbi12d","content":"Equality property for XOR. (Contributed by Mario Carneiro, 4-Sep-2016.)","origin":"thm xorbi12d(wff w0, wff w1, wff w2, wff w3, wff w4) {\n  |- wi(w0, wb(wxo(w1, w2), wxo(w3, w4)))\n  -| wi(w0, wb(w1, w3))\n  -| wi(w0, wb(w2, w4))\n} = {\n  3bitr4g(w0, wxo(w1, w2), wxo(w3, w4), wn(wb(w1, w2)), wn(wb(w3, w4)))\n  notbid(w0, wb(w1, w2), wb(w3, w4))\n  bibi12d(w0, w1, w2, w3, w4)\n  df-xor(w1, w2)\n  df-xor(w3, w4)\n}","pretty":"thm xorbi12d(wff w0, wff w1, wff w2, wff w3, wff w4) {\n  ⊢ (w0 →((w1 ⊻ w2)↔(w3 ⊻ w4)))\n  ⊣ (w0 →(w1 ↔ w3))\n  ⊣ (w0 →(w2 ↔ w4))\n} = {\n  3bitr4g(w0, (w1 ⊻ w2), (w3 ⊻ w4), ¬(w1 ↔ w2), ¬(w3 ↔ w4))\n  notbid(w0, (w1 ↔ w2), (w3 ↔ w4))\n  bibi12d(w0, w1, w2, w3, w4)\n  df-xor(w1, w2)\n  df-xor(w3, w4)\n}","parent":["3bitr4g","notbid","bibi12d","df-xor"],"children":["hadbi123d","cadbi123d"]},{"name":"anxordi","content":"Conjunction distributes over exclusive-or. In intuitionistic logic this assertion is also true, even though ~ xordi does not necessarily hold, in part because the usual definition of xor is subtly different in intuitionistic logic. (Contributed by David A. Wheeler, 7-Oct-2018.)","origin":"thm anxordi(wff w0, wff w1, wff w2) {\n  |- wb(wa(w0, wxo(w1, w2)), wxo(wa(w0, w1), wa(w0, w2)))\n} = {\n  3bitr4i(wa(w0, wxo(w1, w2)), wxo(wa(w0, w1), wa(w0, w2)), wa(w0, wn(wb(w1, w2))), wn(wb(wa(w0, w1), wa(w0, w2))))\n  xordi(w0, w1, w2)\n  anbi2i(w0, wxo(w1, w2), wn(wb(w1, w2)))\n  df-xor(w1, w2)\n  df-xor(wa(w0, w1), wa(w0, w2))\n}","pretty":"thm anxordi(wff w0, wff w1, wff w2) {\n  ⊢ ((w0 ∧(w1 ⊻ w2))↔((w0 ∧ w1)⊻(w0 ∧ w2)))\n} = {\n  3bitr4i((w0 ∧(w1 ⊻ w2)), ((w0 ∧ w1)⊻(w0 ∧ w2)), (w0 ∧ ¬(w1 ↔ w2)), ¬((w0 ∧ w1)↔(w0 ∧ w2)))\n  xordi(w0, w1, w2)\n  anbi2i(w0, (w1 ⊻ w2), ¬(w1 ↔ w2))\n  df-xor(w1, w2)\n  df-xor((w0 ∧ w1), (w0 ∧ w2))\n}","parent":["3bitr4i","xordi","anbi2i","df-xor"],"children":[]},{"name":"xorexmid","content":"Exclusive-or variant of the law of the excluded middle ( ~ exmid ). This statement is ancient, going back to at least Stoic logic. This statement does not necessarily hold in intuitionistic logic. (Contributed by David A. Wheeler, 23-Feb-2019.)","origin":"thm xorexmid(wff w0) {\n  |- wxo(w0, wn(w0))\n} = {\n  mpbir(wxo(w0, wn(w0)), wn(wb(w0, wn(w0))))\n  pm5.19(w0)\n  df-xor(w0, wn(w0))\n}","pretty":"thm xorexmid(wff w0) {\n  ⊢ (w0 ⊻ ¬ w0)\n} = {\n  mpbir((w0 ⊻ ¬ w0), ¬(w0 ↔ ¬ w0))\n  pm5.19(w0)\n  df-xor(w0, ¬ w0)\n}","parent":["mpbir","pm5.19","df-xor"],"children":[]}]}