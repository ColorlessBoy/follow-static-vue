{"index":1510,"title":"Internal binary operations","content":"In this subsection, \"internal binary operations\" obeying different laws are defined.","blocks":[{"name":"cintop","content":"Extend class notation with class of internal (binary) operations for a set.","origin":"const class cintop { intOp }","pretty":"","parent":[],"children":[]},{"name":"diff.cintop.s","content":"","origin":"axiom diff.cintop.s(setvar s0) {\n  |- diffsc(s0, cintop)\n}","pretty":"axiom diff.cintop.s(setvar s0) {\n  ‚ä¢ d(s0, intOp)\n}","parent":[],"children":[]},{"name":"diff.cintop.c","content":"","origin":"axiom diff.cintop.c(class c0) {\n  |- diffcc(cintop, c0)\n}","pretty":"axiom diff.cintop.c(class c0) {\n  ‚ä¢ d(intOp, c0)\n}","parent":[],"children":[]},{"name":"diff.cintop.w","content":"","origin":"axiom diff.cintop.w(wff w0) {\n  |- diffcw(cintop, w0)\n}","pretty":"axiom diff.cintop.w(wff w0) {\n  ‚ä¢ d(intOp, w0)\n}","parent":[],"children":[]},{"name":"cclintop","content":"Extend class notation with class of closed operations for a set.","origin":"const class cclintop { clIntOp }","pretty":"","parent":[],"children":[]},{"name":"diff.cclintop.s","content":"","origin":"axiom diff.cclintop.s(setvar s0) {\n  |- diffsc(s0, cclintop)\n}","pretty":"axiom diff.cclintop.s(setvar s0) {\n  ‚ä¢ d(s0, clIntOp)\n}","parent":[],"children":[]},{"name":"diff.cclintop.c","content":"","origin":"axiom diff.cclintop.c(class c0) {\n  |- diffcc(cclintop, c0)\n}","pretty":"axiom diff.cclintop.c(class c0) {\n  ‚ä¢ d(clIntOp, c0)\n}","parent":[],"children":[]},{"name":"diff.cclintop.w","content":"","origin":"axiom diff.cclintop.w(wff w0) {\n  |- diffcw(cclintop, w0)\n}","pretty":"axiom diff.cclintop.w(wff w0) {\n  ‚ä¢ d(clIntOp, w0)\n}","parent":[],"children":[]},{"name":"cassintop","content":"Extend class notation with class of associative operations for a set.","origin":"const class cassintop { assIntOp }","pretty":"","parent":[],"children":[]},{"name":"diff.cassintop.s","content":"","origin":"axiom diff.cassintop.s(setvar s0) {\n  |- diffsc(s0, cassintop)\n}","pretty":"axiom diff.cassintop.s(setvar s0) {\n  ‚ä¢ d(s0, assIntOp)\n}","parent":[],"children":[]},{"name":"diff.cassintop.c","content":"","origin":"axiom diff.cassintop.c(class c0) {\n  |- diffcc(cassintop, c0)\n}","pretty":"axiom diff.cassintop.c(class c0) {\n  ‚ä¢ d(assIntOp, c0)\n}","parent":[],"children":[]},{"name":"diff.cassintop.w","content":"","origin":"axiom diff.cassintop.w(wff w0) {\n  |- diffcw(cassintop, w0)\n}","pretty":"axiom diff.cassintop.w(wff w0) {\n  ‚ä¢ d(assIntOp, w0)\n}","parent":[],"children":[]},{"name":"df-intop","content":"Function mapping a set to the class of all internal (binary) operations for this set. (Contributed by AV, 20-Jan-2020.)","origin":"axiom df-intop(setvar s0, setvar s1) {\n  |- wceq(cintop, cmpo(s0, s1, universe, universe, co(cv(s1), cmap, cxp(cv(s0), cv(s0)))))\n  -| diffss(s0, s1)\n}","pretty":"axiom df-intop(setvar s0, setvar s1) {\n  ‚ä¢ intOp =(s0 ‚àà ùïå, s1 ‚àà ùïå ‚Ü¶(s1[‚Ü¶](s0 √ó s0)))\n  ‚ä£ d(s0, s1)\n}","parent":[],"children":["intopval","intop"]},{"name":"df-clintop","content":"Function mapping a set to the class of all closed (internal binary) operations for this set, see definition in section 1.2 of [Hall] p. 2, definition in section I.1 of [Bruck] p. 1, or definition 1 in [BourbakiAlg1] p. 1, where it is called \"a law of composition\". (Contributed by AV, 20-Jan-2020.)","origin":"axiom df-clintop(setvar s0) {\n  |- wceq(cclintop, cmpt(s0, universe, co(cv(s0), cintop, cv(s0))))\n}","pretty":"axiom df-clintop(setvar s0) {\n  ‚ä¢ clIntOp =(s0 ‚àà ùïå ‚Ü¶(s0[intOp]s0))\n}","parent":[],"children":["clintopval"]},{"name":"df-assintop","content":"Function mapping a set to the class of all associative (closed internal binary) operations for this set, see definition 5 in [BourbakiAlg1] p. 4, where it is called \"an associative law of composition\". (Contributed by AV, 20-Jan-2020.)","origin":"axiom df-assintop(setvar s0, setvar s1) {\n  |- wceq(cassintop, cmpt(s0, universe, crab(s1, cfv(cclintop, cv(s0)), wbr(cv(s1), casslaw, cv(s0)))))\n  -| diffss(s0, s1)\n}","pretty":"axiom df-assintop(setvar s0, setvar s1) {\n  ‚ä¢ assIntOp =(s0 ‚àà ùïå ‚Ü¶ { s1 ‚àà(clIntOp ` s0)| s1[assLaw]s0 })\n  ‚ä£ d(s0, s1)\n}","parent":[],"children":["assintopval"]},{"name":"intopval","content":"The internal (binary) operations for a set. (Contributed by AV, 20-Jan-2020.)","origin":"thm intopval(class c0, class c1, class c2, class c3) {\n  |- wi(wa(wcel(c0, c1), wcel(c2, c3)), wceq(co(c0, cintop, c2), co(c2, cmap, cxp(c0, c0))))\n} = {\n  ovmpt2d(hs0, hs1, c0, cintop, c2, co(c2, cmap, cxp(c0, c0)), universe, universe, co(cv(hs1), cmap, cxp(cv(hs0), cv(hs0))), universe, wa(wcel(c0, c1), wcel(c2, c3)))\n  a1i(wa(wcel(c0, c1), wcel(c2, c3)), wceq(cintop, cmpo(hs0, hs1, universe, universe, co(cv(hs1), cmap, cxp(cv(hs0), cv(hs0))))))\n  df-intop(hs0, hs1)\n  adantl(wa(wcel(c0, c1), wcel(c2, c3)), wa(wceq(cv(hs0), c0), wceq(cv(hs1), c2)), wceq(co(cv(hs1), cmap, cxp(cv(hs0), cv(hs0))), co(c2, cmap, cxp(c0, c0))))\n  oveq12d(cv(hs1), cmap, cxp(cv(hs0), cv(hs0)), c2, cxp(c0, c0), wa(wceq(cv(hs0), c0), wceq(cv(hs1), c2)))\n  simpr(wceq(cv(hs0), c0), wceq(cv(hs1), c2))\n  sqxpeqd(cv(hs0), c0, wa(wceq(cv(hs0), c0), wceq(cv(hs1), c2)))\n  simpl(wceq(cv(hs0), c0), wceq(cv(hs1), c2))\n  adantr(wcel(c0, c1), wcel(c2, c3), wcel(c0, universe))\n  elex(c0, c1)\n  adantl(wcel(c0, c1), wcel(c2, c3), wcel(c2, universe))\n  elex(c2, c3)\n  ovexd(c2, cmap, cxp(c0, c0), wa(wcel(c0, c1), wcel(c2, c3)))\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c2)\n  diff.hs0.c(co(c2, cmap, cxp(c0, c0)))\n  diff.hs1.c(c0)\n  diff.hs1.c(c2)\n  diff.hs1.c(co(c2, cmap, cxp(c0, c0)))\n  diff.hs0.w(wa(wcel(c0, c1), wcel(c2, c3)))\n  diff.hs1.w(wa(wcel(c0, c1), wcel(c2, c3)))\n}","pretty":"thm intopval(class c0, class c1, class c2, class c3) {\n  ‚ä¢ ((c0 ‚àà c1 ‚àß c2 ‚àà c3)‚Üí(c0[intOp]c2)=(c2[‚Ü¶](c0 √ó c0)))\n} = {\n  ovmpt2d(hs0, hs1, c0, cintop, c2, (c2[‚Ü¶](c0 √ó c0)), universe, universe, (hs1[‚Ü¶](hs0 √ó hs0)), universe, (c0 ‚àà c1 ‚àß c2 ‚àà c3))\n  a1i((c0 ‚àà c1 ‚àß c2 ‚àà c3), intOp =(hs0 ‚àà ùïå, hs1 ‚àà ùïå ‚Ü¶(hs1[‚Ü¶](hs0 √ó hs0))))\n  df-intop(hs0, hs1)\n  adantl((c0 ‚àà c1 ‚àß c2 ‚àà c3), (hs0 = c0 ‚àß hs1 = c2), (hs1[‚Ü¶](hs0 √ó hs0))=(c2[‚Ü¶](c0 √ó c0)))\n  oveq12d(hs1, cmap, (hs0 √ó hs0), c2, (c0 √ó c0), (hs0 = c0 ‚àß hs1 = c2))\n  simpr(hs0 = c0, hs1 = c2)\n  sqxpeqd(hs0, c0, (hs0 = c0 ‚àß hs1 = c2))\n  simpl(hs0 = c0, hs1 = c2)\n  adantr(c0 ‚àà c1, c2 ‚àà c3, c0 ‚àà ùïå)\n  elex(c0, c1)\n  adantl(c0 ‚àà c1, c2 ‚àà c3, c2 ‚àà ùïå)\n  elex(c2, c3)\n  ovexd(c2, cmap, (c0 √ó c0), (c0 ‚àà c1 ‚àß c2 ‚àà c3))\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c2)\n  diff.hs0.c((c2[‚Ü¶](c0 √ó c0)))\n  diff.hs1.c(c0)\n  diff.hs1.c(c2)\n  diff.hs1.c((c2[‚Ü¶](c0 √ó c0)))\n  diff.hs0.w((c0 ‚àà c1 ‚àß c2 ‚àà c3))\n  diff.hs1.w((c0 ‚àà c1 ‚àß c2 ‚àà c3))\n}","parent":["ovmpt2d","a1i","df-intop","adantl","oveq12d","simpr","sqxpeqd","simpl","adantr","elex","ovexd","diff.hs0.s","diff.hs0.c","diff.hs1.c","diff.hs0.w","diff.hs1.w"],"children":["intop","clintopval"]},{"name":"intop","content":"An internal (binary) operation for a set. (Contributed by AV, 20-Jan-2020.)","origin":"thm intop(class c0, class c1, class c2) {\n  |- wi(wcel(c0, co(c1, cintop, c2)), wf(c0, cxp(c1, c1), c2))\n} = {\n  mpcom(wcel(c0, co(c1, cintop, c2)), wf(c0, cxp(c1, c1), c2), wa(wcel(c1, universe), wcel(c2, universe)))\n  elmpt2cl(hs0, hs1, c0, c1, cintop, c2, universe, universe, co(cv(hs1), cmap, cxp(cv(hs0), cv(hs0))))\n  df-intop(hs0, hs1)\n  syl6bi(wa(wcel(c1, universe), wcel(c2, universe)), wcel(c0, co(c1, cintop, c2)), wf(c0, cxp(c1, c1), c2), wcel(c0, co(c2, cmap, cxp(c1, c1))))\n  eleq2d(c0, co(c1, cintop, c2), co(c2, cmap, cxp(c1, c1)), wa(wcel(c1, universe), wcel(c2, universe)))\n  intopval(c1, universe, c2, universe)\n  elmapi(c0, c2, cxp(c1, c1))\n  diff.hs0.s(hs1)\n  diff.hs0.c(universe)\n  diff.hs1.c(universe)\n}","pretty":"thm intop(class c0, class c1, class c2) {\n  ‚ä¢ (c0 ‚àà(c1[intOp]c2)‚Üí(c0 :(c1 √ó c1)‚Üí c2))\n} = {\n  mpcom(c0 ‚àà(c1[intOp]c2), (c0 :(c1 √ó c1)‚Üí c2), (c1 ‚àà ùïå ‚àß c2 ‚àà ùïå))\n  elmpt2cl(hs0, hs1, c0, c1, cintop, c2, universe, universe, (hs1[‚Ü¶](hs0 √ó hs0)))\n  df-intop(hs0, hs1)\n  syl6bi((c1 ‚àà ùïå ‚àß c2 ‚àà ùïå), c0 ‚àà(c1[intOp]c2), (c0 :(c1 √ó c1)‚Üí c2), c0 ‚àà(c2[‚Ü¶](c1 √ó c1)))\n  eleq2d(c0, (c1[intOp]c2), (c2[‚Ü¶](c1 √ó c1)), (c1 ‚àà ùïå ‚àß c2 ‚àà ùïå))\n  intopval(c1, universe, c2, universe)\n  elmapi(c0, c2, (c1 √ó c1))\n  diff.hs0.s(hs1)\n  diff.hs0.c(universe)\n  diff.hs1.c(universe)\n}","parent":["mpcom","elmpt2cl","df-intop","syl6bi","eleq2d","intopval","elmapi","diff.hs0.s","diff.hs0.c","diff.hs1.c"],"children":[]},{"name":"clintopval","content":"The closed (internal binary) operations for a set. (Contributed by AV, 20-Jan-2020.)","origin":"thm clintopval(class c0, class c1) {\n  |- wi(wcel(c0, c1), wceq(cfv(cclintop, c0), co(c0, cmap, cxp(c0, c0))))\n} = {\n  fvmptd(hs0, cclintop, c0, co(c0, cmap, cxp(c0, c0)), universe, co(cv(hs0), cintop, cv(hs0)), universe, wcel(c0, c1))\n  a1i(wcel(c0, c1), wceq(cclintop, cmpt(hs0, universe, co(cv(hs0), cintop, cv(hs0)))))\n  df-clintop(hs0)\n  sylan9eqr(co(cv(hs0), cintop, cv(hs0)), co(c0, cmap, cxp(c0, c0)), co(c0, cintop, c0), wcel(c0, c1), wceq(cv(hs0), c0))\n  oveq12d(cv(hs0), cintop, cv(hs0), c0, c0, wceq(cv(hs0), c0))\n  id(wceq(cv(hs0), c0))\n  anidms(wcel(c0, c1), wceq(co(c0, cintop, c0), co(c0, cmap, cxp(c0, c0))))\n  intopval(c0, c1, c0, c1)\n  elex(c0, c1)\n  ovexd(c0, cmap, cxp(c0, c0), wcel(c0, c1))\n  diff.hs0.c(c0)\n  diff.hs0.c(co(c0, cmap, cxp(c0, c0)))\n  diff.hs0.c(universe)\n  diff.hs0.w(wcel(c0, c1))\n}","pretty":"thm clintopval(class c0, class c1) {\n  ‚ä¢ (c0 ‚àà c1 ‚Üí(clIntOp ` c0)=(c0[‚Ü¶](c0 √ó c0)))\n} = {\n  fvmptd(hs0, cclintop, c0, (c0[‚Ü¶](c0 √ó c0)), universe, (hs0[intOp]hs0), universe, c0 ‚àà c1)\n  a1i(c0 ‚àà c1, clIntOp =(hs0 ‚àà ùïå ‚Ü¶(hs0[intOp]hs0)))\n  df-clintop(hs0)\n  sylan9eqr((hs0[intOp]hs0), (c0[‚Ü¶](c0 √ó c0)), (c0[intOp]c0), c0 ‚àà c1, hs0 = c0)\n  oveq12d(hs0, cintop, hs0, c0, c0, hs0 = c0)\n  id(hs0 = c0)\n  anidms(c0 ‚àà c1, (c0[intOp]c0)=(c0[‚Ü¶](c0 √ó c0)))\n  intopval(c0, c1, c0, c1)\n  elex(c0, c1)\n  ovexd(c0, cmap, (c0 √ó c0), c0 ‚àà c1)\n  diff.hs0.c(c0)\n  diff.hs0.c((c0[‚Ü¶](c0 √ó c0)))\n  diff.hs0.c(universe)\n  diff.hs0.w(c0 ‚àà c1)\n}","parent":["fvmptd","a1i","df-clintop","sylan9eqr","oveq12d","id","anidms","intopval","elex","ovexd","diff.hs0.c","diff.hs0.w"],"children":["assintopmap","isclintop"]},{"name":"assintopval","content":"The associative (closed internal binary) operations for a set. (Contributed by AV, 20-Jan-2020.)","origin":"thm assintopval(setvar s0, class c0, class c1) {\n  |- wi(wcel(c0, c1), wceq(cfv(cassintop, c0), crab(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0))))\n  -| diffsc(s0, c0)\n} = {\n  fvmptd(hs0, cassintop, c0, crab(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0)), universe, crab(s0, cfv(cclintop, cv(hs0)), wbr(cv(s0), casslaw, cv(hs0))), universe, wcel(c0, c1))\n  a1i(wcel(c0, c1), wceq(cassintop, cmpt(hs0, universe, crab(s0, cfv(cclintop, cv(hs0)), wbr(cv(s0), casslaw, cv(hs0))))))\n  df-assintop(hs0, s0)\n  adantl(wcel(c0, c1), wceq(cv(hs0), c0), wceq(crab(s0, cfv(cclintop, cv(hs0)), wbr(cv(s0), casslaw, cv(hs0))), crab(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0))))\n  rabeqbidv(s0, cfv(cclintop, cv(hs0)), cfv(cclintop, c0), wceq(cv(hs0), c0), wbr(cv(s0), casslaw, cv(hs0)), wbr(cv(s0), casslaw, c0))\n  fveq2(cv(hs0), c0, cclintop)\n  breq2(cv(hs0), c0, cv(s0), casslaw)\n  elex(c0, c1)\n  a1i(wcel(c0, c1), wcel(crab(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0)), universe))\n  rabex(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0))\n  fvex(cclintop, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c(crab(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0)))\n  diff.hs0.c(universe)\n  diff.hs0.w(wcel(c0, c1))\n  diff.cfv.s(s0, cclintop, cv(hs0))\n  diff.cfv.s(s0, cclintop, c0)\n  diff.cclintop.s(s0)\n  diff.wceq.s(s0, cv(hs0), c0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm assintopval(setvar s0, class c0, class c1) {\n  ‚ä¢ (c0 ‚àà c1 ‚Üí(assIntOp ` c0)= { s0 ‚àà(clIntOp ` c0)| s0[assLaw]c0 })\n  ‚ä£ d(s0, c0)\n} = {\n  fvmptd(hs0, cassintop, c0, { s0 ‚àà(clIntOp ` c0)| s0[assLaw]c0 }, universe, { s0 ‚àà(clIntOp ` hs0)| s0[assLaw]hs0 }, universe, c0 ‚àà c1)\n  a1i(c0 ‚àà c1, assIntOp =(hs0 ‚àà ùïå ‚Ü¶ { s0 ‚àà(clIntOp ` hs0)| s0[assLaw]hs0 }))\n  df-assintop(hs0, s0)\n  adantl(c0 ‚àà c1, hs0 = c0, { s0 ‚àà(clIntOp ` hs0)| s0[assLaw]hs0 } = { s0 ‚àà(clIntOp ` c0)| s0[assLaw]c0 })\n  rabeqbidv(s0, (clIntOp ` hs0), (clIntOp ` c0), hs0 = c0, s0[assLaw]hs0, s0[assLaw]c0)\n  fveq2(hs0, c0, cclintop)\n  breq2(hs0, c0, s0, casslaw)\n  elex(c0, c1)\n  a1i(c0 ‚àà c1, { s0 ‚àà(clIntOp ` c0)| s0[assLaw]c0 } ‚àà ùïå)\n  rabex(s0, (clIntOp ` c0), s0[assLaw]c0)\n  fvex(cclintop, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c({ s0 ‚àà(clIntOp ` c0)| s0[assLaw]c0 })\n  diff.hs0.c(universe)\n  diff.hs0.w(c0 ‚àà c1)\n  diff.cfv.s(s0, cclintop, hs0)\n  diff.cfv.s(s0, cclintop, c0)\n  diff.cclintop.s(s0)\n  diff.wceq.s(s0, hs0, c0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["fvmptd","a1i","df-assintop","adantl","rabeqbidv","fveq2","breq2","elex","rabex","fvex","diff.hs0.c","diff.hs0.w","diff.cfv.s","diff.cclintop.s","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":["assintopmap","isassintop","assintopcllaw"]},{"name":"assintopmap","content":"The associative (closed internal binary) operations for a set, expressed with set exponentiation. (Contributed by AV, 20-Jan-2020.)","origin":"thm assintopmap(setvar s0, class c0, class c1) {\n  |- wi(wcel(c0, c1), wceq(cfv(cassintop, c0), crab(s0, co(c0, cmap, cxp(c0, c0)), wbr(cv(s0), casslaw, c0))))\n  -| diffsc(s0, c0)\n} = {\n  eqtrd(cfv(cassintop, c0), crab(s0, co(c0, cmap, cxp(c0, c0)), wbr(cv(s0), casslaw, c0)), crab(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0)), wcel(c0, c1))\n  assintopval(s0, c0, c1)\n  syl(wcel(c0, c1), wceq(crab(s0, cfv(cclintop, c0), wbr(cv(s0), casslaw, c0)), crab(s0, co(c0, cmap, cxp(c0, c0)), wbr(cv(s0), casslaw, c0))), wceq(cfv(cclintop, c0), co(c0, cmap, cxp(c0, c0))))\n  clintopval(c0, c1)\n  rabeq(s0, cfv(cclintop, c0), co(c0, cmap, cxp(c0, c0)), wbr(cv(s0), casslaw, c0))\n  diff.cfv.s(s0, cclintop, c0)\n  diff.cclintop.s(s0)\n  diff.co.s(s0, c0, cmap, cxp(c0, c0))\n  diff.cmap.s(s0)\n  diff.cxp.s(s0, c0, c0)\n}","pretty":"thm assintopmap(setvar s0, class c0, class c1) {\n  ‚ä¢ (c0 ‚àà c1 ‚Üí(assIntOp ` c0)= { s0 ‚àà(c0[‚Ü¶](c0 √ó c0))| s0[assLaw]c0 })\n  ‚ä£ d(s0, c0)\n} = {\n  eqtrd((assIntOp ` c0), { s0 ‚àà(c0[‚Ü¶](c0 √ó c0))| s0[assLaw]c0 }, { s0 ‚àà(clIntOp ` c0)| s0[assLaw]c0 }, c0 ‚àà c1)\n  assintopval(s0, c0, c1)\n  syl(c0 ‚àà c1, { s0 ‚àà(clIntOp ` c0)| s0[assLaw]c0 } = { s0 ‚àà(c0[‚Ü¶](c0 √ó c0))| s0[assLaw]c0 }, (clIntOp ` c0)=(c0[‚Ü¶](c0 √ó c0)))\n  clintopval(c0, c1)\n  rabeq(s0, (clIntOp ` c0), (c0[‚Ü¶](c0 √ó c0)), s0[assLaw]c0)\n  diff.cfv.s(s0, cclintop, c0)\n  diff.cclintop.s(s0)\n  diff.co.s(s0, c0, cmap, (c0 √ó c0))\n  diff.cmap.s(s0)\n  diff.cxp.s(s0, c0, c0)\n}","parent":["eqtrd","assintopval","syl","clintopval","rabeq","diff.cfv.s","diff.cclintop.s","diff.co.s","diff.cmap.s","diff.cxp.s"],"children":["assintop","isassintop"]},{"name":"isclintop","content":"The predicate \"is a closed (internal binary) operations for a set\". (Contributed by FL, 2-Nov-2009.) (Revised by AV, 20-Jan-2020.)","origin":"thm isclintop(class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wb(wcel(c2, cfv(cclintop, c0)), wf(c2, cxp(c0, c0), c0)))\n} = {\n  bitrd(wcel(c0, c1), wcel(c2, cfv(cclintop, c0)), wf(c2, cxp(c0, c0), c0), wcel(c2, co(c0, cmap, cxp(c0, c0))))\n  eleq2d(c2, cfv(cclintop, c0), co(c0, cmap, cxp(c0, c0)), wcel(c0, c1))\n  clintopval(c0, c1)\n  mpdan(wcel(c0, c1), wb(wcel(c2, co(c0, cmap, cxp(c0, c0))), wf(c2, cxp(c0, c0), c0)), wcel(cxp(c0, c0), universe))\n  sqxpexg(c0, c1)\n  elmapg(c0, c1, cxp(c0, c0), universe, c2)\n}","pretty":"thm isclintop(class c0, class c1, class c2) {\n  ‚ä¢ (c0 ‚àà c1 ‚Üí(c2 ‚àà(clIntOp ` c0)‚Üî(c2 :(c0 √ó c0)‚Üí c0)))\n} = {\n  bitrd(c0 ‚àà c1, c2 ‚àà(clIntOp ` c0), (c2 :(c0 √ó c0)‚Üí c0), c2 ‚àà(c0[‚Ü¶](c0 √ó c0)))\n  eleq2d(c2, (clIntOp ` c0), (c0[‚Ü¶](c0 √ó c0)), c0 ‚àà c1)\n  clintopval(c0, c1)\n  mpdan(c0 ‚àà c1, (c2 ‚àà(c0[‚Ü¶](c0 √ó c0))‚Üî(c2 :(c0 √ó c0)‚Üí c0)), (c0 √ó c0)‚àà ùïå)\n  sqxpexg(c0, c1)\n  elmapg(c0, c1, (c0 √ó c0), universe, c2)\n}","parent":["bitrd","eleq2d","clintopval","mpdan","sqxpexg","elmapg"],"children":["clintop","isassintop"]},{"name":"clintop","content":"A closed (internal binary) operation for a set. (Contributed by AV, 20-Jan-2020.)","origin":"thm clintop(class c0, class c1) {\n  |- wi(wcel(c0, cfv(cclintop, c1)), wf(c0, cxp(c1, c1), c1))\n} = {\n  mpcom(wcel(c0, cfv(cclintop, c1)), wf(c0, cxp(c1, c1), c1), wcel(c1, universe))\n  elfvex(c0, cclintop, c1)\n  biimpd(wcel(c1, universe), wcel(c0, cfv(cclintop, c1)), wf(c0, cxp(c1, c1), c1))\n  isclintop(c1, universe, c0)\n}","pretty":"thm clintop(class c0, class c1) {\n  ‚ä¢ (c0 ‚àà(clIntOp ` c1)‚Üí(c0 :(c1 √ó c1)‚Üí c1))\n} = {\n  mpcom(c0 ‚àà(clIntOp ` c1), (c0 :(c1 √ó c1)‚Üí c1), c1 ‚àà ùïå)\n  elfvex(c0, cclintop, c1)\n  biimpd(c1 ‚àà ùïå, c0 ‚àà(clIntOp ` c1), (c0 :(c1 √ó c1)‚Üí c1))\n  isclintop(c1, universe, c0)\n}","parent":["mpcom","elfvex","biimpd","isclintop"],"children":["clintopcllaw"]},{"name":"assintop","content":"An associative (closed internal binary) operation for a set. (Contributed by AV, 20-Jan-2020.)","origin":"thm assintop(class c0, class c1) {\n  |- wi(wcel(c0, cfv(cassintop, c1)), wa(wf(c0, cxp(c1, c1), c1), wbr(c0, casslaw, c1)))\n} = {\n  mpcom(wcel(c0, cfv(cassintop, c1)), wa(wf(c0, cxp(c1, c1), c1), wbr(c0, casslaw, c1)), wcel(c1, universe))\n  elfvex(c0, cassintop, c1)\n  syl6bi(wcel(c1, universe), wcel(c0, cfv(cassintop, c1)), wa(wf(c0, cxp(c1, c1), c1), wbr(c0, casslaw, c1)), wcel(c0, crab(hs0, co(c1, cmap, cxp(c1, c1)), wbr(cv(hs0), casslaw, c1))))\n  eleq2d(c0, cfv(cassintop, c1), crab(hs0, co(c1, cmap, cxp(c1, c1)), wbr(cv(hs0), casslaw, c1)), wcel(c1, universe))\n  assintopmap(hs0, c1, universe)\n  sylbi(wcel(c0, crab(hs0, co(c1, cmap, cxp(c1, c1)), wbr(cv(hs0), casslaw, c1))), wa(wf(c0, cxp(c1, c1), c1), wbr(c0, casslaw, c1)), wa(wcel(c0, co(c1, cmap, cxp(c1, c1))), wbr(c0, casslaw, c1)))\n  elrab(hs0, c0, co(c1, cmap, cxp(c1, c1)), wbr(cv(hs0), casslaw, c1), wbr(c0, casslaw, c1))\n  breq1(cv(hs0), c0, casslaw, c1)\n  anim1i(wcel(c0, co(c1, cmap, cxp(c1, c1))), wbr(c0, casslaw, c1), wf(c0, cxp(c1, c1), c1))\n  elmapi(c0, c1, cxp(c1, c1))\n  diff.hs0.c(c1)\n  diff.hs0.c(c0)\n  diff.hs0.c(co(c1, cmap, cxp(c1, c1)))\n  diff.hs0.w(wbr(c0, casslaw, c1))\n}","pretty":"thm assintop(class c0, class c1) {\n  ‚ä¢ (c0 ‚àà(assIntOp ` c1)‚Üí((c0 :(c1 √ó c1)‚Üí c1)‚àß c0[assLaw]c1))\n} = {\n  mpcom(c0 ‚àà(assIntOp ` c1), ((c0 :(c1 √ó c1)‚Üí c1)‚àß c0[assLaw]c1), c1 ‚àà ùïå)\n  elfvex(c0, cassintop, c1)\n  syl6bi(c1 ‚àà ùïå, c0 ‚àà(assIntOp ` c1), ((c0 :(c1 √ó c1)‚Üí c1)‚àß c0[assLaw]c1), c0 ‚àà { hs0 ‚àà(c1[‚Ü¶](c1 √ó c1))| hs0[assLaw]c1 })\n  eleq2d(c0, (assIntOp ` c1), { hs0 ‚àà(c1[‚Ü¶](c1 √ó c1))| hs0[assLaw]c1 }, c1 ‚àà ùïå)\n  assintopmap(hs0, c1, universe)\n  sylbi(c0 ‚àà { hs0 ‚àà(c1[‚Ü¶](c1 √ó c1))| hs0[assLaw]c1 }, ((c0 :(c1 √ó c1)‚Üí c1)‚àß c0[assLaw]c1), (c0 ‚àà(c1[‚Ü¶](c1 √ó c1))‚àß c0[assLaw]c1))\n  elrab(hs0, c0, (c1[‚Ü¶](c1 √ó c1)), hs0[assLaw]c1, c0[assLaw]c1)\n  breq1(hs0, c0, casslaw, c1)\n  anim1i(c0 ‚àà(c1[‚Ü¶](c1 √ó c1)), c0[assLaw]c1, (c0 :(c1 √ó c1)‚Üí c1))\n  elmapi(c0, c1, (c1 √ó c1))\n  diff.hs0.c(c1)\n  diff.hs0.c(c0)\n  diff.hs0.c((c1[‚Ü¶](c1 √ó c1)))\n  diff.hs0.w(c0[assLaw]c1)\n}","parent":["mpcom","elfvex","syl6bi","eleq2d","assintopmap","sylbi","elrab","breq1","anim1i","elmapi","diff.hs0.c","diff.hs0.w"],"children":["assintopasslaw"]},{"name":"isassintop","content":"The predicate \"is an associative (closed internal binary) operations for a set\". (Contributed by FL, 2-Nov-2009.) (Revised by AV, 20-Jan-2020.)","origin":"thm isassintop(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wb(wcel(c2, cfv(cassintop, c0)), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c2)\n  -| diffsc(s1, c0)\n  -| diffsc(s1, c2)\n  -| diffsc(s2, c0)\n  -| diffsc(s2, c2)\n} = {\n  impbid(wcel(c0, c1), wcel(c2, cfv(cassintop, c0)), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2)))))))))\n  sylbid(wcel(c0, c1), wcel(c2, cfv(cassintop, c0)), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2)))))))), wa(wcel(c2, co(c0, cmap, cxp(c0, c0))), wbr(c2, casslaw, c0)))\n  syl6bb(wcel(c0, c1), wcel(c2, cfv(cassintop, c0)), wa(wcel(c2, co(c0, cmap, cxp(c0, c0))), wbr(c2, casslaw, c0)), wcel(c2, crab(hs0, co(c0, cmap, cxp(c0, c0)), wbr(cv(hs0), casslaw, c0))))\n  eleq2d(c2, cfv(cassintop, c0), crab(hs0, co(c0, cmap, cxp(c0, c0)), wbr(cv(hs0), casslaw, c0)), wcel(c0, c1))\n  assintopmap(hs0, c0, c1)\n  elrab(hs0, c2, co(c0, cmap, cxp(c0, c0)), wbr(cv(hs0), casslaw, c0), wbr(c2, casslaw, c0))\n  ex(wcel(c0, c1), wa(wcel(c2, co(c0, cmap, cxp(c0, c0))), wbr(c2, casslaw, c0)), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2)))))))))\n  jca(wa(wcel(c0, c1), wa(wcel(c2, co(c0, cmap, cxp(c0, c0))), wbr(c2, casslaw, c0))), wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))\n  ad2antrl(wcel(c0, c1), wcel(c2, co(c0, cmap, cxp(c0, c0))), wbr(c2, casslaw, c0), wf(c2, cxp(c0, c0), c0))\n  elmapi(c2, c0, cxp(c0, c0))\n  impcom(wcel(c0, c1), wa(wcel(c2, co(c0, cmap, cxp(c0, c0))), wbr(c2, casslaw, c0)), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))\n  impancom(wcel(c2, co(c0, cmap, cxp(c0, c0))), wbr(c2, casslaw, c0), wcel(c0, c1), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))\n  biimpd(wa(wcel(c2, co(c0, cmap, cxp(c0, c0))), wcel(c0, c1)), wbr(c2, casslaw, c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))\n  isasslaw(s0, s1, s2, c2, co(c0, cmap, cxp(c0, c0)), c0, c1)\n  ex(wcel(c0, c1), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2)))))))), wcel(c2, cfv(cassintop, c0)))\n  mpbir2and(wa(wcel(c0, c1), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))), wcel(c2, cfv(cassintop, c0)), wcel(c2, cfv(cclintop, c0)), wbr(c2, casslaw, c0))\n  impcom(wcel(c0, c1), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2)))))))), wcel(c2, cfv(cclintop, c0)))\n  adantr(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))), wi(wcel(c0, c1), wcel(c2, cfv(cclintop, c0))))\n  biimprcd(wf(c2, cxp(c0, c0), c0), wcel(c0, c1), wcel(c2, cfv(cclintop, c0)))\n  isclintop(c0, c1, c2)\n  impr(wcel(c0, c1), wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))), wbr(c2, casslaw, c0))\n  biimpd(wa(wcel(c0, c1), wf(c2, cxp(c0, c0), c0)), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))), wbr(c2, casslaw, c0))\n  syl2anc(wa(wcel(c0, c1), wf(c2, cxp(c0, c0), c0)), wb(wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))), wbr(c2, casslaw, c0)), wcel(c2, universe), wcel(c0, c1))\n  ancoms(wcel(c0, c1), wf(c2, cxp(c0, c0), c0), wcel(c2, universe))\n  sylan2(wf(c2, cxp(c0, c0), c0), wcel(c0, c1), wcel(c2, universe), wcel(cxp(c0, c0), universe))\n  sqxpexg(c0, c1)\n  fex(c2, cxp(c0, c0), c0, universe)\n  simpl(wcel(c0, c1), wf(c2, cxp(c0, c0), c0))\n  bicomd(wa(wcel(c2, universe), wcel(c0, c1)), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))), wbr(c2, casslaw, c0))\n  isasslaw(s0, s1, s2, c2, universe, c0, c1)\n  syl6bb(wa(wcel(c0, c1), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))), wcel(c2, cfv(cassintop, c0)), wa(wcel(c2, cfv(cclintop, c0)), wbr(c2, casslaw, c0)), wcel(c2, crab(hs0, cfv(cclintop, c0), wbr(cv(hs0), casslaw, c0))))\n  eleq2d(c2, cfv(cassintop, c0), crab(hs0, cfv(cclintop, c0), wbr(cv(hs0), casslaw, c0)), wa(wcel(c0, c1), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2))))))))))\n  adantr(wcel(c0, c1), wa(wf(c2, cxp(c0, c0), c0), wral(s0, c0, wral(s1, c0, wral(s2, c0, wceq(co(co(cv(s0), c2, cv(s1)), c2, cv(s2)), co(cv(s0), c2, co(cv(s1), c2, cv(s2)))))))), wceq(cfv(cassintop, c0), crab(hs0, cfv(cclintop, c0), wbr(cv(hs0), casslaw, c0))))\n  assintopval(hs0, c0, c1)\n  elrab(hs0, c2, cfv(cclintop, c0), wbr(cv(hs0), casslaw, c0), wbr(c2, casslaw, c0))\n  breq1(cv(hs0), c2, casslaw, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c(c2)\n  diff.hs0.c(co(c0, cmap, cxp(c0, c0)))\n  diff.hs0.w(wbr(c2, casslaw, c0))\n  diff.hs0.c(cfv(cclintop, c0))\n}","pretty":"thm isassintop(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2) {\n  ‚ä¢ (c0 ‚àà c1 ‚Üí(c2 ‚àà(assIntOp ` c0)‚Üî((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))))\n  ‚ä£ d(s0, s1)\n  ‚ä£ d(s0, s2)\n  ‚ä£ d(s1, s2)\n  ‚ä£ d(s0, c0)\n  ‚ä£ d(s0, c2)\n  ‚ä£ d(s1, c0)\n  ‚ä£ d(s1, c2)\n  ‚ä£ d(s2, c0)\n  ‚ä£ d(s2, c2)\n} = {\n  impbid(c0 ‚àà c1, c2 ‚àà(assIntOp ` c0), ((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2)))))))\n  sylbid(c0 ‚àà c1, c2 ‚àà(assIntOp ` c0), ((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2)))))), (c2 ‚àà(c0[‚Ü¶](c0 √ó c0))‚àß c2[assLaw]c0))\n  syl6bb(c0 ‚àà c1, c2 ‚àà(assIntOp ` c0), (c2 ‚àà(c0[‚Ü¶](c0 √ó c0))‚àß c2[assLaw]c0), c2 ‚àà { hs0 ‚àà(c0[‚Ü¶](c0 √ó c0))| hs0[assLaw]c0 })\n  eleq2d(c2, (assIntOp ` c0), { hs0 ‚àà(c0[‚Ü¶](c0 √ó c0))| hs0[assLaw]c0 }, c0 ‚àà c1)\n  assintopmap(hs0, c0, c1)\n  elrab(hs0, c2, (c0[‚Ü¶](c0 √ó c0)), hs0[assLaw]c0, c2[assLaw]c0)\n  ex(c0 ‚àà c1, (c2 ‚àà(c0[‚Ü¶](c0 √ó c0))‚àß c2[assLaw]c0), ((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2)))))))\n  jca((c0 ‚àà c1 ‚àß(c2 ‚àà(c0[‚Ü¶](c0 √ó c0))‚àß c2[assLaw]c0)), (c2 :(c0 √ó c0)‚Üí c0), ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))\n  ad2antrl(c0 ‚àà c1, c2 ‚àà(c0[‚Ü¶](c0 √ó c0)), c2[assLaw]c0, (c2 :(c0 √ó c0)‚Üí c0))\n  elmapi(c2, c0, (c0 √ó c0))\n  impcom(c0 ‚àà c1, (c2 ‚àà(c0[‚Ü¶](c0 √ó c0))‚àß c2[assLaw]c0), ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))\n  impancom(c2 ‚àà(c0[‚Ü¶](c0 √ó c0)), c2[assLaw]c0, c0 ‚àà c1, ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))\n  biimpd((c2 ‚àà(c0[‚Ü¶](c0 √ó c0))‚àß c0 ‚àà c1), c2[assLaw]c0, ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))\n  isasslaw(s0, s1, s2, c2, (c0[‚Ü¶](c0 √ó c0)), c0, c1)\n  ex(c0 ‚àà c1, ((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2)))))), c2 ‚àà(assIntOp ` c0))\n  mpbir2and((c0 ‚àà c1 ‚àß((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))), c2 ‚àà(assIntOp ` c0), c2 ‚àà(clIntOp ` c0), c2[assLaw]c0)\n  impcom(c0 ‚àà c1, ((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2)))))), c2 ‚àà(clIntOp ` c0))\n  adantr((c2 :(c0 √ó c0)‚Üí c0), ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))), (c0 ‚àà c1 ‚Üí c2 ‚àà(clIntOp ` c0)))\n  biimprcd((c2 :(c0 √ó c0)‚Üí c0), c0 ‚àà c1, c2 ‚àà(clIntOp ` c0))\n  isclintop(c0, c1, c2)\n  impr(c0 ‚àà c1, (c2 :(c0 √ó c0)‚Üí c0), ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))), c2[assLaw]c0)\n  biimpd((c0 ‚àà c1 ‚àß(c2 :(c0 √ó c0)‚Üí c0)), ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))), c2[assLaw]c0)\n  syl2anc((c0 ‚àà c1 ‚àß(c2 :(c0 √ó c0)‚Üí c0)), (‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2)))))‚Üî c2[assLaw]c0), c2 ‚àà ùïå, c0 ‚àà c1)\n  ancoms(c0 ‚àà c1, (c2 :(c0 √ó c0)‚Üí c0), c2 ‚àà ùïå)\n  sylan2((c2 :(c0 √ó c0)‚Üí c0), c0 ‚àà c1, c2 ‚àà ùïå, (c0 √ó c0)‚àà ùïå)\n  sqxpexg(c0, c1)\n  fex(c2, (c0 √ó c0), c0, universe)\n  simpl(c0 ‚àà c1, (c2 :(c0 √ó c0)‚Üí c0))\n  bicomd((c2 ‚àà ùïå ‚àß c0 ‚àà c1), ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))), c2[assLaw]c0)\n  isasslaw(s0, s1, s2, c2, universe, c0, c1)\n  syl6bb((c0 ‚àà c1 ‚àß((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))), c2 ‚àà(assIntOp ` c0), (c2 ‚àà(clIntOp ` c0)‚àß c2[assLaw]c0), c2 ‚àà { hs0 ‚àà(clIntOp ` c0)| hs0[assLaw]c0 })\n  eleq2d(c2, (assIntOp ` c0), { hs0 ‚àà(clIntOp ` c0)| hs0[assLaw]c0 }, (c0 ‚àà c1 ‚àß((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2))))))))\n  adantr(c0 ‚àà c1, ((c2 :(c0 √ó c0)‚Üí c0)‚àß ‚àÄ(s0 ‚àà c0, ‚àÄ(s1 ‚àà c0, ‚àÄ(s2 ‚àà c0,((s0[c2]s1)[c2]s2)=(s0[c2](s1[c2]s2)))))), (assIntOp ` c0)= { hs0 ‚àà(clIntOp ` c0)| hs0[assLaw]c0 })\n  assintopval(hs0, c0, c1)\n  elrab(hs0, c2, (clIntOp ` c0), hs0[assLaw]c0, c2[assLaw]c0)\n  breq1(hs0, c2, casslaw, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c(c2)\n  diff.hs0.c((c0[‚Ü¶](c0 √ó c0)))\n  diff.hs0.w(c2[assLaw]c0)\n  diff.hs0.c((clIntOp ` c0))\n}","parent":["impbid","sylbid","syl6bb","eleq2d","assintopmap","elrab","ex","jca","ad2antrl","elmapi","impcom","impancom","biimpd","isasslaw","mpbir2and","adantr","biimprcd","isclintop","impr","syl2anc","ancoms","sylan2","sqxpexg","fex","simpl","bicomd","assintopval","breq1","diff.hs0.c","diff.hs0.w"],"children":[]},{"name":"clintopcllaw","content":"The closure law holds for a closed (internal binary) operation for a set. (Contributed by AV, 20-Jan-2020.)","origin":"thm clintopcllaw(class c0, class c1) {\n  |- wi(wcel(c0, cfv(cclintop, c1)), wbr(c0, ccllaw, c1))\n} = {\n  mpbird(wcel(c0, cfv(cclintop, c1)), wbr(c0, ccllaw, c1), wral(hs0, c1, wral(hs1, c1, wcel(co(cv(hs0), c0, cv(hs1)), c1))))\n  syl(wcel(c0, cfv(cclintop, c1)), wral(hs0, c1, wral(hs1, c1, wcel(co(cv(hs0), c0, cv(hs1)), c1))), wf(c0, cxp(c1, c1), c1))\n  clintop(c0, c1)\n  simprbi(wf(c0, cxp(c1, c1), c1), wral(hs0, c1, wral(hs1, c1, wcel(co(cv(hs0), c0, cv(hs1)), c1))), wfn(c0, cxp(c1, c1)))\n  ffnov(hs0, hs1, c0, c1, c1, c1)\n  mpdan(wcel(c0, cfv(cclintop, c1)), wb(wbr(c0, ccllaw, c1), wral(hs0, c1, wral(hs1, c1, wcel(co(cv(hs0), c0, cv(hs1)), c1)))), wcel(c1, universe))\n  elfvex(c0, cclintop, c1)\n  iscllaw(hs0, hs1, c0, cfv(cclintop, c1), c1, universe)\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c0)\n  diff.hs1.c(c1)\n}","pretty":"thm clintopcllaw(class c0, class c1) {\n  ‚ä¢ (c0 ‚àà(clIntOp ` c1)‚Üí c0[clLaw]c1)\n} = {\n  mpbird(c0 ‚àà(clIntOp ` c1), c0[clLaw]c1, ‚àÄ(hs0 ‚àà c1, ‚àÄ(hs1 ‚àà c1,(hs0[c0]hs1)‚àà c1)))\n  syl(c0 ‚àà(clIntOp ` c1), ‚àÄ(hs0 ‚àà c1, ‚àÄ(hs1 ‚àà c1,(hs0[c0]hs1)‚àà c1)), (c0 :(c1 √ó c1)‚Üí c1))\n  clintop(c0, c1)\n  simprbi((c0 :(c1 √ó c1)‚Üí c1), ‚àÄ(hs0 ‚àà c1, ‚àÄ(hs1 ‚àà c1,(hs0[c0]hs1)‚àà c1)), c0[Fn](c1 √ó c1))\n  ffnov(hs0, hs1, c0, c1, c1, c1)\n  mpdan(c0 ‚àà(clIntOp ` c1), (c0[clLaw]c1 ‚Üî ‚àÄ(hs0 ‚àà c1, ‚àÄ(hs1 ‚àà c1,(hs0[c0]hs1)‚àà c1))), c1 ‚àà ùïå)\n  elfvex(c0, cclintop, c1)\n  iscllaw(hs0, hs1, c0, (clIntOp ` c1), c1, universe)\n  diff.hs0.s(hs1)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c0)\n  diff.hs1.c(c1)\n}","parent":["mpbird","syl","clintop","simprbi","ffnov","mpdan","elfvex","iscllaw","diff.hs0.s","diff.hs0.c","diff.hs1.c"],"children":["assintopcllaw"]},{"name":"assintopcllaw","content":"The closure low holds for an associative (closed internal binary) operation for a set. (Contributed by FL, 2-Nov-2009.) (Revised by AV, 20-Jan-2020.)","origin":"thm assintopcllaw(class c0, class c1) {\n  |- wi(wcel(c0, cfv(cassintop, c1)), wbr(c0, ccllaw, c1))\n} = {\n  mpcom(wcel(c0, cfv(cassintop, c1)), wbr(c0, ccllaw, c1), wcel(c1, universe))\n  elfvex(c0, cassintop, c1)\n  syl6bi(wcel(c1, universe), wcel(c0, cfv(cassintop, c1)), wbr(c0, ccllaw, c1), wa(wcel(c0, cfv(cclintop, c1)), wbr(c0, casslaw, c1)))\n  syl6bb(wcel(c1, universe), wcel(c0, cfv(cassintop, c1)), wa(wcel(c0, cfv(cclintop, c1)), wbr(c0, casslaw, c1)), wcel(c0, crab(hs0, cfv(cclintop, c1), wbr(cv(hs0), casslaw, c1))))\n  eleq2d(c0, cfv(cassintop, c1), crab(hs0, cfv(cclintop, c1), wbr(cv(hs0), casslaw, c1)), wcel(c1, universe))\n  assintopval(hs0, c1, universe)\n  elrab(hs0, c0, cfv(cclintop, c1), wbr(cv(hs0), casslaw, c1), wbr(c0, casslaw, c1))\n  breq1(cv(hs0), c0, casslaw, c1)\n  adantr(wcel(c0, cfv(cclintop, c1)), wbr(c0, casslaw, c1), wbr(c0, ccllaw, c1))\n  clintopcllaw(c0, c1)\n  diff.hs0.c(c1)\n  diff.hs0.c(c0)\n  diff.hs0.c(cfv(cclintop, c1))\n  diff.hs0.w(wbr(c0, casslaw, c1))\n}","pretty":"thm assintopcllaw(class c0, class c1) {\n  ‚ä¢ (c0 ‚àà(assIntOp ` c1)‚Üí c0[clLaw]c1)\n} = {\n  mpcom(c0 ‚àà(assIntOp ` c1), c0[clLaw]c1, c1 ‚àà ùïå)\n  elfvex(c0, cassintop, c1)\n  syl6bi(c1 ‚àà ùïå, c0 ‚àà(assIntOp ` c1), c0[clLaw]c1, (c0 ‚àà(clIntOp ` c1)‚àß c0[assLaw]c1))\n  syl6bb(c1 ‚àà ùïå, c0 ‚àà(assIntOp ` c1), (c0 ‚àà(clIntOp ` c1)‚àß c0[assLaw]c1), c0 ‚àà { hs0 ‚àà(clIntOp ` c1)| hs0[assLaw]c1 })\n  eleq2d(c0, (assIntOp ` c1), { hs0 ‚àà(clIntOp ` c1)| hs0[assLaw]c1 }, c1 ‚àà ùïå)\n  assintopval(hs0, c1, universe)\n  elrab(hs0, c0, (clIntOp ` c1), hs0[assLaw]c1, c0[assLaw]c1)\n  breq1(hs0, c0, casslaw, c1)\n  adantr(c0 ‚àà(clIntOp ` c1), c0[assLaw]c1, c0[clLaw]c1)\n  clintopcllaw(c0, c1)\n  diff.hs0.c(c1)\n  diff.hs0.c(c0)\n  diff.hs0.c((clIntOp ` c1))\n  diff.hs0.w(c0[assLaw]c1)\n}","parent":["mpcom","elfvex","syl6bi","syl6bb","eleq2d","assintopval","elrab","breq1","adantr","clintopcllaw","diff.hs0.c","diff.hs0.w"],"children":[]},{"name":"assintopasslaw","content":"The associative low holds for a associative (closed internal binary) operation for a set. (Contributed by FL, 2-Nov-2009.) (Revised by AV, 20-Jan-2020.)","origin":"thm assintopasslaw(class c0, class c1) {\n  |- wi(wcel(c0, cfv(cassintop, c1)), wbr(c0, casslaw, c1))\n} = {\n  simprd(wcel(c0, cfv(cassintop, c1)), wbr(c0, casslaw, c1), wf(c0, cxp(c1, c1), c1))\n  assintop(c0, c1)\n}","pretty":"thm assintopasslaw(class c0, class c1) {\n  ‚ä¢ (c0 ‚àà(assIntOp ` c1)‚Üí c0[assLaw]c1)\n} = {\n  simprd(c0 ‚àà(assIntOp ` c1), c0[assLaw]c1, (c0 :(c1 √ó c1)‚Üí c1))\n  assintop(c0, c1)\n}","parent":["simprd","assintop"],"children":["assintopass"]},{"name":"assintopass","content":"An associative (closed internal binary) operation for a set is associative. (Contributed by FL, 2-Nov-2009.) (Revised by AV, 20-Jan-2020.)","origin":"thm assintopass(setvar s0, setvar s1, setvar s2, class c0, class c1) {\n  |- wi(wcel(c0, cfv(cassintop, c1)), wral(s0, c1, wral(s1, c1, wral(s2, c1, wceq(co(co(cv(s0), c0, cv(s1)), c0, cv(s2)), co(cv(s0), c0, co(cv(s1), c0, cv(s2))))))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s1, c0)\n  -| diffsc(s1, c1)\n  -| diffsc(s2, c0)\n  -| diffsc(s2, c1)\n} = {\n  mp2and(wcel(c0, cfv(cassintop, c1)), wral(s0, c1, wral(s1, c1, wral(s2, c1, wceq(co(co(cv(s0), c0, cv(s1)), c0, cv(s2)), co(cv(s0), c0, co(cv(s1), c0, cv(s2))))))), wcel(c0, cfv(cassintop, c1)), wcel(c1, universe))\n  id(wcel(c0, cfv(cassintop, c1)))\n  elfvex(c0, cassintop, c1)\n  syl5ibcom(wcel(c0, cfv(cassintop, c1)), wa(wcel(c0, cfv(cassintop, c1)), wcel(c1, universe)), wral(s0, c1, wral(s1, c1, wral(s2, c1, wceq(co(co(cv(s0), c0, cv(s1)), c0, cv(s2)), co(cv(s0), c0, co(cv(s1), c0, cv(s2))))))), wbr(c0, casslaw, c1))\n  assintopasslaw(c0, c1)\n  isasslaw(s0, s1, s2, c0, cfv(cassintop, c1), c1, universe)\n}","pretty":"thm assintopass(setvar s0, setvar s1, setvar s2, class c0, class c1) {\n  ‚ä¢ (c0 ‚àà(assIntOp ` c1)‚Üí ‚àÄ(s0 ‚àà c1, ‚àÄ(s1 ‚àà c1, ‚àÄ(s2 ‚àà c1,((s0[c0]s1)[c0]s2)=(s0[c0](s1[c0]s2))))))\n  ‚ä£ d(s0, s1)\n  ‚ä£ d(s0, s2)\n  ‚ä£ d(s1, s2)\n  ‚ä£ d(s0, c0)\n  ‚ä£ d(s0, c1)\n  ‚ä£ d(s1, c0)\n  ‚ä£ d(s1, c1)\n  ‚ä£ d(s2, c0)\n  ‚ä£ d(s2, c1)\n} = {\n  mp2and(c0 ‚àà(assIntOp ` c1), ‚àÄ(s0 ‚àà c1, ‚àÄ(s1 ‚àà c1, ‚àÄ(s2 ‚àà c1,((s0[c0]s1)[c0]s2)=(s0[c0](s1[c0]s2))))), c0 ‚àà(assIntOp ` c1), c1 ‚àà ùïå)\n  id(c0 ‚àà(assIntOp ` c1))\n  elfvex(c0, cassintop, c1)\n  syl5ibcom(c0 ‚àà(assIntOp ` c1), (c0 ‚àà(assIntOp ` c1)‚àß c1 ‚àà ùïå), ‚àÄ(s0 ‚àà c1, ‚àÄ(s1 ‚àà c1, ‚àÄ(s2 ‚àà c1,((s0[c0]s1)[c0]s2)=(s0[c0](s1[c0]s2))))), c0[assLaw]c1)\n  assintopasslaw(c0, c1)\n  isasslaw(s0, s1, s2, c0, (assIntOp ` c1), c1, universe)\n}","parent":["mp2and","id","elfvex","syl5ibcom","assintopasslaw","isasslaw"],"children":[]}]}