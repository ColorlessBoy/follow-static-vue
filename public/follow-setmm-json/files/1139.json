{"index":1139,"title":"Classes without extensionality","content":"A few results about classes can be proved without using ~ ax-ext . One could move all theorems from ~ cab to ~ df-clel (except for ~ dfcleq and ~ cvjust ) in a subsection \"Classes\" before the subsection on the axiom of extensionality, together with the theorems below. In that subsection, the last statement should be ~ df-cleq . Note that without ~ ax-ext , the $a-statements ~ df-clab , ~ df-cleq , and ~ df-clel are no longer eliminable (see previous section) (but PROBABLY are still conservative). This is not a reason not to study what is provable with them but without ~ ax-ext , in order to gauge their strengths more precisely. Before that subsection, a subsection \"The membership predicate\" could group the statements with ` e. ` that are currently in the FOL part (including ~ wcel , ~ wel , ~ ax-8 , ~ ax-9 ). Remark: the weakening of ~ eleq1 / ~ eleq2 to ~ eleq1w / ~ eleq2w can also be done with ~ eleq1i , ~ eqeltri , ~ eqeltrri , ~ eleq1a , ~ eleq1d , ~ eqeltrd , ~ eqeltrrd , ~ eqneltrd , ~ eqneltrrd , ~ nelneq . Remark: possibility to remove dependency on ~ ax-10 , ~ ax-11 , ~ ax-13 from ~ nfcri and theorems using it if one adds a disjoint variable condition (that theorem is typically used with dummy variables, so the disjoint variable condition addition is not very restrictive), and then shorten ~ nfnfc .","blocks":[{"name":"bj-cleljustab","content":"An instance of ~ df-clel where the LHS (the definiendum) has the form \"setvar ` e. ` class abstraction\". The straightforward yet important fact that this statement can be proved from FOL= and ~ df-clab (hence without ~ df-clel or ~ df-cleq ) was stressed by Mario Carneiro. The instance of ~ df-clel where the LHS has the form \"setvar ` e. ` setvar\" is proved as ~ cleljust , from FOL= and ~ ax-8 . (Contributed by BJ, 8-Nov-2021.) (Proof modification is discouraged.)","origin":"thm bj-cleljustab(setvar s0, setvar s1, setvar s2, wff w0) {\n  |- wb(wcel(cv(s0), cab(s1, w0)), wex(s2, wa(wceq(cv(s2), cv(s0)), wcel(cv(s2), cab(s1, w0)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsw(s2, w0)\n} = {\n  3bitri(wcel(cv(s0), cab(s1, w0)), wex(s2, wa(wceq(cv(s2), cv(s0)), wcel(cv(s2), cab(s1, w0)))), wsb(s0, s1, w0), wex(s2, wa(wceq(cv(s2), cv(s0)), wsb(s2, s1, w0))))\n  df-clab(s0, s1, w0)\n  3bitri(wsb(s0, s1, w0), wex(s2, wa(wceq(cv(s2), cv(s0)), wsb(s2, s1, w0))), wa(wex(s2, wceq(cv(s2), cv(s0))), wsb(s0, s1, w0)), wex(s2, wa(wceq(cv(s2), cv(s0)), wsb(s0, s1, w0))))\n  biantrur(wsb(s0, s1, w0), wex(s2, wceq(cv(s2), cv(s0))))\n  ax6ev(s2, s0)\n  bicomi(wa(wex(s2, wceq(cv(s2), cv(s0))), wsb(s0, s1, w0)), wex(s2, wa(wceq(cv(s2), cv(s0)), wsb(s0, s1, w0))))\n  19.41v(s2, wceq(cv(s2), cv(s0)), wsb(s0, s1, w0))\n  exbii(s2, wa(wceq(cv(s2), cv(s0)), wsb(s0, s1, w0)), wa(wceq(cv(s2), cv(s0)), wsb(s2, s1, w0)))\n  pm5.32i(wceq(cv(s2), cv(s0)), wsb(s0, s1, w0), wsb(s2, s1, w0))\n  equcoms(s2, s0, wb(wsb(s0, s1, w0), wsb(s2, s1, w0)))\n  sbequ(s0, s2, s1, w0)\n  exbii(s2, wa(wceq(cv(s2), cv(s0)), wsb(s2, s1, w0)), wa(wceq(cv(s2), cv(s0)), wcel(cv(s2), cab(s1, w0))))\n  anbi2i(wceq(cv(s2), cv(s0)), wsb(s2, s1, w0), wcel(cv(s2), cab(s1, w0)))\n  bicomi(wsb(s2, s1, w0), wcel(cv(s2), cab(s1, w0)))\n  df-clab(s2, s1, w0)\n  diff.wsb.s(s2, s0, s1, w0)\n  diffss.ex(s2, s0)\n  diffss.ex(s2, s1)\n}","pretty":"thm bj-cleljustab(setvar s0, setvar s1, setvar s2, wff w0) {\n  ⊢ (s0 ∈ { s1 | w0 } ↔ ∃(s2,(s2 = s0 ∧ s2 ∈ { s1 | w0 })))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s2, w0)\n} = {\n  3bitri(s0 ∈ { s1 | w0 }, ∃(s2,(s2 = s0 ∧ s2 ∈ { s1 | w0 })), [s0 / s1]w0, ∃(s2,(s2 = s0 ∧[s2 / s1]w0)))\n  df-clab(s0, s1, w0)\n  3bitri([s0 / s1]w0, ∃(s2,(s2 = s0 ∧[s2 / s1]w0)), (∃(s2, s2 = s0)∧[s0 / s1]w0), ∃(s2,(s2 = s0 ∧[s0 / s1]w0)))\n  biantrur([s0 / s1]w0, ∃(s2, s2 = s0))\n  ax6ev(s2, s0)\n  bicomi((∃(s2, s2 = s0)∧[s0 / s1]w0), ∃(s2,(s2 = s0 ∧[s0 / s1]w0)))\n  19.41v(s2, s2 = s0, [s0 / s1]w0)\n  exbii(s2, (s2 = s0 ∧[s0 / s1]w0), (s2 = s0 ∧[s2 / s1]w0))\n  pm5.32i(s2 = s0, [s0 / s1]w0, [s2 / s1]w0)\n  equcoms(s2, s0, ([s0 / s1]w0 ↔[s2 / s1]w0))\n  sbequ(s0, s2, s1, w0)\n  exbii(s2, (s2 = s0 ∧[s2 / s1]w0), (s2 = s0 ∧ s2 ∈ { s1 | w0 }))\n  anbi2i(s2 = s0, [s2 / s1]w0, s2 ∈ { s1 | w0 })\n  bicomi([s2 / s1]w0, s2 ∈ { s1 | w0 })\n  df-clab(s2, s1, w0)\n  diff.wsb.s(s2, s0, s1, w0)\n  diffss.ex(s2, s0)\n  diffss.ex(s2, s1)\n}","parent":["3bitri","df-clab","biantrur","ax6ev","bicomi","19.41v","exbii","pm5.32i","equcoms","sbequ","anbi2i","diff.wsb.s","diffss.ex"],"children":[]},{"name":"bj-vexwt","content":"Closed form of ~ bj-vexw . (Contributed by BJ, 14-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-vexwt(setvar s0, setvar s1, wff w0) {\n  |- wi(wal(s0, w0), wcel(cv(s1), cab(s0, w0)))\n} = {\n  sylibr(wal(s0, w0), wcel(cv(s1), cab(s0, w0)), wsb(s1, s0, w0))\n  stdpc4(s0, s1, w0)\n  df-clab(s1, s0, w0)\n}","pretty":"thm bj-vexwt(setvar s0, setvar s1, wff w0) {\n  ⊢ (∀(s0, w0)→ s1 ∈ { s0 | w0 })\n} = {\n  sylibr(∀(s0, w0), s1 ∈ { s0 | w0 }, [s1 / s0]w0)\n  stdpc4(s0, s1, w0)\n  df-clab(s1, s0, w0)\n}","parent":["sylibr","stdpc4","df-clab"],"children":["bj-vexw","bj-issetwt","bj-abv"]},{"name":"bj-vexw","content":"If ` ph ` is a theorem, then any set belongs to the class ` { x | ph } ` . Therefore, ` { x | ph } ` is \"a\" universal class. This is the closest one can get to defining a universal class, or proving ~ vex , without using ~ ax-ext . Note that this theorem has no disjoint variable condition and does not use ~ df-clel nor ~ df-cleq either: only first-order logic and ~ df-clab . Without ~ ax-ext , one cannot define \"the\" universal class, since one could not prove for instance the justification theorem ` { x | T. } = { y | T. } ` (see ~ vjust ). Indeed, in order to prove any equality of classes, one needs ~ df-cleq , which has ~ ax-ext as a hypothesis. Therefore, the classes ` { x | T. } ` , ` { y | ( ph -> ph ) } ` , ` { z | ( A. t t = t -> A. t t = t ) } ` and countless others are all universal classes whose equality one cannot prove without ~ ax-ext . See also ~ bj-issetw . Its degenerate instance is a simple consequence of ~ abid . (Contributed by BJ, 13-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-vexw(setvar s0, setvar s1, wff w0) {\n  |- wcel(cv(s0), cab(s1, w0))\n  -| w0\n} = {\n  mpg(s1, wcel(cv(s0), cab(s1, w0)), w0)\n  bj-vexwt(s1, s0, w0)\n}","pretty":"thm bj-vexw(setvar s0, setvar s1, wff w0) {\n  ⊢ s0 ∈ { s1 | w0 }\n  ⊣ w0\n} = {\n  mpg(s1, s0 ∈ { s1 | w0 }, w0)\n  bj-vexwt(s1, s0, w0)\n}","parent":["mpg","bj-vexwt"],"children":["bj-denotes","bj-ralvw","bj-rexvw","bj-rababw","bj-df-v"]},{"name":"bj-denotes","content":"This would be the justification theorem for the definition of the unary predicate \"E!\" by ` |- ( ` E! ` A <-> E. x x = A ) ` which could be interpreted as \" ` A ` exists\" or \" ` A ` denotes\". It is interesting that this justification theorem can be proved without ~ ax-ext nor ~ df-cleq (but then one requires ~ df-clab and ~ df-clel ). The next theorem ~ bj-issetwt will prove that \"existing\" (as a set) is equivalent to being a member of a class abstraction (that every class is equal to a class abstration is then proved by ~ abid1 / bj-termab , which requires more axioms, including ~ ax-ext and the three class related definitions). Note that there is no disjoint variable condition on ` x , y ` but the theorem does not depend on ~ ax-13 . Actually, the proof depends only on the logical axioms ~ ax-1 through ~ ax-7 and ~ sp . The symbol \"E!\" was chosen to be reminiscent of the analogous predicate in (inclusive or non-inclusive) free logic, which deals with the possibility of nonexistent objects. This analogy should not be taken too far, since here there are no equality axioms for classes: these are derived from ~ ax-ext and ~ df-cleq (e.g., ~ eqid and ~ eqeq1 ). In particular, one cannot even prove ` |- E. x x = A => |- A = A ` without ~ ax-ext and ~ df-cleq . See also ~ bj-denotesv and comments there. (Contributed by BJ, 29-Apr-2019.) (Proof modification is discouraged.)","origin":"thm bj-denotes(setvar s0, setvar s1, class c0) {\n  |- wb(wex(s0, wceq(cv(s0), c0)), wex(s1, wceq(cv(s1), c0)))\n  -| diffsc(s0, c0)\n  -| diffsc(s1, c0)\n} = {\n  bitri(wex(s0, wceq(cv(s0), c0)), wex(s1, wceq(cv(s1), c0)), wex(s1, wa(wceq(cv(s1), c0), wcel(cv(s1), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))))))\n  3bitr2i(wex(s0, wceq(cv(s0), c0)), wex(s1, wa(wceq(cv(s1), c0), wcel(cv(s1), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))))), wex(s0, wa(wceq(cv(s0), c0), wcel(cv(s0), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))))), wcel(c0, cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))))\n  exbii(s0, wceq(cv(s0), c0), wa(wceq(cv(s0), c0), wcel(cv(s0), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0)))))))\n  biantru(wceq(cv(s0), c0), wcel(cv(s0), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))))\n  bj-vexw(s0, hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))\n  df-clel(s0, c0, cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0)))))\n  df-clel(s1, c0, cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0)))))\n  exbii(s1, wa(wceq(cv(s1), c0), wcel(cv(s1), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0)))))), wceq(cv(s1), c0))\n  bicomi(wa(wceq(cv(s1), c0), wcel(cv(s1), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0)))))), wceq(cv(s1), c0))\n  biantru(wceq(cv(s1), c0), wcel(cv(s1), cab(hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))))\n  bj-vexw(s1, hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))\n  id(wceq(cv(hs0), cv(hs0)))\n  diff.cab.s(s0, hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))\n  diff.wi.s(s0, wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0)))\n  diff.wceq.s(s0, cv(hs0), cv(hs0))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.cab.s(s1, hs0, wi(wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0))))\n  diff.wi.s(s1, wceq(cv(hs0), cv(hs0)), wceq(cv(hs0), cv(hs0)))\n  diff.wceq.s(s1, cv(hs0), cv(hs0))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","pretty":"thm bj-denotes(setvar s0, setvar s1, class c0) {\n  ⊢ (∃(s0, s0 = c0)↔ ∃(s1, s1 = c0))\n  ⊣ d(s0, c0)\n  ⊣ d(s1, c0)\n} = {\n  bitri(∃(s0, s0 = c0), ∃(s1, s1 = c0), ∃(s1,(s1 = c0 ∧ s1 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)})))\n  3bitr2i(∃(s0, s0 = c0), ∃(s1,(s1 = c0 ∧ s1 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)})), ∃(s0,(s0 = c0 ∧ s0 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)})), c0 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)})\n  exbii(s0, s0 = c0, (s0 = c0 ∧ s0 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)}))\n  biantru(s0 = c0, s0 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)})\n  bj-vexw(s0, hs0, (hs0 = hs0 → hs0 = hs0))\n  df-clel(s0, c0, { hs0 |(hs0 = hs0 → hs0 = hs0)})\n  df-clel(s1, c0, { hs0 |(hs0 = hs0 → hs0 = hs0)})\n  exbii(s1, (s1 = c0 ∧ s1 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)}), s1 = c0)\n  bicomi((s1 = c0 ∧ s1 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)}), s1 = c0)\n  biantru(s1 = c0, s1 ∈ { hs0 |(hs0 = hs0 → hs0 = hs0)})\n  bj-vexw(s1, hs0, (hs0 = hs0 → hs0 = hs0))\n  id(hs0 = hs0)\n  diff.cab.s(s0, hs0, (hs0 = hs0 → hs0 = hs0))\n  diff.wi.s(s0, hs0 = hs0, hs0 = hs0)\n  diff.wceq.s(s0, hs0, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.cab.s(s1, hs0, (hs0 = hs0 → hs0 = hs0))\n  diff.wi.s(s1, hs0 = hs0, hs0 = hs0)\n  diff.wceq.s(s1, hs0, hs0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","parent":["bitri","3bitr2i","exbii","biantru","bj-vexw","df-clel","bicomi","id","diff.cab.s","diff.wi.s","diff.wceq.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":["bj-issetwt","bj-elisset","bj-vtoclg1f1"]},{"name":"bj-denotesv","content":"Version of ~ bj-denotes with the additional condition DV(x,y). With that additional disjoint variable condition, a short proof is possible, which depends only on ~ ax-1 through ~ ax-7 and ~ eqeq1 . The latter is an axiom in free logic but in our axiomatization its proof requires ~ ax-ext and ~ df-cleq (hence ~ ax-9 ). Compared to ~ bj-denotes , it does not require ~ ax-12 nor ~ df-clab nor ~ df-clel (nor ~ ax-8 ). (Contributed by BJ, 29-Apr-2019.) (Proof modification is discouraged.)","origin":"thm bj-denotesv(setvar s0, setvar s1, class c0) {\n  |- wb(wex(s0, wceq(cv(s0), c0)), wex(s1, wceq(cv(s1), c0)))\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsc(s1, c0)\n} = {\n  cbvexvw(s0, s1, wceq(cv(s0), c0), wceq(cv(s1), c0))\n  eqeq1(cv(s0), cv(s1), c0)\n  diff.wceq.s(s0, cv(s1), c0)\n  diff.cv.s(s0, s1)\n  diff.wceq.s(s1, cv(s0), c0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm bj-denotesv(setvar s0, setvar s1, class c0) {\n  ⊢ (∃(s0, s0 = c0)↔ ∃(s1, s1 = c0))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s1, c0)\n} = {\n  cbvexvw(s0, s1, s0 = c0, s1 = c0)\n  eqeq1(s0, s1, c0)\n  diff.wceq.s(s0, s1, c0)\n  diff.cv.s(s0, s1)\n  diff.wceq.s(s1, s0, c0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["cbvexvw","eqeq1","diff.wceq.s","diff.cv.s","diffss.ex"],"children":[]},{"name":"bj-issetwt","content":"Closed form of ~ bj-issetw . (Contributed by BJ, 29-Apr-2019.) (Proof modification is discouraged.)","origin":"thm bj-issetwt(setvar s0, setvar s1, class c0, wff w0) {\n  |- wi(wal(s0, w0), wb(wcel(c0, cab(s0, w0)), wex(s1, wceq(cv(s1), c0))))\n  -| diffsc(s1, c0)\n} = {\n  3bitrd(wal(s0, w0), wcel(c0, cab(s0, w0)), wex(s1, wceq(cv(s1), c0)), wex(hs0, wa(wceq(cv(hs0), c0), wcel(cv(hs0), cab(s0, w0)))), wex(hs0, wceq(cv(hs0), c0)))\n  a1i(wal(s0, w0), wb(wcel(c0, cab(s0, w0)), wex(hs0, wa(wceq(cv(hs0), c0), wcel(cv(hs0), cab(s0, w0))))))\n  df-clel(hs0, c0, cab(s0, w0))\n  exbidv(hs0, wal(s0, w0), wa(wceq(cv(hs0), c0), wcel(cv(hs0), cab(s0, w0))), wceq(cv(hs0), c0))\n  bicomd(wal(s0, w0), wa(wceq(cv(hs0), c0), wcel(cv(hs0), cab(s0, w0))), wceq(cv(hs0), c0))\n  biantrud(wal(s0, w0), wceq(cv(hs0), c0), wcel(cv(hs0), cab(s0, w0)))\n  bj-vexwt(s0, hs0, w0)\n  a1i(wal(s0, w0), wb(wex(hs0, wceq(cv(hs0), c0)), wex(s1, wceq(cv(s1), c0))))\n  bj-denotes(hs0, s1, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c(cab(s0, w0))\n  diff.hs0.w(wal(s0, w0))\n}","pretty":"thm bj-issetwt(setvar s0, setvar s1, class c0, wff w0) {\n  ⊢ (∀(s0, w0)→(c0 ∈ { s0 | w0 } ↔ ∃(s1, s1 = c0)))\n  ⊣ d(s1, c0)\n} = {\n  3bitrd(∀(s0, w0), c0 ∈ { s0 | w0 }, ∃(s1, s1 = c0), ∃(hs0,(hs0 = c0 ∧ hs0 ∈ { s0 | w0 })), ∃(hs0, hs0 = c0))\n  a1i(∀(s0, w0), (c0 ∈ { s0 | w0 } ↔ ∃(hs0,(hs0 = c0 ∧ hs0 ∈ { s0 | w0 }))))\n  df-clel(hs0, c0, { s0 | w0 })\n  exbidv(hs0, ∀(s0, w0), (hs0 = c0 ∧ hs0 ∈ { s0 | w0 }), hs0 = c0)\n  bicomd(∀(s0, w0), (hs0 = c0 ∧ hs0 ∈ { s0 | w0 }), hs0 = c0)\n  biantrud(∀(s0, w0), hs0 = c0, hs0 ∈ { s0 | w0 })\n  bj-vexwt(s0, hs0, w0)\n  a1i(∀(s0, w0), (∃(hs0, hs0 = c0)↔ ∃(s1, s1 = c0)))\n  bj-denotes(hs0, s1, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c({ s0 | w0 })\n  diff.hs0.w(∀(s0, w0))\n}","parent":["3bitrd","a1i","df-clel","exbidv","bicomd","biantrud","bj-vexwt","bj-denotes","diff.hs0.c","diff.hs0.w"],"children":["bj-issetw"]},{"name":"bj-issetw","content":"The closest one can get to ~ isset without using ~ ax-ext . See also ~ bj-vexw . Note that the only disjoint variable condition is between ` y ` and ` A ` . From there, one can prove ~ isset using ~ eleq2i (which requires ~ ax-ext and ~ df-cleq ). (Contributed by BJ, 29-Apr-2019.) (Proof modification is discouraged.)","origin":"thm bj-issetw(setvar s0, setvar s1, class c0, wff w0) {\n  |- wb(wcel(c0, cab(s0, w0)), wex(s1, wceq(cv(s1), c0)))\n  -| w0\n  -| diffsc(s1, c0)\n} = {\n  mpg(s0, wb(wcel(c0, cab(s0, w0)), wex(s1, wceq(cv(s1), c0))), w0)\n  bj-issetwt(s0, s1, c0, w0)\n}","pretty":"thm bj-issetw(setvar s0, setvar s1, class c0, wff w0) {\n  ⊢ (c0 ∈ { s0 | w0 } ↔ ∃(s1, s1 = c0))\n  ⊣ w0\n  ⊣ d(s1, c0)\n} = {\n  mpg(s0, (c0 ∈ { s0 | w0 } ↔ ∃(s1, s1 = c0)), w0)\n  bj-issetwt(s0, s1, c0, w0)\n}","parent":["mpg","bj-issetwt"],"children":[]},{"name":"bj-elissetv","content":"Version of ~ bj-elisset with a disjoint variable condition on ` x , V ` . This proof uses only ~ df-ex , ~ ax-gen , ~ ax-4 and ~ df-clel on top of propositional calculus. Prefer its use over ~ bj-elisset when sufficient. (Contributed by BJ, 14-Sep-2019.) (Proof modification is discouraged.)","origin":"thm bj-elissetv(setvar s0, class c0, class c1) {\n  |- wi(wcel(c0, c1), wex(s0, wceq(cv(s0), c0)))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n} = {\n  sylbi(wcel(c0, c1), wex(s0, wceq(cv(s0), c0)), wex(s0, wa(wceq(cv(s0), c0), wcel(cv(s0), c1))))\n  df-clel(s0, c0, c1)\n  exsimpl(s0, wceq(cv(s0), c0), wcel(cv(s0), c1))\n}","pretty":"thm bj-elissetv(setvar s0, class c0, class c1) {\n  ⊢ (c0 ∈ c1 → ∃(s0, s0 = c0))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n} = {\n  sylbi(c0 ∈ c1, ∃(s0, s0 = c0), ∃(s0,(s0 = c0 ∧ s0 ∈ c1)))\n  df-clel(s0, c0, c1)\n  exsimpl(s0, s0 = c0, s0 ∈ c1)\n}","parent":["sylbi","df-clel","exsimpl"],"children":["bj-elisset","bj-issetiv","bj-ceqsaltv","bj-ceqsalgv","bj-spcimdvv","bj-vtoclg1fv","bj-vtoclg","bj-ru"]},{"name":"bj-elisset","content":"Remove from ~ elisset dependency on ~ ax-ext (and on ~ df-cleq and ~ df-v ). This proof uses only ~ df-clab and ~ df-clel on top of first-order logic. It only requires ax-1--7 and ~ sp . Use ~ bj-elissetv instead when sufficient (in particular when ` V ` is substituted for ` _V ` ). (Contributed by BJ, 29-Apr-2019.) (Proof modification is discouraged.)","origin":"thm bj-elisset(setvar s0, class c0, class c1) {\n  |- wi(wcel(c0, c1), wex(s0, wceq(cv(s0), c0)))\n  -| diffsc(s0, c0)\n} = {\n  sylib(wcel(c0, c1), wex(s0, wceq(cv(s0), c0)), wex(hs0, wceq(cv(hs0), c0)))\n  bj-elissetv(hs0, c0, c1)\n  bj-denotes(hs0, s0, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n}","pretty":"thm bj-elisset(setvar s0, class c0, class c1) {\n  ⊢ (c0 ∈ c1 → ∃(s0, s0 = c0))\n  ⊣ d(s0, c0)\n} = {\n  sylib(c0 ∈ c1, ∃(s0, s0 = c0), ∃(hs0, hs0 = c0))\n  bj-elissetv(hs0, c0, c1)\n  bj-denotes(hs0, s0, c0)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n}","parent":["sylib","bj-elissetv","bj-denotes","diff.hs0.c"],"children":["bj-isseti","bj-ceqsalt","bj-ceqsalg","bj-spcimdv","bj-vtoclg1f"]},{"name":"bj-issetiv","content":"Version of ~ bj-isseti with a disjoint variable condition on ` x , V ` . This proof uses only ~ df-ex , ~ ax-gen , ~ ax-4 and ~ df-clel on top of propositional calculus. Prefer its use over ~ bj-isseti when sufficient (in particular when ` V ` is substituted for ` _V ` ). (Contributed by BJ, 14-Sep-2019.) (Proof modification is discouraged.)","origin":"thm bj-issetiv(setvar s0, class c0, class c1) {\n  |- wex(s0, wceq(cv(s0), c0))\n  -| wcel(c0, c1)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n} = {\n  ax-mp(wex(s0, wceq(cv(s0), c0)), wcel(c0, c1))\n  bj-elissetv(s0, c0, c1)\n}","pretty":"thm bj-issetiv(setvar s0, class c0, class c1) {\n  ⊢ ∃(s0, s0 = c0)\n  ⊣ c0 ∈ c1\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n} = {\n  ax-mp(∃(s0, s0 = c0), c0 ∈ c1)\n  bj-elissetv(s0, c0, c1)\n}","parent":["ax-mp","bj-elissetv"],"children":["bj-rexcom4bv","bj-vtoclf"]},{"name":"bj-isseti","content":"Remove from ~ isseti dependency on ~ ax-ext (and on ~ df-cleq and ~ df-v ). This proof uses only ~ df-clab and ~ df-clel on top of first-order logic. It only uses ~ ax-12 among the auxiliary logical axioms. The hypothesis uses ` V ` instead of ` _V ` for extra generality. This is indeed more general as long as ~ elex is not available. Use ~ bj-issetiv instead when sufficient (in particular when ` V ` is substituted for ` _V ` ). (Contributed by BJ, 13-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-isseti(setvar s0, class c0, class c1) {\n  |- wex(s0, wceq(cv(s0), c0))\n  -| wcel(c0, c1)\n  -| diffsc(s0, c0)\n} = {\n  ax-mp(wex(s0, wceq(cv(s0), c0)), wcel(c0, c1))\n  bj-elisset(s0, c0, c1)\n}","pretty":"thm bj-isseti(setvar s0, class c0, class c1) {\n  ⊢ ∃(s0, s0 = c0)\n  ⊣ c0 ∈ c1\n  ⊣ d(s0, c0)\n} = {\n  ax-mp(∃(s0, s0 = c0), c0 ∈ c1)\n  bj-elisset(s0, c0, c1)\n}","parent":["ax-mp","bj-elisset"],"children":["bj-rexcom4b"]},{"name":"bj-ralvw","content":"A weak version of ~ ralv not using ~ ax-ext (nor ~ df-cleq , ~ df-clel , ~ df-v ), and only core FOL axioms. See also ~ bj-rexvw . The analogues for ~ reuv and ~ rmov are not proved. (Contributed by BJ, 16-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-ralvw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wral(s0, cab(s1, w0), w1), wal(s0, w1))\n  -| w0\n} = {\n  bitr4i(wral(s0, cab(s1, w0), w1), wal(s0, w1), wal(s0, wi(wcel(cv(s0), cab(s1, w0)), w1)))\n  df-ral(s0, cab(s1, w0), w1)\n  albii(s0, w1, wi(wcel(cv(s0), cab(s1, w0)), w1))\n  a1bi(w1, wcel(cv(s0), cab(s1, w0)))\n  bj-vexw(s0, s1, w0)\n}","pretty":"thm bj-ralvw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∀(s0 ∈ { s1 | w0 }, w1)↔ ∀(s0, w1))\n  ⊣ w0\n} = {\n  bitr4i(∀(s0 ∈ { s1 | w0 }, w1), ∀(s0, w1), ∀(s0,(s0 ∈ { s1 | w0 } → w1)))\n  df-ral(s0, { s1 | w0 }, w1)\n  albii(s0, w1, (s0 ∈ { s1 | w0 } → w1))\n  a1bi(w1, s0 ∈ { s1 | w0 })\n  bj-vexw(s0, s1, w0)\n}","parent":["bitr4i","df-ral","albii","a1bi","bj-vexw"],"children":[]},{"name":"bj-rexvw","content":"A weak version of ~ rexv not using ~ ax-ext (nor ~ df-cleq , ~ df-clel , ~ df-v ), and only core FOL axioms. See also ~ bj-ralvw . (Contributed by BJ, 16-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-rexvw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(wrex(s0, cab(s1, w0), w1), wex(s0, w1))\n  -| w0\n} = {\n  bitr4i(wrex(s0, cab(s1, w0), w1), wex(s0, w1), wex(s0, wa(wcel(cv(s0), cab(s1, w0)), w1)))\n  df-rex(s0, cab(s1, w0), w1)\n  exbii(s0, w1, wa(wcel(cv(s0), cab(s1, w0)), w1))\n  biantrur(w1, wcel(cv(s0), cab(s1, w0)))\n  bj-vexw(s0, s1, w0)\n}","pretty":"thm bj-rexvw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (∃(s0 ∈ { s1 | w0 }, w1)↔ ∃(s0, w1))\n  ⊣ w0\n} = {\n  bitr4i(∃(s0 ∈ { s1 | w0 }, w1), ∃(s0, w1), ∃(s0,(s0 ∈ { s1 | w0 } ∧ w1)))\n  df-rex(s0, { s1 | w0 }, w1)\n  exbii(s0, w1, (s0 ∈ { s1 | w0 } ∧ w1))\n  biantrur(w1, s0 ∈ { s1 | w0 })\n  bj-vexw(s0, s1, w0)\n}","parent":["bitr4i","df-rex","exbii","biantrur","bj-vexw"],"children":[]},{"name":"bj-rababw","content":"A weak version of ~ rabab not using ~ df-clel nor ~ df-v (but requiring ~ ax-ext ) nor ~ ax-12 . (Contributed by BJ, 16-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-rababw(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wceq(crab(s0, cab(s1, w0), w1), cab(s0, w1))\n  -| w0\n} = {\n  eqtr4i(crab(s0, cab(s1, w0), w1), cab(s0, w1), cab(s0, wa(wcel(cv(s0), cab(s1, w0)), w1)))\n  df-rab(s0, cab(s1, w0), w1)\n  abbii(s0, w1, wa(wcel(cv(s0), cab(s1, w0)), w1))\n  biantrur(w1, wcel(cv(s0), cab(s1, w0)))\n  bj-vexw(s0, s1, w0)\n}","pretty":"thm bj-rababw(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ { s0 ∈ { s1 | w0 } | w1 } = { s0 | w1 }\n  ⊣ w0\n} = {\n  eqtr4i({ s0 ∈ { s1 | w0 } | w1 }, { s0 | w1 }, { s0 |(s0 ∈ { s1 | w0 } ∧ w1)})\n  df-rab(s0, { s1 | w0 }, w1)\n  abbii(s0, w1, (s0 ∈ { s1 | w0 } ∧ w1))\n  biantrur(w1, s0 ∈ { s1 | w0 })\n  bj-vexw(s0, s1, w0)\n}","parent":["eqtr4i","df-rab","abbii","biantrur","bj-vexw"],"children":[]},{"name":"bj-ralcom4","content":"Remove from ~ ralcom4 dependency on ~ ax-ext and ~ ax-13 (and on ~ df-or , ~ df-an , ~ df-tru , ~ df-sb , ~ df-clab , ~ df-cleq , ~ df-clel , ~ df-nfc , ~ df-v ). This proof uses only ~ df-ral on top of first-order logic. (Contributed by BJ, 13-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-ralcom4(setvar s0, setvar s1, class c0, wff w0) {\n  |- wb(wral(s0, c0, wal(s1, w0)), wal(s1, wral(s0, c0, w0)))\n  -| diffss(s0, s1)\n  -| diffsc(s1, c0)\n} = {\n  3bitr4i(wral(s0, c0, wal(s1, w0)), wal(s1, wral(s0, c0, w0)), wal(s0, wi(wcel(cv(s0), c0), wal(s1, w0))), wal(s1, wal(s0, wi(wcel(cv(s0), c0), w0))))\n  bitri(wal(s0, wi(wcel(cv(s0), c0), wal(s1, w0))), wal(s1, wal(s0, wi(wcel(cv(s0), c0), w0))), wal(s0, wal(s1, wi(wcel(cv(s0), c0), w0))))\n  albii(s0, wi(wcel(cv(s0), c0), wal(s1, w0)), wal(s1, wi(wcel(cv(s0), c0), w0)))\n  bicomi(wi(wcel(cv(s0), c0), wal(s1, w0)), wal(s1, wi(wcel(cv(s0), c0), w0)))\n  19.21v(s1, wcel(cv(s0), c0), w0)\n  alcom(s0, s1, wi(wcel(cv(s0), c0), w0))\n  df-ral(s0, c0, wal(s1, w0))\n  albii(s1, wral(s0, c0, w0), wal(s0, wi(wcel(cv(s0), c0), w0)))\n  df-ral(s0, c0, w0)\n  diff.wcel.s(s1, cv(s0), c0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm bj-ralcom4(setvar s0, setvar s1, class c0, wff w0) {\n  ⊢ (∀(s0 ∈ c0, ∀(s1, w0))↔ ∀(s1, ∀(s0 ∈ c0, w0)))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, c0)\n} = {\n  3bitr4i(∀(s0 ∈ c0, ∀(s1, w0)), ∀(s1, ∀(s0 ∈ c0, w0)), ∀(s0,(s0 ∈ c0 → ∀(s1, w0))), ∀(s1, ∀(s0,(s0 ∈ c0 → w0))))\n  bitri(∀(s0,(s0 ∈ c0 → ∀(s1, w0))), ∀(s1, ∀(s0,(s0 ∈ c0 → w0))), ∀(s0, ∀(s1,(s0 ∈ c0 → w0))))\n  albii(s0, (s0 ∈ c0 → ∀(s1, w0)), ∀(s1,(s0 ∈ c0 → w0)))\n  bicomi((s0 ∈ c0 → ∀(s1, w0)), ∀(s1,(s0 ∈ c0 → w0)))\n  19.21v(s1, s0 ∈ c0, w0)\n  alcom(s0, s1, (s0 ∈ c0 → w0))\n  df-ral(s0, c0, ∀(s1, w0))\n  albii(s1, ∀(s0 ∈ c0, w0), ∀(s0,(s0 ∈ c0 → w0)))\n  df-ral(s0, c0, w0)\n  diff.wcel.s(s1, s0, c0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["3bitr4i","bitri","albii","bicomi","19.21v","alcom","df-ral","diff.wcel.s","diff.cv.s","diffss.ex"],"children":[]},{"name":"bj-rexcom4","content":"Remove from ~ rexcom4 dependency on ~ ax-ext and ~ ax-13 (and on ~ df-or , ~ df-tru , ~ df-sb , ~ df-clab , ~ df-cleq , ~ df-clel , ~ df-nfc , ~ df-v ). This proof uses only ~ df-rex on top of first-order logic. (Contributed by BJ, 13-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-rexcom4(setvar s0, setvar s1, class c0, wff w0) {\n  |- wb(wrex(s0, c0, wex(s1, w0)), wex(s1, wrex(s0, c0, w0)))\n  -| diffss(s0, s1)\n  -| diffsc(s1, c0)\n} = {\n  bitri(wrex(s0, c0, wex(s1, w0)), wex(s1, wrex(s0, c0, w0)), wex(s0, wa(wcel(cv(s0), c0), wex(s1, w0))))\n  df-rex(s0, c0, wex(s1, w0))\n  bitri(wex(s0, wa(wcel(cv(s0), c0), wex(s1, w0))), wex(s1, wrex(s0, c0, w0)), wex(s0, wex(s1, wa(wcel(cv(s0), c0), w0))))\n  exbii(s0, wa(wcel(cv(s0), c0), wex(s1, w0)), wex(s1, wa(wcel(cv(s0), c0), w0)))\n  bicomi(wa(wcel(cv(s0), c0), wex(s1, w0)), wex(s1, wa(wcel(cv(s0), c0), w0)))\n  19.42v(s1, wcel(cv(s0), c0), w0)\n  bitri(wex(s0, wex(s1, wa(wcel(cv(s0), c0), w0))), wex(s1, wrex(s0, c0, w0)), wex(s1, wex(s0, wa(wcel(cv(s0), c0), w0))))\n  excom(s0, s1, wa(wcel(cv(s0), c0), w0))\n  exbii(s1, wex(s0, wa(wcel(cv(s0), c0), w0)), wrex(s0, c0, w0))\n  bicomi(wex(s0, wa(wcel(cv(s0), c0), w0)), wrex(s0, c0, w0))\n  df-rex(s0, c0, w0)\n  diff.wcel.s(s1, cv(s0), c0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","pretty":"thm bj-rexcom4(setvar s0, setvar s1, class c0, wff w0) {\n  ⊢ (∃(s0 ∈ c0, ∃(s1, w0))↔ ∃(s1, ∃(s0 ∈ c0, w0)))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, c0)\n} = {\n  bitri(∃(s0 ∈ c0, ∃(s1, w0)), ∃(s1, ∃(s0 ∈ c0, w0)), ∃(s0,(s0 ∈ c0 ∧ ∃(s1, w0))))\n  df-rex(s0, c0, ∃(s1, w0))\n  bitri(∃(s0,(s0 ∈ c0 ∧ ∃(s1, w0))), ∃(s1, ∃(s0 ∈ c0, w0)), ∃(s0, ∃(s1,(s0 ∈ c0 ∧ w0))))\n  exbii(s0, (s0 ∈ c0 ∧ ∃(s1, w0)), ∃(s1,(s0 ∈ c0 ∧ w0)))\n  bicomi((s0 ∈ c0 ∧ ∃(s1, w0)), ∃(s1,(s0 ∈ c0 ∧ w0)))\n  19.42v(s1, s0 ∈ c0, w0)\n  bitri(∃(s0, ∃(s1,(s0 ∈ c0 ∧ w0))), ∃(s1, ∃(s0 ∈ c0, w0)), ∃(s1, ∃(s0,(s0 ∈ c0 ∧ w0))))\n  excom(s0, s1, (s0 ∈ c0 ∧ w0))\n  exbii(s1, ∃(s0,(s0 ∈ c0 ∧ w0)), ∃(s0 ∈ c0, w0))\n  bicomi(∃(s0,(s0 ∈ c0 ∧ w0)), ∃(s0 ∈ c0, w0))\n  df-rex(s0, c0, w0)\n  diff.wcel.s(s1, s0, c0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n}","parent":["bitri","df-rex","exbii","bicomi","19.42v","excom","diff.wcel.s","diff.cv.s","diffss.ex"],"children":["bj-rexcom4a"]},{"name":"bj-rexcom4a","content":"Remove from ~ rexcom4a dependency on ~ ax-ext and ~ ax-13 (and on ~ df-or , ~ df-sb , ~ df-clab , ~ df-cleq , ~ df-clel , ~ df-nfc , ~ df-v ). This proof uses only ~ df-rex on top of first-order logic. (Contributed by BJ, 16-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-rexcom4a(setvar s0, setvar s1, class c0, wff w0, wff w1) {\n  |- wb(wex(s0, wrex(s1, c0, wa(w0, w1))), wrex(s1, c0, wa(w0, wex(s0, w1))))\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsw(s0, w0)\n} = {\n  bitr3i(wex(s0, wrex(s1, c0, wa(w0, w1))), wrex(s1, c0, wa(w0, wex(s0, w1))), wrex(s1, c0, wex(s0, wa(w0, w1))))\n  bj-rexcom4(s1, s0, c0, wa(w0, w1))\n  rexbii(s1, c0, wex(s0, wa(w0, w1)), wa(w0, wex(s0, w1)))\n  19.42v(s0, w0, w1)\n  diffss.ex(s1, s0)\n}","pretty":"thm bj-rexcom4a(setvar s0, setvar s1, class c0, wff w0, wff w1) {\n  ⊢ (∃(s0, ∃(s1 ∈ c0,(w0 ∧ w1)))↔ ∃(s1 ∈ c0,(w0 ∧ ∃(s0, w1))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, w0)\n} = {\n  bitr3i(∃(s0, ∃(s1 ∈ c0,(w0 ∧ w1))), ∃(s1 ∈ c0,(w0 ∧ ∃(s0, w1))), ∃(s1 ∈ c0, ∃(s0,(w0 ∧ w1))))\n  bj-rexcom4(s1, s0, c0, (w0 ∧ w1))\n  rexbii(s1, c0, ∃(s0,(w0 ∧ w1)), (w0 ∧ ∃(s0, w1)))\n  19.42v(s0, w0, w1)\n  diffss.ex(s1, s0)\n}","parent":["bitr3i","bj-rexcom4","rexbii","19.42v","diffss.ex"],"children":["bj-rexcom4bv","bj-rexcom4b"]},{"name":"bj-rexcom4bv","content":"Version of ~ bj-rexcom4b with a disjoint variable condition on ` x , V ` , hence removing dependency on ~ df-sb and ~ df-clab (so that it depends on ~ df-clel and ~ df-rex only on top of first-order logic). Prefer its use over ~ bj-rexcom4b when sufficient (in particular when ` V ` is substituted for ` _V ` ). (Contributed by BJ, 14-Sep-2019.) (Proof modification is discouraged.)","origin":"thm bj-rexcom4bv(setvar s0, setvar s1, class c0, class c1, class c2, wff w0) {\n  |- wb(wex(s0, wrex(s1, c0, wa(w0, wceq(cv(s0), c1)))), wrex(s1, c0, w0))\n  -| wcel(c1, c2)\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n  -| diffsw(s0, w0)\n} = {\n  bitr4i(wex(s0, wrex(s1, c0, wa(w0, wceq(cv(s0), c1)))), wrex(s1, c0, w0), wrex(s1, c0, wa(w0, wex(s0, wceq(cv(s0), c1)))))\n  bj-rexcom4a(s0, s1, c0, w0, wceq(cv(s0), c1))\n  rexbii(s1, c0, w0, wa(w0, wex(s0, wceq(cv(s0), c1))))\n  biantru(w0, wex(s0, wceq(cv(s0), c1)))\n  bj-issetiv(s0, c1, c2)\n}","pretty":"thm bj-rexcom4bv(setvar s0, setvar s1, class c0, class c1, class c2, wff w0) {\n  ⊢ (∃(s0, ∃(s1 ∈ c0,(w0 ∧ s0 = c1)))↔ ∃(s1 ∈ c0, w0))\n  ⊣ c1 ∈ c2\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c2)\n  ⊣ d(s0, w0)\n} = {\n  bitr4i(∃(s0, ∃(s1 ∈ c0,(w0 ∧ s0 = c1))), ∃(s1 ∈ c0, w0), ∃(s1 ∈ c0,(w0 ∧ ∃(s0, s0 = c1))))\n  bj-rexcom4a(s0, s1, c0, w0, s0 = c1)\n  rexbii(s1, c0, w0, (w0 ∧ ∃(s0, s0 = c1)))\n  biantru(w0, ∃(s0, s0 = c1))\n  bj-issetiv(s0, c1, c2)\n}","parent":["bitr4i","bj-rexcom4a","rexbii","biantru","bj-issetiv"],"children":[]},{"name":"bj-rexcom4b","content":"Remove from ~ rexcom4b dependency on ~ ax-ext and ~ ax-13 (and on ~ df-or , ~ df-cleq , ~ df-nfc , ~ df-v ). The hypothesis uses ` V ` instead of ` _V ` (see ~ bj-isseti for the motivation). Use ~ bj-rexcom4bv instead when sufficient (in particular when ` V ` is substituted for ` _V ` ). (Contributed by BJ, 16-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-rexcom4b(setvar s0, setvar s1, class c0, class c1, class c2, wff w0) {\n  |- wb(wex(s0, wrex(s1, c0, wa(w0, wceq(cv(s0), c1)))), wrex(s1, c0, w0))\n  -| wcel(c1, c2)\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsw(s0, w0)\n} = {\n  bitr4i(wex(s0, wrex(s1, c0, wa(w0, wceq(cv(s0), c1)))), wrex(s1, c0, w0), wrex(s1, c0, wa(w0, wex(s0, wceq(cv(s0), c1)))))\n  bj-rexcom4a(s0, s1, c0, w0, wceq(cv(s0), c1))\n  rexbii(s1, c0, w0, wa(w0, wex(s0, wceq(cv(s0), c1))))\n  biantru(w0, wex(s0, wceq(cv(s0), c1)))\n  bj-isseti(s0, c1, c2)\n}","pretty":"thm bj-rexcom4b(setvar s0, setvar s1, class c0, class c1, class c2, wff w0) {\n  ⊢ (∃(s0, ∃(s1 ∈ c0,(w0 ∧ s0 = c1)))↔ ∃(s1 ∈ c0, w0))\n  ⊣ c1 ∈ c2\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, w0)\n} = {\n  bitr4i(∃(s0, ∃(s1 ∈ c0,(w0 ∧ s0 = c1))), ∃(s1 ∈ c0, w0), ∃(s1 ∈ c0,(w0 ∧ ∃(s0, s0 = c1))))\n  bj-rexcom4a(s0, s1, c0, w0, s0 = c1)\n  rexbii(s1, c0, w0, (w0 ∧ ∃(s0, s0 = c1)))\n  biantru(w0, ∃(s0, s0 = c1))\n  bj-isseti(s0, c1, c2)\n}","parent":["bitr4i","bj-rexcom4a","rexbii","biantru","bj-isseti"],"children":[]},{"name":"bj-ceqsalt0","content":"The FOL content of ~ ceqsalt . Lemma for ~ bj-ceqsalt and ~ bj-ceqsaltv . (Contributed by BJ, 26-Sep-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsalt0(setvar s0, wff w0, wff w1, wff w2) {\n  |- wi(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1)), wb(wal(s0, wi(w1, w2)), w0))\n} = {\n  impbid(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1)), wal(s0, wi(w1, w2)), w0)\n  mpid(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1)), wal(s0, wi(w1, w2)), w0, wex(s0, w1))\n  simp3(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1))\n  sylibd(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1)), wal(s0, wi(w1, w2)), wi(wex(s0, w1), w0), wal(s0, wi(w1, w0)))\n  3ad2ant2(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1), wi(wal(s0, wi(w1, w2)), wal(s0, wi(w1, w0))))\n  al2imi(s0, wi(w1, wb(w2, w0)), wi(w1, w2), wi(w1, w0))\n  imim3i(w1, wb(w2, w0), w2, w0)\n  biimp(w2, w0)\n  3ad2ant1(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1), wb(wal(s0, wi(w1, w0)), wi(wex(s0, w1), w0)))\n  19.23t(s0, w0, w1)\n  mpbid(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1)), wi(w0, wal(s0, wi(w1, w2))), wal(s0, wi(w0, wi(w1, w2))))\n  3ad2ant2(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1), wal(s0, wi(w0, wi(w1, w2))))\n  alimi(s0, wi(w1, wb(w2, w0)), wi(w0, wi(w1, w2)))\n  com23(wi(w1, wb(w2, w0)), w0, w1, w2)\n  imim2i(w1, wb(w2, w0), wi(w0, w2))\n  biimpr(w2, w0)\n  3ad2ant1(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), wex(s0, w1), wb(wal(s0, wi(w0, wi(w1, w2))), wi(w0, wal(s0, wi(w1, w2)))))\n  19.21t(s0, w0, wi(w1, w2))\n}","pretty":"thm bj-ceqsalt0(setvar s0, wff w0, wff w1, wff w2) {\n  ⊢ ((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ ∃(s0, w1))→(∀(s0,(w1 → w2))↔ w0))\n} = {\n  impbid((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ ∃(s0, w1)), ∀(s0,(w1 → w2)), w0)\n  mpid((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ ∃(s0, w1)), ∀(s0,(w1 → w2)), w0, ∃(s0, w1))\n  simp3(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), ∃(s0, w1))\n  sylibd((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ ∃(s0, w1)), ∀(s0,(w1 → w2)), (∃(s0, w1)→ w0), ∀(s0,(w1 → w0)))\n  3ad2ant2(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), ∃(s0, w1), (∀(s0,(w1 → w2))→ ∀(s0,(w1 → w0))))\n  al2imi(s0, (w1 →(w2 ↔ w0)), (w1 → w2), (w1 → w0))\n  imim3i(w1, (w2 ↔ w0), w2, w0)\n  biimp(w2, w0)\n  3ad2ant1(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), ∃(s0, w1), (∀(s0,(w1 → w0))↔(∃(s0, w1)→ w0)))\n  19.23t(s0, w0, w1)\n  mpbid((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ ∃(s0, w1)), (w0 → ∀(s0,(w1 → w2))), ∀(s0,(w0 →(w1 → w2))))\n  3ad2ant2(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), ∃(s0, w1), ∀(s0,(w0 →(w1 → w2))))\n  alimi(s0, (w1 →(w2 ↔ w0)), (w0 →(w1 → w2)))\n  com23((w1 →(w2 ↔ w0)), w0, w1, w2)\n  imim2i(w1, (w2 ↔ w0), (w0 → w2))\n  biimpr(w2, w0)\n  3ad2ant1(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), ∃(s0, w1), (∀(s0,(w0 →(w1 → w2)))↔(w0 → ∀(s0,(w1 → w2)))))\n  19.21t(s0, w0, (w1 → w2))\n}","parent":["impbid","mpid","simp3","sylibd","3ad2ant2","al2imi","imim3i","biimp","3ad2ant1","19.23t","mpbid","alimi","com23","imim2i","biimpr","19.21t"],"children":["bj-ceqsalt","bj-ceqsaltv","bj-ceqsalg0"]},{"name":"bj-ceqsalt1","content":"The FOL content of ~ ceqsalt . Lemma for ~ bj-ceqsalt and ~ bj-ceqsaltv . (TODO: consider removing if it does not add anything to ~ bj-ceqsalt0 .) (Contributed by BJ, 26-Sep-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsalt1(setvar s0, wff w0, wff w1, wff w2, wff w3) {\n  |- wi(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3), wb(wal(s0, wi(w1, w2)), w0))\n  -| wi(w3, wex(s0, w1))\n} = {\n  impbid(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3), wal(s0, wi(w1, w2)), w0)\n  mpid(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3), wal(s0, wi(w1, w2)), w0, wex(s0, w1))\n  3ad2ant3(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3, wex(s0, w1))\n  sylibd(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3), wal(s0, wi(w1, w2)), wi(wex(s0, w1), w0), wal(s0, wi(w1, w0)))\n  3ad2ant2(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3, wi(wal(s0, wi(w1, w2)), wal(s0, wi(w1, w0))))\n  al2imi(s0, wi(w1, wb(w2, w0)), wi(w1, w2), wi(w1, w0))\n  imim3i(w1, wb(w2, w0), w2, w0)\n  biimp(w2, w0)\n  3ad2ant1(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3, wb(wal(s0, wi(w1, w0)), wi(wex(s0, w1), w0)))\n  19.23t(s0, w0, w1)\n  mpbid(w3a(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3), wi(w0, wal(s0, wi(w1, w2))), wal(s0, wi(w0, wi(w1, w2))))\n  3ad2ant2(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3, wal(s0, wi(w0, wi(w1, w2))))\n  alimi(s0, wi(w1, wb(w2, w0)), wi(w0, wi(w1, w2)))\n  com23(wi(w1, wb(w2, w0)), w0, w1, w2)\n  imim2i(w1, wb(w2, w0), wi(w0, w2))\n  biimpr(w2, w0)\n  3ad2ant1(wnf(s0, w0), wal(s0, wi(w1, wb(w2, w0))), w3, wb(wal(s0, wi(w0, wi(w1, w2))), wi(w0, wal(s0, wi(w1, w2)))))\n  19.21t(s0, w0, wi(w1, w2))\n}","pretty":"thm bj-ceqsalt1(setvar s0, wff w0, wff w1, wff w2, wff w3) {\n  ⊢ ((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ w3)→(∀(s0,(w1 → w2))↔ w0))\n  ⊣ (w3 → ∃(s0, w1))\n} = {\n  impbid((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ w3), ∀(s0,(w1 → w2)), w0)\n  mpid((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ w3), ∀(s0,(w1 → w2)), w0, ∃(s0, w1))\n  3ad2ant3(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), w3, ∃(s0, w1))\n  sylibd((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ w3), ∀(s0,(w1 → w2)), (∃(s0, w1)→ w0), ∀(s0,(w1 → w0)))\n  3ad2ant2(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), w3, (∀(s0,(w1 → w2))→ ∀(s0,(w1 → w0))))\n  al2imi(s0, (w1 →(w2 ↔ w0)), (w1 → w2), (w1 → w0))\n  imim3i(w1, (w2 ↔ w0), w2, w0)\n  biimp(w2, w0)\n  3ad2ant1(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), w3, (∀(s0,(w1 → w0))↔(∃(s0, w1)→ w0)))\n  19.23t(s0, w0, w1)\n  mpbid((F/(s0, w0)∧ ∀(s0,(w1 →(w2 ↔ w0)))∧ w3), (w0 → ∀(s0,(w1 → w2))), ∀(s0,(w0 →(w1 → w2))))\n  3ad2ant2(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), w3, ∀(s0,(w0 →(w1 → w2))))\n  alimi(s0, (w1 →(w2 ↔ w0)), (w0 →(w1 → w2)))\n  com23((w1 →(w2 ↔ w0)), w0, w1, w2)\n  imim2i(w1, (w2 ↔ w0), (w0 → w2))\n  biimpr(w2, w0)\n  3ad2ant1(F/(s0, w0), ∀(s0,(w1 →(w2 ↔ w0))), w3, (∀(s0,(w0 →(w1 → w2)))↔(w0 → ∀(s0,(w1 → w2)))))\n  19.21t(s0, w0, (w1 → w2))\n}","parent":["impbid","mpid","3ad2ant3","sylibd","3ad2ant2","al2imi","imim3i","biimp","3ad2ant1","19.23t","mpbid","alimi","com23","imim2i","biimpr","19.21t"],"children":[]},{"name":"bj-ceqsalt","content":"Remove from ~ ceqsalt dependency on ~ ax-ext (and on ~ df-cleq and ~ df-v ). Note: this is not doable with ~ ceqsralt (or ~ ceqsralv ), which uses ~ eleq1 , but the same dependence removal is possible for ~ ceqsalg , ~ ceqsal , ~ ceqsalv , ~ cgsexg , ~ cgsex2g , ~ cgsex4g , ~ ceqsex , ~ ceqsexv , ~ ceqsex2 , ~ ceqsex2v , ~ ceqsex3v , ~ ceqsex4v , ~ ceqsex6v , ~ ceqsex8v , ~ gencbvex (after changing ` A = y ` to ` y = A ` ), ~ gencbvex2 , ~ gencbval , ~ vtoclgft (it uses ` F/_ ` , whose justification ~ nfcjust does not use ~ ax-ext ) and several other vtocl* theorems (see for instance ~ bj-vtoclg1f ). See also ~ bj-ceqsaltv . (Contributed by BJ, 16-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsalt(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(w3a(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wcel(c0, c1)), wb(wal(s0, wi(wceq(cv(s0), c0), w1)), w0))\n  -| diffsc(s0, c0)\n} = {\n  syl(w3a(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wcel(c0, c1)), wb(wal(s0, wi(wceq(cv(s0), c0), w1)), w0), w3a(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wex(s0, wceq(cv(s0), c0))))\n  3anim3i(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wcel(c0, c1), wex(s0, wceq(cv(s0), c0)))\n  bj-elisset(s0, c0, c1)\n  bj-ceqsalt0(s0, w0, wceq(cv(s0), c0), w1)\n}","pretty":"thm bj-ceqsalt(setvar s0, class c0, class c1, wff w0, wff w1) {\n  ⊢ ((F/(s0, w0)∧ ∀(s0,(s0 = c0 →(w1 ↔ w0)))∧ c0 ∈ c1)→(∀(s0,(s0 = c0 → w1))↔ w0))\n  ⊣ d(s0, c0)\n} = {\n  syl((F/(s0, w0)∧ ∀(s0,(s0 = c0 →(w1 ↔ w0)))∧ c0 ∈ c1), (∀(s0,(s0 = c0 → w1))↔ w0), (F/(s0, w0)∧ ∀(s0,(s0 = c0 →(w1 ↔ w0)))∧ ∃(s0, s0 = c0)))\n  3anim3i(F/(s0, w0), ∀(s0,(s0 = c0 →(w1 ↔ w0))), c0 ∈ c1, ∃(s0, s0 = c0))\n  bj-elisset(s0, c0, c1)\n  bj-ceqsalt0(s0, w0, s0 = c0, w1)\n}","parent":["syl","3anim3i","bj-elisset","bj-ceqsalt0"],"children":["bj-ceqsalgALT"]},{"name":"bj-ceqsaltv","content":"Version of ~ bj-ceqsalt with a disjoint variable condition on ` x , V ` , removing dependency on ~ df-sb and ~ df-clab . Prefer its use over ~ bj-ceqsalt when sufficient (in particular when ` V ` is substituted for ` _V ` ). (Contributed by BJ, 16-Jun-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsaltv(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(w3a(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wcel(c0, c1)), wb(wal(s0, wi(wceq(cv(s0), c0), w1)), w0))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n} = {\n  syl(w3a(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wcel(c0, c1)), wb(wal(s0, wi(wceq(cv(s0), c0), w1)), w0), w3a(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wex(s0, wceq(cv(s0), c0))))\n  3anim3i(wnf(s0, w0), wal(s0, wi(wceq(cv(s0), c0), wb(w1, w0))), wcel(c0, c1), wex(s0, wceq(cv(s0), c0)))\n  bj-elissetv(s0, c0, c1)\n  bj-ceqsalt0(s0, w0, wceq(cv(s0), c0), w1)\n}","pretty":"thm bj-ceqsaltv(setvar s0, class c0, class c1, wff w0, wff w1) {\n  ⊢ ((F/(s0, w0)∧ ∀(s0,(s0 = c0 →(w1 ↔ w0)))∧ c0 ∈ c1)→(∀(s0,(s0 = c0 → w1))↔ w0))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n} = {\n  syl((F/(s0, w0)∧ ∀(s0,(s0 = c0 →(w1 ↔ w0)))∧ c0 ∈ c1), (∀(s0,(s0 = c0 → w1))↔ w0), (F/(s0, w0)∧ ∀(s0,(s0 = c0 →(w1 ↔ w0)))∧ ∃(s0, s0 = c0)))\n  3anim3i(F/(s0, w0), ∀(s0,(s0 = c0 →(w1 ↔ w0))), c0 ∈ c1, ∃(s0, s0 = c0))\n  bj-elissetv(s0, c0, c1)\n  bj-ceqsalt0(s0, w0, s0 = c0, w1)\n}","parent":["syl","3anim3i","bj-elissetv","bj-ceqsalt0"],"children":["bj-ceqsalgvALT"]},{"name":"bj-ceqsalg0","content":"The FOL content of ~ ceqsalg . (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsalg0(setvar s0, wff w0, wff w1, wff w2) {\n  |- wi(wex(s0, w0), wb(wal(s0, wi(w0, w1)), w2))\n  -| wnf(s0, w2)\n  -| wi(w0, wb(w1, w2))\n} = {\n  mp3an12(wex(s0, w0), wb(wal(s0, wi(w0, w1)), w2), wnf(s0, w2), wal(s0, wi(w0, wb(w1, w2))))\n  ax-gen(s0, wi(w0, wb(w1, w2)))\n  bj-ceqsalt0(s0, w2, w0, w1)\n}","pretty":"thm bj-ceqsalg0(setvar s0, wff w0, wff w1, wff w2) {\n  ⊢ (∃(s0, w0)→(∀(s0,(w0 → w1))↔ w2))\n  ⊣ F/(s0, w2)\n  ⊣ (w0 →(w1 ↔ w2))\n} = {\n  mp3an12(∃(s0, w0), (∀(s0,(w0 → w1))↔ w2), F/(s0, w2), ∀(s0,(w0 →(w1 ↔ w2))))\n  ax-gen(s0, (w0 →(w1 ↔ w2)))\n  bj-ceqsalt0(s0, w2, w0, w1)\n}","parent":["mp3an12","ax-gen","bj-ceqsalt0"],"children":["bj-ceqsalg","bj-ceqsalgv"]},{"name":"bj-ceqsalg","content":"Remove from ~ ceqsalg dependency on ~ ax-ext (and on ~ df-cleq and ~ df-v ). See also ~ bj-ceqsalgv . (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsalg(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1))\n  -| wnf(s0, w1)\n  -| wi(wceq(cv(s0), c0), wb(w0, w1))\n  -| diffsc(s0, c0)\n} = {\n  syl(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1), wex(s0, wceq(cv(s0), c0)))\n  bj-elisset(s0, c0, c1)\n  bj-ceqsalg0(s0, wceq(cv(s0), c0), w0, w1)\n}","pretty":"thm bj-ceqsalg(setvar s0, class c0, class c1, wff w0, wff w1) {\n  ⊢ (c0 ∈ c1 →(∀(s0,(s0 = c0 → w0))↔ w1))\n  ⊣ F/(s0, w1)\n  ⊣ (s0 = c0 →(w0 ↔ w1))\n  ⊣ d(s0, c0)\n} = {\n  syl(c0 ∈ c1, (∀(s0,(s0 = c0 → w0))↔ w1), ∃(s0, s0 = c0))\n  bj-elisset(s0, c0, c1)\n  bj-ceqsalg0(s0, s0 = c0, w0, w1)\n}","parent":["syl","bj-elisset","bj-ceqsalg0"],"children":[]},{"name":"bj-ceqsalgALT","content":"Alternate proof of ~ bj-ceqsalg . (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-ceqsalgALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1))\n  -| wnf(s0, w1)\n  -| wi(wceq(cv(s0), c0), wb(w0, w1))\n  -| diffsc(s0, c0)\n} = {\n  mp3an12(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1), wnf(s0, w1), wal(s0, wi(wceq(cv(s0), c0), wb(w0, w1))))\n  ax-gen(s0, wi(wceq(cv(s0), c0), wb(w0, w1)))\n  bj-ceqsalt(s0, c0, c1, w1, w0)\n}","pretty":"thm bj-ceqsalgALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  ⊢ (c0 ∈ c1 →(∀(s0,(s0 = c0 → w0))↔ w1))\n  ⊣ F/(s0, w1)\n  ⊣ (s0 = c0 →(w0 ↔ w1))\n  ⊣ d(s0, c0)\n} = {\n  mp3an12(c0 ∈ c1, (∀(s0,(s0 = c0 → w0))↔ w1), F/(s0, w1), ∀(s0,(s0 = c0 →(w0 ↔ w1))))\n  ax-gen(s0, (s0 = c0 →(w0 ↔ w1)))\n  bj-ceqsalt(s0, c0, c1, w1, w0)\n}","parent":["mp3an12","ax-gen","bj-ceqsalt"],"children":[]},{"name":"bj-ceqsalgv","content":"Version of ~ bj-ceqsalg with a disjoint variable condition on ` x , V ` , removing dependency on ~ df-sb and ~ df-clab . Prefer its use over ~ bj-ceqsalg when sufficient (in particular when ` V ` is substituted for ` _V ` ). (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsalgv(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1))\n  -| wnf(s0, w1)\n  -| wi(wceq(cv(s0), c0), wb(w0, w1))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n} = {\n  syl(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1), wex(s0, wceq(cv(s0), c0)))\n  bj-elissetv(s0, c0, c1)\n  bj-ceqsalg0(s0, wceq(cv(s0), c0), w0, w1)\n}","pretty":"thm bj-ceqsalgv(setvar s0, class c0, class c1, wff w0, wff w1) {\n  ⊢ (c0 ∈ c1 →(∀(s0,(s0 = c0 → w0))↔ w1))\n  ⊣ F/(s0, w1)\n  ⊣ (s0 = c0 →(w0 ↔ w1))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n} = {\n  syl(c0 ∈ c1, (∀(s0,(s0 = c0 → w0))↔ w1), ∃(s0, s0 = c0))\n  bj-elissetv(s0, c0, c1)\n  bj-ceqsalg0(s0, s0 = c0, w0, w1)\n}","parent":["syl","bj-elissetv","bj-ceqsalg0"],"children":["bj-ceqsal","bj-raldifsn"]},{"name":"bj-ceqsalgvALT","content":"Alternate proof of ~ bj-ceqsalgv . (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm bj-ceqsalgvALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  |- wi(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1))\n  -| wnf(s0, w1)\n  -| wi(wceq(cv(s0), c0), wb(w0, w1))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n} = {\n  mp3an12(wcel(c0, c1), wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1), wnf(s0, w1), wal(s0, wi(wceq(cv(s0), c0), wb(w0, w1))))\n  ax-gen(s0, wi(wceq(cv(s0), c0), wb(w0, w1)))\n  bj-ceqsaltv(s0, c0, c1, w1, w0)\n}","pretty":"thm bj-ceqsalgvALT(setvar s0, class c0, class c1, wff w0, wff w1) {\n  ⊢ (c0 ∈ c1 →(∀(s0,(s0 = c0 → w0))↔ w1))\n  ⊣ F/(s0, w1)\n  ⊣ (s0 = c0 →(w0 ↔ w1))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n} = {\n  mp3an12(c0 ∈ c1, (∀(s0,(s0 = c0 → w0))↔ w1), F/(s0, w1), ∀(s0,(s0 = c0 →(w0 ↔ w1))))\n  ax-gen(s0, (s0 = c0 →(w0 ↔ w1)))\n  bj-ceqsaltv(s0, c0, c1, w1, w0)\n}","parent":["mp3an12","ax-gen","bj-ceqsaltv"],"children":[]},{"name":"bj-ceqsal","content":"Remove from ~ ceqsal dependency on ~ ax-ext (and on ~ df-cleq , ~ df-v , ~ df-clab , ~ df-sb ). (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsal(setvar s0, class c0, wff w0, wff w1) {\n  |- wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1)\n  -| wnf(s0, w1)\n  -| wcel(c0, universe)\n  -| wi(wceq(cv(s0), c0), wb(w0, w1))\n  -| diffsc(s0, c0)\n} = {\n  ax-mp(wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1), wcel(c0, universe))\n  bj-ceqsalgv(s0, c0, universe, w0, w1)\n  diff.universe.s(s0)\n}","pretty":"thm bj-ceqsal(setvar s0, class c0, wff w0, wff w1) {\n  ⊢ (∀(s0,(s0 = c0 → w0))↔ w1)\n  ⊣ F/(s0, w1)\n  ⊣ c0 ∈ 𝕌\n  ⊣ (s0 = c0 →(w0 ↔ w1))\n  ⊣ d(s0, c0)\n} = {\n  ax-mp((∀(s0,(s0 = c0 → w0))↔ w1), c0 ∈ 𝕌)\n  bj-ceqsalgv(s0, c0, universe, w0, w1)\n  diff.universe.s(s0)\n}","parent":["ax-mp","bj-ceqsalgv","diff.universe.s"],"children":["bj-ceqsalv"]},{"name":"bj-ceqsalv","content":"Remove from ~ ceqsalv dependency on ~ ax-ext (and on ~ df-cleq , ~ df-v , ~ df-clab , ~ df-sb ). (Contributed by BJ, 12-Oct-2019.) (Proof modification is discouraged.)","origin":"thm bj-ceqsalv(setvar s0, class c0, wff w0, wff w1) {\n  |- wb(wal(s0, wi(wceq(cv(s0), c0), w0)), w1)\n  -| wcel(c0, universe)\n  -| wi(wceq(cv(s0), c0), wb(w0, w1))\n  -| diffsc(s0, c0)\n  -| diffsw(s0, w1)\n} = {\n  bj-ceqsal(s0, c0, w0, w1)\n  nfv(s0, w1)\n}","pretty":"thm bj-ceqsalv(setvar s0, class c0, wff w0, wff w1) {\n  ⊢ (∀(s0,(s0 = c0 → w0))↔ w1)\n  ⊣ c0 ∈ 𝕌\n  ⊣ (s0 = c0 →(w0 ↔ w1))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, w1)\n} = {\n  bj-ceqsal(s0, c0, w0, w1)\n  nfv(s0, w1)\n}","parent":["bj-ceqsal","nfv"],"children":[]},{"name":"bj-spcimdv","content":"Remove from ~ spcimdv dependency on ~ ax-9 , ~ ax-10 , ~ ax-11 , ~ ax-13 , ~ ax-ext , ~ df-cleq (and ~ df-nfc , ~ df-v , ~ df-or , ~ df-tru , ~ df-nf ). For an even more economical version, see ~ bj-spcimdvv . (Contributed by BJ, 30-Nov-2020.) (Proof modification is discouraged.)","origin":"thm bj-spcimdv(setvar s0, class c0, class c1, wff w0, wff w1, wff w2) {\n  |- wi(w0, wi(wal(s0, w1), w2))\n  -| wi(w0, wcel(c0, c1))\n  -| wi(wa(w0, wceq(cv(s0), c0)), wi(w1, w2))\n  -| diffsc(s0, c0)\n  -| diffsw(s0, w0)\n  -| diffsw(s0, w2)\n} = {\n  sylc(w0, wi(wal(s0, w1), w2), wal(s0, wi(wceq(cv(s0), c0), wi(w1, w2))), wcel(c0, c1))\n  alrimiv(s0, w0, wi(wceq(cv(s0), c0), wi(w1, w2)))\n  ex(w0, wceq(cv(s0), c0), wi(w1, w2))\n  syl6ib(wal(s0, wi(wceq(cv(s0), c0), wi(w1, w2))), wcel(c0, c1), wi(wal(s0, w1), w2), wex(s0, wi(w1, w2)))\n  syl5(wal(s0, wi(wceq(cv(s0), c0), wi(w1, w2))), wcel(c0, c1), wex(s0, wi(w1, w2)), wex(s0, wceq(cv(s0), c0)))\n  bj-elisset(s0, c0, c1)\n  exim(s0, wceq(cv(s0), c0), wi(w1, w2))\n  19.36v(s0, w1, w2)\n}","pretty":"thm bj-spcimdv(setvar s0, class c0, class c1, wff w0, wff w1, wff w2) {\n  ⊢ (w0 →(∀(s0, w1)→ w2))\n  ⊣ (w0 → c0 ∈ c1)\n  ⊣ ((w0 ∧ s0 = c0)→(w1 → w2))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, w0)\n  ⊣ d(s0, w2)\n} = {\n  sylc(w0, (∀(s0, w1)→ w2), ∀(s0,(s0 = c0 →(w1 → w2))), c0 ∈ c1)\n  alrimiv(s0, w0, (s0 = c0 →(w1 → w2)))\n  ex(w0, s0 = c0, (w1 → w2))\n  syl6ib(∀(s0,(s0 = c0 →(w1 → w2))), c0 ∈ c1, (∀(s0, w1)→ w2), ∃(s0,(w1 → w2)))\n  syl5(∀(s0,(s0 = c0 →(w1 → w2))), c0 ∈ c1, ∃(s0,(w1 → w2)), ∃(s0, s0 = c0))\n  bj-elisset(s0, c0, c1)\n  exim(s0, s0 = c0, (w1 → w2))\n  19.36v(s0, w1, w2)\n}","parent":["sylc","alrimiv","ex","syl6ib","syl5","bj-elisset","exim","19.36v"],"children":[]},{"name":"bj-spcimdvv","content":"Remove from ~ spcimdv dependency on ~ ax-7 , ~ ax-8 , ~ ax-10 , ~ ax-11 , ~ ax-12 ~ ax-13 , ~ ax-ext , ~ df-cleq , ~ df-clab (and ~ df-nfc , ~ df-v , ~ df-or , ~ df-tru , ~ df-nf ) at the price of adding a disjoint variable condition on ` x , B ` (but in usages, ` x ` is typically a dummy, hence fresh, variable). For the version without this disjoint variable condition, see ~ bj-spcimdv . (Contributed by BJ, 3-Nov-2021.) (Proof modification is discouraged.)","origin":"thm bj-spcimdvv(setvar s0, class c0, class c1, wff w0, wff w1, wff w2) {\n  |- wi(w0, wi(wal(s0, w1), w2))\n  -| wi(w0, wcel(c0, c1))\n  -| wi(wa(w0, wceq(cv(s0), c0)), wi(w1, w2))\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsw(s0, w0)\n  -| diffsw(s0, w2)\n} = {\n  sylc(w0, wi(wal(s0, w1), w2), wal(s0, wi(wceq(cv(s0), c0), wi(w1, w2))), wcel(c0, c1))\n  alrimiv(s0, w0, wi(wceq(cv(s0), c0), wi(w1, w2)))\n  ex(w0, wceq(cv(s0), c0), wi(w1, w2))\n  syl6ib(wal(s0, wi(wceq(cv(s0), c0), wi(w1, w2))), wcel(c0, c1), wi(wal(s0, w1), w2), wex(s0, wi(w1, w2)))\n  syl5(wal(s0, wi(wceq(cv(s0), c0), wi(w1, w2))), wcel(c0, c1), wex(s0, wi(w1, w2)), wex(s0, wceq(cv(s0), c0)))\n  bj-elissetv(s0, c0, c1)\n  exim(s0, wceq(cv(s0), c0), wi(w1, w2))\n  19.36v(s0, w1, w2)\n}","pretty":"thm bj-spcimdvv(setvar s0, class c0, class c1, wff w0, wff w1, wff w2) {\n  ⊢ (w0 →(∀(s0, w1)→ w2))\n  ⊣ (w0 → c0 ∈ c1)\n  ⊣ ((w0 ∧ s0 = c0)→(w1 → w2))\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, w0)\n  ⊣ d(s0, w2)\n} = {\n  sylc(w0, (∀(s0, w1)→ w2), ∀(s0,(s0 = c0 →(w1 → w2))), c0 ∈ c1)\n  alrimiv(s0, w0, (s0 = c0 →(w1 → w2)))\n  ex(w0, s0 = c0, (w1 → w2))\n  syl6ib(∀(s0,(s0 = c0 →(w1 → w2))), c0 ∈ c1, (∀(s0, w1)→ w2), ∃(s0,(w1 → w2)))\n  syl5(∀(s0,(s0 = c0 →(w1 → w2))), c0 ∈ c1, ∃(s0,(w1 → w2)), ∃(s0, s0 = c0))\n  bj-elissetv(s0, c0, c1)\n  exim(s0, s0 = c0, (w1 → w2))\n  19.36v(s0, w1, w2)\n}","parent":["sylc","alrimiv","ex","syl6ib","syl5","bj-elissetv","exim","19.36v"],"children":[]}]}