{"index":76,"title":"Introduce the Axiom of Extensionality","content":"","blocks":[{"name":"ax-ext","content":"Axiom of Extensionality. An axiom of Zermelo-Fraenkel set theory. It states that two sets are identical if they contain the same elements. Axiom Ext of [BellMachover] p. 461. Set theory can also be formulated with a _single_ primitive predicate ` e. ` on top of traditional predicate calculus _without_ equality. In that case the Axiom of Extensionality becomes ` ( A. w ( w e. x <-> w e. y ) -> ( x e. z -> y e. z ) ) ` , and equality ` x = y ` is _defined_ as ` A. w ( w e. x <-> w e. y ) ` . All of the usual axioms of equality then become theorems of set theory. See, for example, Axiom 1 of [TakeutiZaring] p. 8. To use the above \"equality-free\" version of Extensionality with Metamath's predicate calculus axioms, we would rewrite all axioms involving equality with equality expanded according to the above definition. Some of those axioms may be provable from ax-ext and would become redundant, but this hasn't been studied carefully. _General remarks_: Our set theory axioms are presented using defined connectives ( ` <-> ` , ` E. ` , etc.) for convenience. However, it is implicitly understood that the actual axioms use only the primitive connectives ` -> ` , ` -. ` , ` A. ` , ` = ` , and ` e. ` . It is straightforward to establish the equivalence between the actual axioms and the ones we display, and we will not do so. It is important to understand that strictly speaking, all of our set theory axioms are really schemes that represent an infinite number of actual axioms. This is inherent in the design of Metamath (\"metavariable math\"), which manipulates only metavariables. For example, the metavariable ` x ` in ~ ax-ext can represent any actual variable _v1_, _v2_, _v3_,... . Distinct variable restrictions ($d) prevent us from substituting say _v1_ for both ` x ` and ` z ` . This is in contrast to typical textbook presentations that present actual axioms (except for Replacement ~ ax-rep , which involves a wff metavariable). In practice, though, the theorems and proofs are essentially the same. The $d restrictions make each of the infinite axioms generated by the ~ ax-ext scheme exactly logically equivalent to each other and in particular to the actual axiom of the textbook version. (Contributed by NM, 21-May-1993.)","origin":"axiom ax-ext(setvar s0, setvar s1, setvar s2) {\n  |- wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2)))\n  -| diffss(s1, s2)\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n}","pretty":"axiom ax-ext(setvar s0, setvar s1, setvar s2) {\n  ⊢ (∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n}","parent":[],"children":["axext2","axext3","axext3ALT","axextmo","bm1.1OLD","ax6vsep","nfnid","bj-axext3","bj-ax9","bj-ax9-2","axc11next"]},{"name":"axext2","content":"The Axiom of Extensionality ( ~ ax-ext ) restated so that it postulates the existence of a set ` z ` given two arbitrary sets ` x ` and ` y ` . This way to express it follows the general idea of the other ZFC axioms, which is to postulate the existence of sets given other sets. (Contributed by NM, 28-Sep-2003.)","origin":"thm axext2(setvar s0, setvar s1, setvar s2) {\n  |- wex(s0, wi(wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2))), wceq(cv(s1), cv(s2))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  mpbir(wex(s0, wi(wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2))), wceq(cv(s1), cv(s2)))), wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2))))\n  ax-ext(s0, s1, s2)\n  19.36v(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2))), wceq(cv(s1), cv(s2)))\n  diff.wceq.s(s0, cv(s1), cv(s2))\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, s2)\n}","pretty":"thm axext2(setvar s0, setvar s1, setvar s2) {\n  ⊢ ∃(s0,((s0 ∈ s1 ↔ s0 ∈ s2)→ s1 = s2))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  mpbir(∃(s0,((s0 ∈ s1 ↔ s0 ∈ s2)→ s1 = s2)), (∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2))\n  ax-ext(s0, s1, s2)\n  19.36v(s0, (s0 ∈ s1 ↔ s0 ∈ s2), s1 = s2)\n  diff.wceq.s(s0, s1, s2)\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, s2)\n}","parent":["mpbir","ax-ext","19.36v","diff.wceq.s","diff.cv.s"],"children":[]},{"name":"axext3","content":"A generalization of the Axiom of Extensionality in which ` x ` and ` y ` need not be distinct. (Contributed by NM, 15-Sep-1993.) (Proof shortened by Andrew Salmon, 12-Aug-2011.) Remove dependencies on ~ ax-10 , ~ ax-12 , ~ ax-13 . (Revised by Wolf Lammen, 9-Dec-2019.)","origin":"thm axext3(setvar s0, setvar s1, setvar s2) {\n  |- wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2)))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n} = {\n  exlimiiv(hs0, wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2))), wceq(cv(hs0), cv(s1)))\n  syld(wceq(cv(hs0), cv(s1)), wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2)), wceq(cv(hs0), cv(s2)))\n  syl6bir(wceq(cv(hs0), cv(s1)), wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(hs0), cv(s2)), wal(s0, wb(wcel(cv(s0), cv(hs0)), wcel(cv(s0), cv(s2)))))\n  albidv(s0, wceq(cv(hs0), cv(s1)), wb(wcel(cv(s0), cv(hs0)), wcel(cv(s0), cv(s2))), wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2))))\n  bibi1d(wceq(cv(hs0), cv(s1)), wcel(cv(s0), cv(hs0)), wcel(cv(s0), cv(s2)), wcel(cv(s0), cv(s1)))\n  elequ2(hs0, s1, s0)\n  ax-ext(s0, hs0, s2)\n  ax7(hs0, s1, s2)\n  ax6ev(hs0, s1)\n  diff.hs0.w(wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2))))\n  diff.wceq.s(s0, cv(hs0), cv(s1))\n  diff.cv.s(s0, hs0)\n  diff.cv.s(s0, s1)\n  diff.hs0.s(s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n}","pretty":"thm axext3(setvar s0, setvar s1, setvar s2) {\n  ⊢ (∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n} = {\n  exlimiiv(hs0, (∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2), hs0 = s1)\n  syld(hs0 = s1, ∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2)), s1 = s2, hs0 = s2)\n  syl6bir(hs0 = s1, ∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2)), hs0 = s2, ∀(s0,(s0 ∈ hs0 ↔ s0 ∈ s2)))\n  albidv(s0, hs0 = s1, (s0 ∈ hs0 ↔ s0 ∈ s2), (s0 ∈ s1 ↔ s0 ∈ s2))\n  bibi1d(hs0 = s1, s0 ∈ hs0, s0 ∈ s2, s0 ∈ s1)\n  elequ2(hs0, s1, s0)\n  ax-ext(s0, hs0, s2)\n  ax7(hs0, s1, s2)\n  ax6ev(hs0, s1)\n  diff.hs0.w((∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2))\n  diff.wceq.s(s0, hs0, s1)\n  diff.cv.s(s0, hs0)\n  diff.cv.s(s0, s1)\n  diff.hs0.s(s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n}","parent":["exlimiiv","syld","syl6bir","albidv","bibi1d","elequ2","ax-ext","ax7","ax6ev","diff.hs0.w","diff.wceq.s","diff.cv.s","diff.hs0.s","diffss.ex"],"children":["axext4","dfcleq","axextnd","axextdist","bj-cleqhyp"]},{"name":"axext3ALT","content":"Alternate proof of ~ axext3 , shorter but uses more axioms. (Contributed by NM, 15-Sep-1993.) (Proof shortened by Andrew Salmon, 12-Aug-2011.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm axext3ALT(setvar s0, setvar s1, setvar s2) {\n  |- wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2)))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n} = {\n  chvarv(hs0, s1, wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2))), wi(wal(s0, wb(wcel(cv(s0), cv(hs0)), wcel(cv(s0), cv(s2)))), wceq(cv(hs0), cv(s2))))\n  imbi12d(wceq(cv(hs0), cv(s1)), wal(s0, wb(wcel(cv(s0), cv(hs0)), wcel(cv(s0), cv(s2)))), wceq(cv(hs0), cv(s2)), wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2)))\n  albidv(s0, wceq(cv(hs0), cv(s1)), wb(wcel(cv(s0), cv(hs0)), wcel(cv(s0), cv(s2))), wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2))))\n  bibi1d(wceq(cv(hs0), cv(s1)), wcel(cv(s0), cv(hs0)), wcel(cv(s0), cv(s2)), wcel(cv(s0), cv(s1)))\n  elequ2(hs0, s1, s0)\n  equequ1(hs0, s1, s2)\n  ax-ext(s0, hs0, s2)\n  diff.hs0.w(wi(wal(s0, wb(wcel(cv(s0), cv(s1)), wcel(cv(s0), cv(s2)))), wceq(cv(s1), cv(s2))))\n  diff.wceq.s(s0, cv(hs0), cv(s1))\n  diff.cv.s(s0, hs0)\n  diff.cv.s(s0, s1)\n  diff.hs0.s(s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm axext3ALT(setvar s0, setvar s1, setvar s2) {\n  ⊢ (∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n} = {\n  chvarv(hs0, s1, (∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2), (∀(s0,(s0 ∈ hs0 ↔ s0 ∈ s2))→ hs0 = s2))\n  imbi12d(hs0 = s1, ∀(s0,(s0 ∈ hs0 ↔ s0 ∈ s2)), hs0 = s2, ∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2)), s1 = s2)\n  albidv(s0, hs0 = s1, (s0 ∈ hs0 ↔ s0 ∈ s2), (s0 ∈ s1 ↔ s0 ∈ s2))\n  bibi1d(hs0 = s1, s0 ∈ hs0, s0 ∈ s2, s0 ∈ s1)\n  elequ2(hs0, s1, s0)\n  equequ1(hs0, s1, s2)\n  ax-ext(s0, hs0, s2)\n  diff.hs0.w((∀(s0,(s0 ∈ s1 ↔ s0 ∈ s2))→ s1 = s2))\n  diff.wceq.s(s0, hs0, s1)\n  diff.cv.s(s0, hs0)\n  diff.cv.s(s0, s1)\n  diff.hs0.s(s2)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["chvarv","imbi12d","albidv","bibi1d","elequ2","equequ1","ax-ext","diff.hs0.w","diff.wceq.s","diff.cv.s","diff.hs0.s","diffss.ex"],"children":[]},{"name":"axext4","content":"A bidirectional version of Extensionality. Although this theorem \"looks\" like it is just a definition of equality, it requires the Axiom of Extensionality for its proof under our axiomatization. See the comments for ~ ax-ext and ~ df-cleq . (Contributed by NM, 14-Nov-2008.)","origin":"thm axext4(setvar s0, setvar s1, setvar s2) {\n  |- wb(wceq(cv(s0), cv(s1)), wal(s2, wb(wcel(cv(s2), cv(s0)), wcel(cv(s2), cv(s1)))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  impbii(wceq(cv(s0), cv(s1)), wal(s2, wb(wcel(cv(s2), cv(s0)), wcel(cv(s2), cv(s1)))))\n  alrimiv(s2, wceq(cv(s0), cv(s1)), wb(wcel(cv(s2), cv(s0)), wcel(cv(s2), cv(s1))))\n  elequ2(s0, s1, s2)\n  axext3(s2, s0, s1)\n  diff.wceq.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s0)\n  diffss.ex(s2, s1)\n}","pretty":"thm axext4(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 ↔ ∀(s2,(s2 ∈ s0 ↔ s2 ∈ s1)))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  impbii(s0 = s1, ∀(s2,(s2 ∈ s0 ↔ s2 ∈ s1)))\n  alrimiv(s2, s0 = s1, (s2 ∈ s0 ↔ s2 ∈ s1))\n  elequ2(s0, s1, s2)\n  axext3(s2, s0, s1)\n  diff.wceq.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s0)\n  diffss.ex(s2, s1)\n}","parent":["impbii","alrimiv","elequ2","axext3","diff.wceq.s","diff.cv.s","diffss.ex"],"children":["axc11next"]},{"name":"axextmo","content":"There exists at most one set with prescribed elements. Theorem 1.1 of [BellMachover] p. 462. (Contributed by NM, 30-Jun-1994.) (Proof shortened by Wolf Lammen, 13-Nov-2019.) Use the at-most-one quantifier. (Revised by BJ, 17-Sep-2022.)","origin":"thm axextmo(setvar s0, setvar s1, wff w0) {\n  |- wmo(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0)))\n  -| wnf(s0, w0)\n  -| diffss(s0, s1)\n} = {\n  mpbir(wmo(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0))), wal(s0, wal(hs0, wi(wa(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))), wceq(cv(s0), cv(hs0))))))\n  gen2(s0, hs0, wi(wa(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))), wceq(cv(s0), cv(hs0))))\n  syl(wa(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))), wceq(cv(s0), cv(hs0)), wal(s1, wb(wcel(cv(s1), cv(s0)), wcel(cv(s1), cv(hs0)))))\n  alanimi(s1, wb(wcel(cv(s1), cv(s0)), w0), wb(wcel(cv(s1), cv(hs0)), w0), wb(wcel(cv(s1), cv(s0)), wcel(cv(s1), cv(hs0))))\n  biantr(wcel(cv(s1), cv(s0)), w0, wcel(cv(s1), cv(hs0)))\n  ax-ext(s1, s0, hs0)\n  mo4f(s0, hs0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0)))\n  nfal(s0, s1, wb(wcel(cv(s1), cv(hs0)), w0))\n  nfbi(s0, wcel(cv(s1), cv(hs0)), w0)\n  nfv(s0, wcel(cv(s1), cv(hs0)))\n  albidv(s1, wceq(cv(s0), cv(hs0)), wb(wcel(cv(s1), cv(s0)), w0), wb(wcel(cv(s1), cv(hs0)), w0))\n  bibi1d(wceq(cv(s0), cv(hs0)), wcel(cv(s1), cv(s0)), w0, wcel(cv(s1), cv(hs0)))\n  elequ2(s0, hs0, s1)\n  diff.hs0.w(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)))\n  diff.wcel.s(s0, cv(s1), cv(hs0))\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wceq.s(s1, cv(s0), cv(hs0))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","pretty":"thm axextmo(setvar s0, setvar s1, wff w0) {\n  ⊢ ∃*(s0, ∀(s1,(s1 ∈ s0 ↔ w0)))\n  ⊣ F/(s0, w0)\n  ⊣ d(s0, s1)\n} = {\n  mpbir(∃*(s0, ∀(s1,(s1 ∈ s0 ↔ w0))), ∀(s0, ∀(hs0,((∀(s1,(s1 ∈ s0 ↔ w0))∧ ∀(s1,(s1 ∈ hs0 ↔ w0)))→ s0 = hs0))))\n  gen2(s0, hs0, ((∀(s1,(s1 ∈ s0 ↔ w0))∧ ∀(s1,(s1 ∈ hs0 ↔ w0)))→ s0 = hs0))\n  syl((∀(s1,(s1 ∈ s0 ↔ w0))∧ ∀(s1,(s1 ∈ hs0 ↔ w0))), s0 = hs0, ∀(s1,(s1 ∈ s0 ↔ s1 ∈ hs0)))\n  alanimi(s1, (s1 ∈ s0 ↔ w0), (s1 ∈ hs0 ↔ w0), (s1 ∈ s0 ↔ s1 ∈ hs0))\n  biantr(s1 ∈ s0, w0, s1 ∈ hs0)\n  ax-ext(s1, s0, hs0)\n  mo4f(s0, hs0, ∀(s1,(s1 ∈ s0 ↔ w0)), ∀(s1,(s1 ∈ hs0 ↔ w0)))\n  nfal(s0, s1, (s1 ∈ hs0 ↔ w0))\n  nfbi(s0, s1 ∈ hs0, w0)\n  nfv(s0, s1 ∈ hs0)\n  albidv(s1, s0 = hs0, (s1 ∈ s0 ↔ w0), (s1 ∈ hs0 ↔ w0))\n  bibi1d(s0 = hs0, s1 ∈ s0, w0, s1 ∈ hs0)\n  elequ2(s0, hs0, s1)\n  diff.hs0.w(∀(s1,(s1 ∈ s0 ↔ w0)))\n  diff.wcel.s(s0, s1, hs0)\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wceq.s(s1, s0, hs0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","parent":["mpbir","gen2","syl","alanimi","biantr","ax-ext","mo4f","nfal","nfbi","nfv","albidv","bibi1d","elequ2","diff.hs0.w","diff.wcel.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.wceq.s"],"children":["nulmo","nulmoOLD","zfnuleuOLD"]},{"name":"bm1.1OLD","content":"Obsolete version of ~ axextmo as of 17-Sep-2022. (Contributed by NM, 30-Jun-1994.) (Proof shortened by Wolf Lammen, 13-Nov-2019.) (Proof modification is discouraged.) Use ~ axextmo instead. (New usage is discouraged.)","origin":"thm bm1.1OLD(setvar s0, setvar s1, wff w0) {\n  |- wi(wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0))), weu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0))))\n  -| wnf(s0, w0)\n  -| diffss(s0, s1)\n} = {\n  mpbi(wi(wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0))), weu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0)))), wal(s0, wal(hs0, wi(wa(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))), wceq(cv(s0), cv(hs0))))))\n  gen2(s0, hs0, wi(wa(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))), wceq(cv(s0), cv(hs0))))\n  syl(wa(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))), wceq(cv(s0), cv(hs0)), wal(s1, wb(wcel(cv(s1), cv(s0)), wcel(cv(s1), cv(hs0)))))\n  alanimi(s1, wb(wcel(cv(s1), cv(s0)), w0), wb(wcel(cv(s1), cv(hs0)), w0), wb(wcel(cv(s1), cv(s0)), wcel(cv(s1), cv(hs0))))\n  biantr(wcel(cv(s1), cv(s0)), w0, wcel(cv(s1), cv(hs0)))\n  ax-ext(s1, s0, hs0)\n  bitr3i(wal(s0, wal(hs0, wi(wa(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0))), wceq(cv(s0), cv(hs0))))), wi(wex(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0))), weu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0)))), wmo(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0))))\n  mo4f(s0, hs0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0)), wal(s1, wb(wcel(cv(s1), cv(hs0)), w0)))\n  nfal(s0, s1, wb(wcel(cv(s1), cv(hs0)), w0))\n  nfbi(s0, wcel(cv(s1), cv(hs0)), w0)\n  nfv(s0, wcel(cv(s1), cv(hs0)))\n  albidv(s1, wceq(cv(s0), cv(hs0)), wb(wcel(cv(s1), cv(s0)), w0), wb(wcel(cv(s1), cv(hs0)), w0))\n  bibi1d(wceq(cv(s0), cv(hs0)), wcel(cv(s1), cv(s0)), w0, wcel(cv(s1), cv(hs0)))\n  elequ2(s0, hs0, s1)\n  moeu(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), w0)))\n  diff.hs0.w(wal(s1, wb(wcel(cv(s1), cv(s0)), w0)))\n  diff.wcel.s(s0, cv(s1), cv(hs0))\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wceq.s(s1, cv(s0), cv(hs0))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","pretty":"thm bm1.1OLD(setvar s0, setvar s1, wff w0) {\n  ⊢ (∃(s0, ∀(s1,(s1 ∈ s0 ↔ w0)))→ ∃!(s0, ∀(s1,(s1 ∈ s0 ↔ w0))))\n  ⊣ F/(s0, w0)\n  ⊣ d(s0, s1)\n} = {\n  mpbi((∃(s0, ∀(s1,(s1 ∈ s0 ↔ w0)))→ ∃!(s0, ∀(s1,(s1 ∈ s0 ↔ w0)))), ∀(s0, ∀(hs0,((∀(s1,(s1 ∈ s0 ↔ w0))∧ ∀(s1,(s1 ∈ hs0 ↔ w0)))→ s0 = hs0))))\n  gen2(s0, hs0, ((∀(s1,(s1 ∈ s0 ↔ w0))∧ ∀(s1,(s1 ∈ hs0 ↔ w0)))→ s0 = hs0))\n  syl((∀(s1,(s1 ∈ s0 ↔ w0))∧ ∀(s1,(s1 ∈ hs0 ↔ w0))), s0 = hs0, ∀(s1,(s1 ∈ s0 ↔ s1 ∈ hs0)))\n  alanimi(s1, (s1 ∈ s0 ↔ w0), (s1 ∈ hs0 ↔ w0), (s1 ∈ s0 ↔ s1 ∈ hs0))\n  biantr(s1 ∈ s0, w0, s1 ∈ hs0)\n  ax-ext(s1, s0, hs0)\n  bitr3i(∀(s0, ∀(hs0,((∀(s1,(s1 ∈ s0 ↔ w0))∧ ∀(s1,(s1 ∈ hs0 ↔ w0)))→ s0 = hs0))), (∃(s0, ∀(s1,(s1 ∈ s0 ↔ w0)))→ ∃!(s0, ∀(s1,(s1 ∈ s0 ↔ w0)))), ∃*(s0, ∀(s1,(s1 ∈ s0 ↔ w0))))\n  mo4f(s0, hs0, ∀(s1,(s1 ∈ s0 ↔ w0)), ∀(s1,(s1 ∈ hs0 ↔ w0)))\n  nfal(s0, s1, (s1 ∈ hs0 ↔ w0))\n  nfbi(s0, s1 ∈ hs0, w0)\n  nfv(s0, s1 ∈ hs0)\n  albidv(s1, s0 = hs0, (s1 ∈ s0 ↔ w0), (s1 ∈ hs0 ↔ w0))\n  bibi1d(s0 = hs0, s1 ∈ s0, w0, s1 ∈ hs0)\n  elequ2(s0, hs0, s1)\n  moeu(s0, ∀(s1,(s1 ∈ s0 ↔ w0)))\n  diff.hs0.w(∀(s1,(s1 ∈ s0 ↔ w0)))\n  diff.wcel.s(s0, s1, hs0)\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wceq.s(s1, s0, hs0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n}","parent":["mpbi","gen2","syl","alanimi","biantr","ax-ext","bitr3i","mo4f","nfal","nfbi","nfv","albidv","bibi1d","elequ2","moeu","diff.hs0.w","diff.wcel.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.wceq.s"],"children":[]},{"name":"nulmo","content":"There exists at most one empty set. With either ~ axnul or ~ axnulALT or ~ ax-nul , this proves that there exists a unique empty set. In practice, once the language of classes is available, we use the stronger characterization among classes ~ eq0 . (Contributed by NM, 22-Dec-2007.) Use the at-most-one quantifier. (Revised by BJ, 17-Sep-2022.) (Proof shortened by Wolf Lammen, 26-Apr-2023.)","origin":"thm nulmo(setvar s0, setvar s1) {\n  |- wmo(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  -| diffss(s0, s1)\n} = {\n  mpbir(wmo(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), wmo(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))))\n  axextmo(s0, s1, wfal)\n  nfv(s0, wfal)\n  mobii(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))), wal(s1, wb(wcel(cv(s1), cv(s0)), wfal)))\n  albii(s1, wn(wcel(cv(s1), cv(s0))), wb(wcel(cv(s1), cv(s0)), wfal))\n  nbfal(wcel(cv(s1), cv(s0)))\n  diff.wfal.s(s0)\n}","pretty":"thm nulmo(setvar s0, setvar s1) {\n  ⊢ ∃*(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  mpbir(∃*(s0, ∀(s1, ¬ s1 ∈ s0)), ∃*(s0, ∀(s1,(s1 ∈ s0 ↔ F))))\n  axextmo(s0, s1, wfal)\n  nfv(s0, wfal)\n  mobii(s0, ∀(s1, ¬ s1 ∈ s0), ∀(s1,(s1 ∈ s0 ↔ F)))\n  albii(s1, ¬ s1 ∈ s0, (s1 ∈ s0 ↔ F))\n  nbfal(s1 ∈ s0)\n  diff.wfal.s(s0)\n}","parent":["mpbir","axextmo","nfv","mobii","albii","nbfal","diff.wfal.s"],"children":[]},{"name":"nulmoOLD","content":"Obsolete version of ~ nulmo as of 26-Apr-2023. (Contributed by NM, 22-Dec-2007.) Use the at-most-one quantifier. (Revised by BJ, 17-Sep-2022.) (Proof modification is discouraged.) (New usage is discouraged.)","origin":"thm nulmoOLD(setvar s0, setvar s1) {\n  |- wmo(s0, wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  -| diffss(s0, s1)\n} = {\n  mpbi(wmo(s0, wal(s1, wn(wcel(cv(s1), cv(s0))))), wmo(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal))))\n  axextmo(s0, s1, wfal)\n  nfv(s0, wfal)\n  mobii(s0, wal(s1, wb(wcel(cv(s1), cv(s0)), wfal)), wal(s1, wn(wcel(cv(s1), cv(s0)))))\n  albii(s1, wb(wcel(cv(s1), cv(s0)), wfal), wn(wcel(cv(s1), cv(s0))))\n  bicomi(wb(wcel(cv(s1), cv(s0)), wfal), wn(wcel(cv(s1), cv(s0))))\n  nbfal(wcel(cv(s1), cv(s0)))\n  diff.wfal.s(s0)\n}","pretty":"thm nulmoOLD(setvar s0, setvar s1) {\n  ⊢ ∃*(s0, ∀(s1, ¬ s1 ∈ s0))\n  ⊣ d(s0, s1)\n} = {\n  mpbi(∃*(s0, ∀(s1, ¬ s1 ∈ s0)), ∃*(s0, ∀(s1,(s1 ∈ s0 ↔ F))))\n  axextmo(s0, s1, wfal)\n  nfv(s0, wfal)\n  mobii(s0, ∀(s1,(s1 ∈ s0 ↔ F)), ∀(s1, ¬ s1 ∈ s0))\n  albii(s1, (s1 ∈ s0 ↔ F), ¬ s1 ∈ s0)\n  bicomi((s1 ∈ s0 ↔ F), ¬ s1 ∈ s0)\n  nbfal(s1 ∈ s0)\n  diff.wfal.s(s0)\n}","parent":["mpbi","axextmo","nfv","mobii","albii","bicomi","nbfal","diff.wfal.s"],"children":[]}]}