{"index":84,"title":"Conditional equality (experimental)","content":"This is a very useless definition, which \"abbreviates\" ` ( x = y -> ph ) ` as ` CondEq ( x = y -> ph ) ` . What this display hides, though, is that the first expression, even though it has a shorter constant string, is actually much more complicated in its parse tree: it is parsed as (wi (wceq (cv vx) (cv vy)) wph), while the ` CondEq ` version is parsed as (wcdeq vx vy wph). It also allows us to give a name to the specific ternary operation ` ( x = y -> ph ) ` . This is all used as part of a metatheorem: we want to say that ` |- ( x = y -> ( ph ( x ) <-> ph ( y ) ) ) ` and ` |- ( x = y -> A ( x ) = A ( y ) ) ` are provable, for any expressions ` ph ( x ) ` or ` A ( x ) ` in the language. The proof is by induction, so the base case is each of the primitives, which is why you will see a theorem for each of the set.mm primitive operations. The metatheorem comes with a disjoint variables assumption: every variable in ` ph ( x ) ` is assumed disjoint from ` x ` except ` x ` itself. For such a proof by induction, we must consider each of the possible forms of ` ph ( x ) ` . If it is a variable other than ` x ` , then we have ` CondEq ( x = y -> A = A ) ` or ` CondEq ( x = y -> ( ph <-> ph ) ) ` , which is provable by ~ cdeqth and reflexivity. Since we are only working with class and wff expressions, it can't be ` x ` itself in set.mm, but if it was we'd have to also prove ` CondEq ( x = y -> x = y ) ` (where _set_ equality is being used on the right). Otherwise, it is a primitive operation applied to smaller expressions. In these cases, for each setvar variable parameter to the operation, we must consider if it is equal to ` x ` or not, which yields 2^n proof obligations. Luckily, all primitive operations in set.mm have either zero or one setvar variable, so we only need to prove one statement for the non-set constructors (like implication) and two for the constructors taking a set (the forall and the class builder). In each of the primitive proofs, we are allowed to assume that ` y ` is disjoint from ` ph ( x ) ` and vice versa, because this is maintained through the induction. This is how we satisfy the disjoint variable conditions of ~ cdeqab1 and ~ cdeqab .","blocks":[{"name":"wcdeq","content":"Extend wff notation to include conditional equality. This is a technical device used in the proof that ` F/ ` is the not-free predicate, and that definitions are conservative as a result.","origin":"prop wff wcdeq(setvar s0, setvar s1, wff w0) { CondEq(s0 = s1 → w0) }","pretty":"","parent":[],"children":[]},{"name":"diff.wcdeq.s","content":"","origin":"axiom diff.wcdeq.s(setvar sBase, setvar s0, setvar s1, wff w0) {\n  |- diffsw(sBase, wcdeq(s0, s1, w0))\n  -| diffss(sBase, s0)\n  -| diffss(sBase, s1)\n  -| diffsw(sBase, w0)\n}","pretty":"axiom diff.wcdeq.s(setvar sBase, setvar s0, setvar s1, wff w0) {\n  ⊢ d(sBase, CondEq(s0 = s1 → w0))\n  ⊣ d(sBase, s0)\n  ⊣ d(sBase, s1)\n  ⊣ d(sBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wcdeq.c","content":"","origin":"axiom diff.wcdeq.c(class cBase, setvar s0, setvar s1, wff w0) {\n  |- diffcw(cBase, wcdeq(s0, s1, w0))\n  -| diffsc(s0, cBase)\n  -| diffsc(s1, cBase)\n  -| diffcw(cBase, w0)\n}","pretty":"axiom diff.wcdeq.c(class cBase, setvar s0, setvar s1, wff w0) {\n  ⊢ d(cBase, CondEq(s0 = s1 → w0))\n  ⊣ d(s0, cBase)\n  ⊣ d(s1, cBase)\n  ⊣ d(cBase, w0)\n}","parent":[],"children":[]},{"name":"diff.wcdeq.w","content":"","origin":"axiom diff.wcdeq.w(wff wBase, setvar s0, setvar s1, wff w0) {\n  |- diffww(wBase, wcdeq(s0, s1, w0))\n  -| diffsw(s0, wBase)\n  -| diffsw(s1, wBase)\n  -| diffww(wBase, w0)\n}","pretty":"axiom diff.wcdeq.w(wff wBase, setvar s0, setvar s1, wff w0) {\n  ⊢ d(wBase, CondEq(s0 = s1 → w0))\n  ⊣ d(s0, wBase)\n  ⊣ d(s1, wBase)\n  ⊣ d(wBase, w0)\n}","parent":[],"children":[]},{"name":"df-cdeq","content":"Define conditional equality. All the notation to the left of the ` <-> ` is fake; the parentheses and arrows are all part of the notation, which could equally well be written ` CondEq x y ph ` . On the right side is the actual implication arrow. The reason for this definition is to \"flatten\" the structure on the right side (whose tree structure is something like (wi (wceq (cv vx) (cv vy)) wph) ) into just (wcdeq vx vy wph). (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"axiom df-cdeq(setvar s0, setvar s1, wff w0) {\n  |- wb(wcdeq(s0, s1, w0), wi(wceq(cv(s0), cv(s1)), w0))\n}","pretty":"axiom df-cdeq(setvar s0, setvar s1, wff w0) {\n  ⊢ (CondEq(s0 = s1 → w0)↔(s0 = s1 → w0))\n}","parent":[],"children":["cdeqi","cdeqri"]},{"name":"cdeqi","content":"Deduce conditional equality. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqi(setvar s0, setvar s1, wff w0) {\n  |- wcdeq(s0, s1, w0)\n  -| wi(wceq(cv(s0), cv(s1)), w0)\n} = {\n  mpbir(wcdeq(s0, s1, w0), wi(wceq(cv(s0), cv(s1)), w0))\n  df-cdeq(s0, s1, w0)\n}","pretty":"thm cdeqi(setvar s0, setvar s1, wff w0) {\n  ⊢ CondEq(s0 = s1 → w0)\n  ⊣ (s0 = s1 → w0)\n} = {\n  mpbir(CondEq(s0 = s1 → w0), (s0 = s1 → w0))\n  df-cdeq(s0, s1, w0)\n}","parent":["mpbir","df-cdeq"],"children":["cdeqth","cdeqnot","cdeqal","cdeqab","cdeqim","cdeqcv","cdeqeq","cdeqel","bj-cdeqab"]},{"name":"cdeqri","content":"Property of conditional equality. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqri(setvar s0, setvar s1, wff w0) {\n  |- wi(wceq(cv(s0), cv(s1)), w0)\n  -| wcdeq(s0, s1, w0)\n} = {\n  mpbi(wi(wceq(cv(s0), cv(s1)), w0), wcdeq(s0, s1, w0))\n  df-cdeq(s0, s1, w0)\n}","pretty":"thm cdeqri(setvar s0, setvar s1, wff w0) {\n  ⊢ (s0 = s1 → w0)\n  ⊣ CondEq(s0 = s1 → w0)\n} = {\n  mpbi((s0 = s1 → w0), CondEq(s0 = s1 → w0))\n  df-cdeq(s0, s1, w0)\n}","parent":["mpbi","df-cdeq"],"children":["cdeqnot","cdeqal","cdeqab","cdeqal1","cdeqab1","cdeqim","cdeqeq","cdeqel","nfcdeq","bj-cdeqab"]},{"name":"cdeqth","content":"Deduce conditional equality from a theorem. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqth(setvar s0, setvar s1, wff w0) {\n  |- wcdeq(s0, s1, w0)\n  -| w0\n} = {\n  cdeqi(s0, s1, w0)\n  a1i(wceq(cv(s0), cv(s1)), w0)\n}","pretty":"thm cdeqth(setvar s0, setvar s1, wff w0) {\n  ⊢ CondEq(s0 = s1 → w0)\n  ⊣ w0\n} = {\n  cdeqi(s0, s1, w0)\n  a1i(s0 = s1, w0)\n}","parent":["cdeqi","a1i"],"children":["cdeqal1","cdeqab1","nfccdeq"]},{"name":"cdeqnot","content":"Distribute conditional equality over negation. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqnot(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wcdeq(s0, s1, wb(wn(w0), wn(w1)))\n  -| wcdeq(s0, s1, wb(w0, w1))\n} = {\n  cdeqi(s0, s1, wb(wn(w0), wn(w1)))\n  notbid(wceq(cv(s0), cv(s1)), w0, w1)\n  cdeqri(s0, s1, wb(w0, w1))\n}","pretty":"thm cdeqnot(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ CondEq(s0 = s1 →(¬ w0 ↔ ¬ w1))\n  ⊣ CondEq(s0 = s1 →(w0 ↔ w1))\n} = {\n  cdeqi(s0, s1, (¬ w0 ↔ ¬ w1))\n  notbid(s0 = s1, w0, w1)\n  cdeqri(s0, s1, (w0 ↔ w1))\n}","parent":["cdeqi","notbid","cdeqri"],"children":[]},{"name":"cdeqal","content":"Distribute conditional equality over quantification. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqal(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  |- wcdeq(s0, s1, wb(wal(s2, w0), wal(s2, w1)))\n  -| wcdeq(s0, s1, wb(w0, w1))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  cdeqi(s0, s1, wb(wal(s2, w0), wal(s2, w1)))\n  albidv(s2, wceq(cv(s0), cv(s1)), w0, w1)\n  cdeqri(s0, s1, wb(w0, w1))\n  diff.wceq.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm cdeqal(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  ⊢ CondEq(s0 = s1 →(∀(s2, w0)↔ ∀(s2, w1)))\n  ⊣ CondEq(s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  cdeqi(s0, s1, (∀(s2, w0)↔ ∀(s2, w1)))\n  albidv(s2, s0 = s1, w0, w1)\n  cdeqri(s0, s1, (w0 ↔ w1))\n  diff.wceq.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["cdeqi","albidv","cdeqri","diff.wceq.s","diff.cv.s","diffss.ex"],"children":[]},{"name":"cdeqab","content":"Distribute conditional equality over abstraction. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqab(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  |- wcdeq(s0, s1, wceq(cab(s2, w0), cab(s2, w1)))\n  -| wcdeq(s0, s1, wb(w0, w1))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  cdeqi(s0, s1, wceq(cab(s2, w0), cab(s2, w1)))\n  abbidv(s2, wceq(cv(s0), cv(s1)), w0, w1)\n  cdeqri(s0, s1, wb(w0, w1))\n  diff.wceq.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm cdeqab(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  ⊢ CondEq(s0 = s1 → { s2 | w0 } = { s2 | w1 })\n  ⊣ CondEq(s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  cdeqi(s0, s1, { s2 | w0 } = { s2 | w1 })\n  abbidv(s2, s0 = s1, w0, w1)\n  cdeqri(s0, s1, (w0 ↔ w1))\n  diff.wceq.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["cdeqi","abbidv","cdeqri","diff.wceq.s","diff.cv.s","diffss.ex"],"children":[]},{"name":"cdeqal1","content":"Distribute conditional equality over quantification. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqal1(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wcdeq(s0, s1, wb(wal(s0, w0), wal(s1, w1)))\n  -| wcdeq(s0, s1, wb(w0, w1))\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  cdeqth(s0, s1, wb(wal(s0, w0), wal(s1, w1)))\n  cbvalv(s0, s1, w0, w1)\n  cdeqri(s0, s1, wb(w0, w1))\n}","pretty":"thm cdeqal1(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ CondEq(s0 = s1 →(∀(s0, w0)↔ ∀(s1, w1)))\n  ⊣ CondEq(s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  cdeqth(s0, s1, (∀(s0, w0)↔ ∀(s1, w1)))\n  cbvalv(s0, s1, w0, w1)\n  cdeqri(s0, s1, (w0 ↔ w1))\n}","parent":["cdeqth","cbvalv","cdeqri"],"children":[]},{"name":"cdeqab1","content":"Distribute conditional equality over abstraction. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqab1(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wcdeq(s0, s1, wceq(cab(s0, w0), cab(s1, w1)))\n  -| wcdeq(s0, s1, wb(w0, w1))\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  cdeqth(s0, s1, wceq(cab(s0, w0), cab(s1, w1)))\n  cbvab(s0, s1, w0, w1)\n  nfv(s1, w0)\n  nfv(s0, w1)\n  cdeqri(s0, s1, wb(w0, w1))\n}","pretty":"thm cdeqab1(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ CondEq(s0 = s1 → { s0 | w0 } = { s1 | w1 })\n  ⊣ CondEq(s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  cdeqth(s0, s1, { s0 | w0 } = { s1 | w1 })\n  cbvab(s0, s1, w0, w1)\n  nfv(s1, w0)\n  nfv(s0, w1)\n  cdeqri(s0, s1, (w0 ↔ w1))\n}","parent":["cdeqth","cbvab","nfv","cdeqri"],"children":[]},{"name":"cdeqim","content":"Distribute conditional equality over implication. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqim(setvar s0, setvar s1, wff w0, wff w1, wff w2, wff w3) {\n  |- wcdeq(s0, s1, wb(wi(w0, w1), wi(w2, w3)))\n  -| wcdeq(s0, s1, wb(w0, w2))\n  -| wcdeq(s0, s1, wb(w1, w3))\n} = {\n  cdeqi(s0, s1, wb(wi(w0, w1), wi(w2, w3)))\n  imbi12d(wceq(cv(s0), cv(s1)), w0, w1, w2, w3)\n  cdeqri(s0, s1, wb(w0, w2))\n  cdeqri(s0, s1, wb(w1, w3))\n}","pretty":"thm cdeqim(setvar s0, setvar s1, wff w0, wff w1, wff w2, wff w3) {\n  ⊢ CondEq(s0 = s1 →((w0 → w1)↔(w2 → w3)))\n  ⊣ CondEq(s0 = s1 →(w0 ↔ w2))\n  ⊣ CondEq(s0 = s1 →(w1 ↔ w3))\n} = {\n  cdeqi(s0, s1, ((w0 → w1)↔(w2 → w3)))\n  imbi12d(s0 = s1, w0, w1, w2, w3)\n  cdeqri(s0, s1, (w0 ↔ w2))\n  cdeqri(s0, s1, (w1 ↔ w3))\n}","parent":["cdeqi","imbi12d","cdeqri"],"children":[]},{"name":"cdeqcv","content":"Conditional equality for set-to-class promotion. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqcv(setvar s0, setvar s1) {\n  |- wcdeq(s0, s1, wceq(cv(s0), cv(s1)))\n} = {\n  cdeqi(s0, s1, wceq(cv(s0), cv(s1)))\n  id(wceq(cv(s0), cv(s1)))\n}","pretty":"thm cdeqcv(setvar s0, setvar s1) {\n  ⊢ CondEq(s0 = s1 → s0 = s1)\n} = {\n  cdeqi(s0, s1, s0 = s1)\n  id(s0 = s1)\n}","parent":["cdeqi","id"],"children":[]},{"name":"cdeqeq","content":"Distribute conditional equality over equality. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqeq(setvar s0, setvar s1, class c0, class c1, class c2, class c3) {\n  |- wcdeq(s0, s1, wb(wceq(c0, c1), wceq(c2, c3)))\n  -| wcdeq(s0, s1, wceq(c0, c2))\n  -| wcdeq(s0, s1, wceq(c1, c3))\n} = {\n  cdeqi(s0, s1, wb(wceq(c0, c1), wceq(c2, c3)))\n  eqeq12d(c0, c1, c2, c3, wceq(cv(s0), cv(s1)))\n  cdeqri(s0, s1, wceq(c0, c2))\n  cdeqri(s0, s1, wceq(c1, c3))\n}","pretty":"thm cdeqeq(setvar s0, setvar s1, class c0, class c1, class c2, class c3) {\n  ⊢ CondEq(s0 = s1 →(c0 = c1 ↔ c2 = c3))\n  ⊣ CondEq(s0 = s1 → c0 = c2)\n  ⊣ CondEq(s0 = s1 → c1 = c3)\n} = {\n  cdeqi(s0, s1, (c0 = c1 ↔ c2 = c3))\n  eqeq12d(c0, c1, c2, c3, s0 = s1)\n  cdeqri(s0, s1, c0 = c2)\n  cdeqri(s0, s1, c1 = c3)\n}","parent":["cdeqi","eqeq12d","cdeqri"],"children":[]},{"name":"cdeqel","content":"Distribute conditional equality over elementhood. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm cdeqel(setvar s0, setvar s1, class c0, class c1, class c2, class c3) {\n  |- wcdeq(s0, s1, wb(wcel(c0, c1), wcel(c2, c3)))\n  -| wcdeq(s0, s1, wceq(c0, c2))\n  -| wcdeq(s0, s1, wceq(c1, c3))\n} = {\n  cdeqi(s0, s1, wb(wcel(c0, c1), wcel(c2, c3)))\n  eleq12d(c0, c1, c2, c3, wceq(cv(s0), cv(s1)))\n  cdeqri(s0, s1, wceq(c0, c2))\n  cdeqri(s0, s1, wceq(c1, c3))\n}","pretty":"thm cdeqel(setvar s0, setvar s1, class c0, class c1, class c2, class c3) {\n  ⊢ CondEq(s0 = s1 →(c0 ∈ c1 ↔ c2 ∈ c3))\n  ⊣ CondEq(s0 = s1 → c0 = c2)\n  ⊣ CondEq(s0 = s1 → c1 = c3)\n} = {\n  cdeqi(s0, s1, (c0 ∈ c1 ↔ c2 ∈ c3))\n  eleq12d(c0, c1, c2, c3, s0 = s1)\n  cdeqri(s0, s1, c0 = c2)\n  cdeqri(s0, s1, c1 = c3)\n}","parent":["cdeqi","eleq12d","cdeqri"],"children":["nfccdeq"]},{"name":"nfcdeq","content":"If we have a conditional equality proof, where ` ph ` is ` ph ( x ) ` and ` ps ` is ` ph ( y ) ` , and ` ph ( x ) ` in fact does not have ` x ` free in it according to ` F/ ` , then ` ph ( x ) <-> ph ( y ) ` unconditionally. This proves that ` F/ x ph ` is actually a not-free predicate. (Contributed by Mario Carneiro, 11-Aug-2016.)","origin":"thm nfcdeq(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wb(w0, w1)\n  -| wnf(s0, w0)\n  -| wcdeq(s0, s1, wb(w0, w1))\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  a1ii(wb(w0, w1), diffsw(s1, w0))\n  bitr3i(w0, w1, wsb(s1, s0, w0))\n  sbf(s1, s0, w0)\n  sbie(s1, s0, w0, w1)\n  nfv(s0, w1)\n  cdeqri(s0, s1, wb(w0, w1))\n}","pretty":"thm nfcdeq(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (w0 ↔ w1)\n  ⊣ F/(s0, w0)\n  ⊣ CondEq(s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  a1ii((w0 ↔ w1), d(s1, w0))\n  bitr3i(w0, w1, [s1 / s0]w0)\n  sbf(s1, s0, w0)\n  sbie(s1, s0, w0, w1)\n  nfv(s0, w1)\n  cdeqri(s0, s1, (w0 ↔ w1))\n}","parent":["a1ii","bitr3i","sbf","sbie","nfv","cdeqri"],"children":["nfccdeq"]},{"name":"nfccdeq","content":"Variation of ~ nfcdeq for classes. (Contributed by Mario Carneiro, 11-Aug-2016.) Avoid ~ ax-11 . (Revised by Gino Giotto, 19-May-2023.)","origin":"thm nfccdeq(setvar s0, setvar s1, class c0, class c1) {\n  |- wceq(c0, c1)\n  -| wnfc(s0, c0)\n  -| wcdeq(s0, s1, wceq(c0, c1))\n  -| diffsc(s0, c1)\n  -| diffsc(s1, c0)\n} = {\n  eqriv(hs0, c0, c1)\n  nfcdeq(s0, s1, wcel(cv(hs0), c0), wcel(cv(hs0), c1))\n  nfcriv(s0, hs0, c0)\n  cdeqel(s0, s1, cv(hs0), c0, cv(hs0), c1)\n  cdeqth(s0, s1, wceq(cv(hs0), cv(hs0)))\n  eqid(cv(hs0))\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.wcel.s(s0, cv(hs0), c1)\n  diff.cv.s(s0, hs0)\n  diff.wcel.s(s1, cv(hs0), c0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm nfccdeq(setvar s0, setvar s1, class c0, class c1) {\n  ⊢ c0 = c1\n  ⊣ F/(s0, c0)\n  ⊣ CondEq(s0 = s1 → c0 = c1)\n  ⊣ d(s0, c1)\n  ⊣ d(s1, c0)\n} = {\n  eqriv(hs0, c0, c1)\n  nfcdeq(s0, s1, hs0 ∈ c0, hs0 ∈ c1)\n  nfcriv(s0, hs0, c0)\n  cdeqel(s0, s1, hs0, c0, hs0, c1)\n  cdeqth(s0, s1, hs0 = hs0)\n  eqid(hs0)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.wcel.s(s0, hs0, c1)\n  diff.cv.s(s0, hs0)\n  diff.wcel.s(s1, hs0, c0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["eqriv","nfcdeq","nfcriv","cdeqel","cdeqth","eqid","diff.hs0.c","diff.wcel.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":[]}]}