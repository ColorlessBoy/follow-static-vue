{"index":1565,"title":"Basic Properties of Set Recursion","content":"Symbols in this section: All the symbols used in the definition of ` setrecs ( F ) ` are explained in the comment of ~ df-setrecs . The class ` Y ` is explained in the comment of ~ setrec1lem1 . Glossaries of symbols used in individual proofs, or used differently in different proofs, are in the comments of those proofs.","blocks":[{"name":"csetrecs","content":"Extend class notation to include a set defined by transfinite recursion.","origin":"prop class csetrecs(class c0) { setrecs(c0) }","pretty":"","parent":[],"children":[]},{"name":"diff.csetrecs.s","content":"","origin":"axiom diff.csetrecs.s(setvar sBase, class c0) {\n  |- diffsc(sBase, csetrecs(c0))\n  -| diffsc(sBase, c0)\n}","pretty":"axiom diff.csetrecs.s(setvar sBase, class c0) {\n  ⊢ d(sBase, setrecs(c0))\n  ⊣ d(sBase, c0)\n}","parent":[],"children":[]},{"name":"diff.csetrecs.c","content":"","origin":"axiom diff.csetrecs.c(class cBase, class c0) {\n  |- diffcc(cBase, csetrecs(c0))\n  -| diffcc(cBase, c0)\n}","pretty":"axiom diff.csetrecs.c(class cBase, class c0) {\n  ⊢ d(cBase, setrecs(c0))\n  ⊣ d(cBase, c0)\n}","parent":[],"children":[]},{"name":"diff.csetrecs.w","content":"","origin":"axiom diff.csetrecs.w(wff wBase, class c0) {\n  |- diffcw(csetrecs(c0), wBase)\n  -| diffcw(c0, wBase)\n}","pretty":"axiom diff.csetrecs.w(wff wBase, class c0) {\n  ⊢ d(setrecs(c0), wBase)\n  ⊣ d(c0, wBase)\n}","parent":[],"children":[]},{"name":"df-setrecs","content":"Define a class ` setrecs ( F ) ` by transfinite recursion, where ` ( F `` x ) ` is the set of new elements to add to the class given the set ` x ` of elements in the class so far. We do not need a base case, because we can start with the empty set, which is vacuously a subset of ` setrecs ( F ) ` . The goal of this definition is to construct a class fulfilling theorems ~ setrec1 and ~ setrec2v , which give a more intuitive idea of the meaning of ` setrecs ` . Unlike ` wrecs ` , ` setrecs ` is well-defined for any ` F ` and meaningful for any function ` F ` . For example, see theorem ~ onsetrec for how the class ` On ` is defined recursively using the successor function. The definition works by building subsets of the desired class and taking the union of those subsets. To find such a collection of subsets, consider an arbitrary set ` z ` , and consider the result when applying ` F ` to any subset ` w C_ z ` . Remember that ` F ` can be any function, and in general we are interested in functions that give outputs that are larger than their inputs, so we have no reason to expect the outputs to be within ` z ` . However, if we restrict the domain of ` F ` to a given set ` y ` , the resulting range will be a set. Therefore, with this restricted ` F ` , it makes sense to consider sets ` z ` that are closed under ` F ` applied to its subsets. Now we can test whether a given set ` y ` is recursively generated by ` F ` . If every set ` z ` that is closed under ` F ` contains ` y ` , that means that every member of ` y ` must eventually be generated by ` F ` . On the other hand, if some such ` z ` does not contain a certain element of ` y ` , then that element can be avoided even if we apply ` F ` in every possible way to previously generated elements. Note that such an omitted element might be eventually recursively generated by ` F ` , but not through the elements of ` y ` . In this case, ` y ` would fail the condition in the definition, but the omitted element would still be included in some larger ` y ` . For example, if ` F ` is the successor function, the set ` { (/) , 2o } ` would fail the condition since ` 2o ` is not an element of the successor of ` (/) ` or ` { (/) } ` . Remember that we are applying ` F ` to subsets of ` y ` , not elements of ` y ` . In fact, even the set ` { 1o } ` fails the condition, since the only subset of previously generated elements is ` (/) ` , and ` suc (/) ` does not have ` 1o ` as an element. However, we can let ` y ` be any ordinal, since each of its elements is generated by starting with ` (/) ` and repeatedly applying the successor function. A similar definition I initially used for ` setrecs ( F ) ` was ` setrecs ( F ) = U. ran recs ( ( g e. _V |-> ( F `` U. ran g ) ) ) ` . I had initially tried and failed to find an elementary definition, and I had proven theorems analogous to ~ setrec1 and ~ setrec2v using the old definition before I found the new one. I decided to change definitions for two reasons. First, as John Horton Conway noted in the Appendix to Part Zero of On Numbers and Games, mathematicians should not be caught up in any particular formalization, such as ZF set theory. Instead, they should work under whatever framework best suits the problem, and the formal bases used for different problems can be shown to be equivalent. Thus, Conway preferred defining surreal numbers as equivalence classes of surreal number forms, rather than sign-expansions. Although sign-expansions are easier to implement in ZF set theory, Conway argued that \"formalisation within some particular axiomatic set theory is irrelevant\". Furthermore, one of the most remarkable properties of the theory of surreal numbers is that it generates so much from almost nothing. Using sign-expansions as the formal definition destroys the beauty of surreal numbers, because ordinals are already built in. For this reason, I replaced the old definition of ` setrecs ` , which also relied heavily on ordinal numbers. On the other hand, both surreal numbers and the elementary definition of ` setrecs ` immediately generate the ordinal numbers from a (relatively) very simple set-theoretical basis. Second, although it is still complicated to formalize the theory of recursively generated sets within ZF set theory, it is actually simpler and more natural to do so with set theory directly than with the theory of ordinal numbers. As Conway wrote, indexing the \"birthdays\" of sets is and should be unnecessary. Using an elementary definition for ` setrecs ` removes the reliance on the previously developed theory of ordinal numbers, allowing proofs to be simpler and more direct. Formalizing surreal numbers within Metamath is probably still not in the spirit of Conway. He said that \"attempts to force arbitrary theories into a single formal straitjacket... produce unnecessarily cumbrous and inelegant contortions.\" Nevertheless, Metamath has proven to be much more versatile than it seems at first, and I think the theory of surreal numbers can be natural while fitting well into the Metamath framework. The difficulty in writing a definition in Metamath for ` setrecs ( F ) ` is that the necessary properties to prove are self-referential (see ~ setrec1 and ~ setrec2v ), so we cannot simply write the properties we want inside a class abstraction as with most definitions. As noted in the comment of ~ df-rdg , this is not actually a requirement of the Metamath language, but we would like to be able to eliminate all definitions by direct mechanical substitution. We cannot define ` setrecs ` using a class abstraction directly, because nothing about its individual elements tells us whether they are in the set. We need to know about previous elements first. One way of getting around this problem without indexing is by defining ` setrecs ( F ) ` as a union or intersection of suitable sets. Thus, instead of using a class abstraction for the elements of ` setrecs ( F ) ` , which seems to be impossible, we can use a class abstraction for supersets or subsets of ` setrecs ( F ) ` , which \"know\" about multiple individual elements at a time. Note that we cannot define ` setrecs ( F ) ` as an intersection of sets, because in general it is a proper class, so any supersets would also be proper classes. However, a proper class can be a union of sets, as long as the collection of such sets is a proper class. Therefore, it is feasible to define ` setrecs ( F ) ` as a union of a class abstraction. If ` setrecs ( F ) = U. A ` , the elements of A must be subsets of ` setrecs ( F ) ` which together include everything recursively generated by ` F ` . We can do this by letting ` A ` be the class of sets ` x ` whose elements are all recursively generated by ` F ` . One necessary condition is that each element of a given ` x e. A ` must be generated by ` F ` when applied to a previous element ` y e. A ` . In symbols, ` A. x e. A E. y e. A ( y C_ x /\\ x C_ ( F `` y ) ) } ` . However, this is not sufficient. All fixed points ` x ` of ` F ` will satisfy this condition whether they should be in ` setrecs ( F ) ` or not. If we replace the subset relation with the proper subset relation, ` x ` cannot be the empty set, even though the empty set should be in ` A ` . Therefore this condition cannot be used in the definition, even if we can find a way to avoid making it circular. A better strategy is to find a necessary and sufficient condition for all the elements of a set ` y e. A ` to be generated by ` F ` when applied only to sets of previously generated elements within ` y ` . For example, taking ` F ` to be the successor function, we can let ` A = On ` rather than ` ~P On ` , and we will still have ` U. A = On ` as required. This gets rid of the circularity of the definition, since we should have a condition to test whether a given set ` y ` is in ` A ` without knowing about any of the other elements of ` A ` . The definition I ended up using accomplishes this using induction: ` A ` is defined as the class of sets ` y ` for which a sort of induction on the elements of ` y ` holds. However, when creating a definition for ` setrecs ` that did not rely on ordinal numbers, I tried at first to write a definition using the well-founded relation predicate, ` Fr ` . I thought that this would be simple to do once I found a suitable definition using induction, just as the least- element principle is equivalent to induction on the positive integers. If we let ` R = { <. a , b >. | ( F `` a ) C_ b } ` , then ` ( R Fr A <-> A. x ( ( x C_ A /\\ x =/= (/) ) ` ` -> E. y e. x A. z e. x -. ( F `` z ) C_ y ) ) ` . On 22-Jul-2020 I came up with the following definition (Version 1) phrased in terms of induction: ` U. { y | A. z ` ` ( A. w ( w C_ y -> ( w e. z -> ( F `` w ) e. z ) ) -> y e. z ) } ` In Aug-2020 I came up with an equivalent definition with the goal of phrasing it in terms of the relation ` Fr ` . It is the contrapositive of the previous one with ` z ` replaced by its complement. ` U. { y | A. z ` ` ( y e. z -> E. w ( w C_ y /\\ ( F `` w ) e. z /\\ -. w e. z ) ) } ` These definitions didn't work because the induction didn't \"get off the ground.\" If ` z ` does not contain the empty set, the condition ` ( A. w ... y e. z ` fails, so ` y = (/) ` doesn't get included in ` A ` even though it should. This could be fixed by adding the base case as a separate requirement, but the subtler problem would remain that rather than a set of \"acceptable\" sets, what we really need is a collection ` z ` of all individuals that have been generated so far. So one approach is to replace every occurence of ` e. z ` with ` C_ z ` , making ` z ` a set of individuals rather than a family of sets. That solves this problem, but it complicates the foundedness version of the definition, which looked cleaner in Version 1. There was another problem with Version 1. If we let ` F ` be the power set function, then the induction in the inductive version works for ` z ` being the class of transitive sets, restricted to subsets of ` y ` . Therefore, ` y ` must be transitive by definition of ` z ` . This doesn't affect the union of all such ` y ` , but it may or may not be desirable. The problem is that ` F ` is only applied to transitive sets, because of the strong requirement ` w e. z ` , so the definition requires the additional constraint ` ( a C_ b -> ( F ` a ) C_ ( F ` b ) ) ` in order to work. This issue can also be avoided by replacing ` e. z ` with ` C_ z ` . The induction version of the result is used in the final definition. Version 2: (18-Aug-2020) Induction: ` U. { y | A. z ` ` ( A. w ( w C_ y -> ( w C_ z -> ( F `` w ) C_ z ) ) -> y C_ z ) } ` Foundedness: ` U. { y | A. z ( y i^i z =/= (/) -> ` ` E. w ( w C_ y /\\ w i^i z = (/) /\\ ( F `` w ) i^i z =/= (/) ) ) } ` In the induction version, not only does ` z ` include all the elements of ` y ` , but it must include the elements of ` ( F `` w ) ` for ` w C_ ( y i^i z ) ` even if those elements of ` ( F `` w ) ` are not in ` y ` . We shouldn't care about any of the elements of ` z ` outside ` y ` , but this detail doesn't affect the correctness of the definition. If we replaced ` ( F `` w ) ` in the definition by ` ( ( F `` w ) i^i y ) ` , we would get the same class for ` setrecs ( F ) ` . Suppose we could find a ` z ` for which the condition fails for a given ` y ` under the changed definition. Then the antecedent would be true, but ` y C_ z ` would be false. We could then simply add all elements of ` ( F `` w ) ` outside of ` y ` for any ` w C_ y ` , which we can do because all the classes involved are sets. This is not trivial and requires the axioms of union, power set, and replacement. However, the expanded ` z ` fails the condition under the Metamath definition. The other direction is easier. If a certain ` z ` fails the Metamath definition, then all ` ( F `` w ) C_ z ` for ` w C_ ( y i^i z ) ` , and in particular ` ( ( F `` w ) i^i y ) C_ z ` . The foundedness version is starting to look more like ~ ax-reg ! We want to take advantage of the preexisting relation ` Fr ` , which seems closely related to our foundedness definition. Since we only care about the elements of ` z ` which are subsets of ` y ` , we can restrict ` z ` to ` y ` in the foundedness definition. Furthermore, instead of quantifying over ` w ` , quantify over the elements ` v e. z ` overlapping with ` w ` . Versions 3, 4, and 5 are all equivalent to Version 2. Version 3 - Foundedness (5-Sep-2020): ` U. { y | A. z ( ( z C_ y /\\ z =/= (/) ) ` ` -> E. v e. z E. w ( w C_ y /\\ w i^i z = (/) /\\ v e. ( F `` w ) ) ) } ` Now, if we replace ` ( F `` w ) ` by ` ( ( F `` w ) i^i y ) ` , we do not change the definition. We already know that ` v e. y ` since ` v e. z ` and ` z C_ y ` . All we need to show in order to prove that this change leads to an equivalent definition is to find To make our definition look exactly like ~ df-fr , we add another variable ` u ` representing the nonexistent element of ` w ` in ` z ` . Version 4 - Foundedness (6-Sep-2020): ` U. { y | A. z ( ( z C_ y /\\ z =/= (/) ) -> ` ` E. v e. z E. w A. u e. z ( w C_ y /\\ -. u e. w /\\ v e. ( F `` w ) ) ` This is so close to ~ df-fr ; the only change needed is to switch ` E. w ` with ` A. u e. z ` . Unfortunately, I couldn't find any way to switch the quantifiers without interfering with the definition. Maybe there is a definition equivalent to this one that uses ` Fr ` , but I couldn't find one. Yet, we can still find a remarkable similarity between Foundedness Version 2 and ~ ax-reg . Rather than a disjoint element of ` z ` , there's a disjoint coverer of an element of ` z ` . Finally, here's a different dead end I followed: To clean up our foundedness definition, we keep ` z ` as a family of sets ` y ` but allow ` w ` to be any subset of ` U. z ` in the induction. With this stronger induction, we can also allow for the stronger requirement ` ~P y C_ z ` rather than only ` y e. z ` . This will help improve the foundedness version. Version 1.1 (28-Aug-2020) Induction: ` U. { y | A. z ( A. w ` ` ( w C_ y -> ( w C_ U. z -> ( F `` w ) e. z ) ) -> ~P y C_ z ) } ` Foundedness: ` U. { y | A. z ( E. a ( a C_ y /\\ a e. z ) ` ` -> E. w ( w C_ y /\\ w i^i |^| z = (/) /\\ ( F `` w ) e. z ) ) } ` ( Edit (Aug 31) - this isn't true! Nothing forces the subset of an element of ` z ` to be in ` z ` . Version 2 does not have this issue. ) Similarly, we could allow ` w ` to be any subset of any element of ` z ` rather than any subset of ` U. z ` . I think this has the same problem. We want to take advantage of the preexisting relation ` Fr ` , which seems closely related to our foundedness definition. Since we only care about the elements of ` z ` which are subsets of ` y ` , we can restrict ` z ` to ` ~P y ` in the foundedness definition: Version 1.2 (31-Aug-2020) Foundedness: ` U. { y | A. z ( ( z C_ ~P y /\\ z =/= (/) ) ` ` -> E. w ( w e. ~P y /\\ w i^i |^| z = (/) /\\ ( F `` w ) e. z ) ) } ` Now this looks more like ~ df-fr ! The last step necessary to be able to use ` Fr ` directly in our definition is to replace ` ( F `` w ) ` with its own setvar variable, corresponding to ` y ` in ~ df-fr . This definition is incorrect, though, since there's nothing forcing the subset of an element of ` z ` to be in ` z ` . Version 1.3 (31-Aug-2020) Induction: ` U. { y | A. z ( A. w ( w C_ y ` ` -> ( w C_ U. z -> ( w e. z /\\ ( F `` w ) e. z ) ) ) -> ~P y C_ z ) } ` Foundedness: ` U. { y | A. z ( ( z C_ ~P y /\\ z =/= (/) ) -> E. w ( w e. ~P y ` ` /\\ w i^i |^| z = (/) /\\ ( w e. z \\/ ( F `` w ) e. z ) ) ) } ` ` z ` must contain the supersets of each of its elements in the foundedness version, and we can't make any restrictions on ` z ` or ` F ` , so this doesn't work. Let's try letting R be the covering relation ` R = { <. a , b >. | b e. ( F `` a ) } ` to solve the transitivity issue (i.e. that if ` F ` is the power set relation, ` A ` consists only of transitive sets). The set ` ( F `` w ) ` corresponds to the variable ` y ` in ~ df-fr . Thus, in our case, ~ df-fr is equivalent to ` ( R Fr A <-> A. z ( ( z C_ A /\\ z =/= (/) ) ` ` -> E. w ( ( F `` w ) e. z /\\ -. E. v e. z v R ( F `` w ) ) ) ` . Substituting our relation ` R ` gives ` ( R Fr A <-> A. z ( ( z C_ A /\\ z =/= (/) ) -> ` ` E. w ( ( F `` w ) e. z /\\ -. E. v e. z ( F `` w ) e. ( F `` v ) ) ) ` This doesn't work for non-injective ` F ` because we need all ` z ` to be straddlers, but we don't necessarily need all-straddlers; loops within z are fine for non-injective F. Consider the foundedness form of Version 1. We want to show ` -. w e. z <-> A. v e. z -. v R ( F `` w ) ` so we can replace one with the other. Negate both sides: ` w e. z <-> E. v e. z v R ( F `` w ) ` If ` F ` is injective, then we should be able to pick a suitable R, being careful about the above problem for some F (for example z = transitivity) when changing the antecedent y e. z' to z =/= (/). If we're clever, we can get rid of the injectivity requirement. The forward direction of the above equivalence always holds, but the key is that although the backwards direction doesn't hold in general, we can always find some z' where it doesn't work for ` w ` itself. If there exists a z' where the version with the w condition fails, then there exists a z' where the version with the v condition also fails. However, Version 1 is not a correct definition, so this doesn't work either. (Contributed by Emmett Weisz, 18-Aug-2020.) (New usage is discouraged.)","origin":"axiom df-setrecs(setvar s0, setvar s1, setvar s2, class c0) {\n  |- wceq(csetrecs(c0), cuni(cab(s0, wal(s1, wi(wal(s2, wi(wss(cv(s2), cv(s0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c0, cv(s2)), cv(s1))))), wss(cv(s0), cv(s1)))))))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffss(s0, s1)\n  -| diffsc(s2, c0)\n  -| diffsc(s0, c0)\n  -| diffsc(s1, c0)\n}","pretty":"axiom df-setrecs(setvar s0, setvar s1, setvar s2, class c0) {\n  ⊢ setrecs(c0)= ⋃ { s0 | ∀(s1,(∀(s2,(s2 ⊆ s0 →(s2 ⊆ s1 →(c0 ` s2)⊆ s1)))→ s0 ⊆ s1))}\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s0, s1)\n  ⊣ d(s2, c0)\n  ⊣ d(s0, c0)\n  ⊣ d(s1, c0)\n}","parent":[],"children":["setrecseq","nfsetrecs","setrec1","setrec2fun","setrec2"]},{"name":"setrecseq","content":"Equality theorem for set recursion. (Contributed by Emmett Weisz, 17-Feb-2021.)","origin":"thm setrecseq(class c0, class c1) {\n  |- wi(wceq(c0, c1), wceq(csetrecs(c0), csetrecs(c1)))\n} = {\n  3eqtr4g(csetrecs(c0), csetrecs(c1), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), wceq(c0, c1))\n  unieqd(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), wceq(c0, c1))\n  abbidv(hs1, wceq(c0, c1), wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))), wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))\n  albidv(hs2, wceq(c0, c1), wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))), wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))\n  imbi1d(wceq(c0, c1), wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)), wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2))))))\n  albidv(hs0, wceq(c0, c1), wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2)))), wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2)))))\n  imbi2d(wceq(c0, c1), wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2))))\n  imbi2d(wceq(c0, c1), wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2)), wss(cfv(c1, cv(hs0)), cv(hs2)))\n  sseq1d(cfv(c0, cv(hs0)), cv(hs2), cfv(c1, cv(hs0)), wceq(c0, c1))\n  fveq1(c0, c1, cv(hs0))\n  df-setrecs(hs1, hs2, hs0, c0)\n  df-setrecs(hs1, hs2, hs0, c1)\n  diff.hs1.w(wceq(c0, c1))\n  diff.hs2.w(wceq(c0, c1))\n  diff.hs0.w(wceq(c0, c1))\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n  diff.hs2.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c1)\n  diff.hs2.c(c1)\n}","pretty":"thm setrecseq(class c0, class c1) {\n  ⊢ (c0 = c1 → setrecs(c0)= setrecs(c1))\n} = {\n  3eqtr4g(setrecs(c0), setrecs(c1), ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c1 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, c0 = c1)\n  unieqd({ hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c1 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, c0 = c1)\n  abbidv(hs1, c0 = c1, ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2)), ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c1 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2)))\n  albidv(hs2, c0 = c1, (∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2), (∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c1 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))\n  imbi1d(c0 = c1, ∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2))), hs1 ⊆ hs2, ∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c1 ` hs0)⊆ hs2))))\n  albidv(hs0, c0 = c1, (hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)), (hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c1 ` hs0)⊆ hs2)))\n  imbi2d(c0 = c1, hs0 ⊆ hs1, (hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2), (hs0 ⊆ hs2 →(c1 ` hs0)⊆ hs2))\n  imbi2d(c0 = c1, hs0 ⊆ hs2, (c0 ` hs0)⊆ hs2, (c1 ` hs0)⊆ hs2)\n  sseq1d((c0 ` hs0), hs2, (c1 ` hs0), c0 = c1)\n  fveq1(c0, c1, hs0)\n  df-setrecs(hs1, hs2, hs0, c0)\n  df-setrecs(hs1, hs2, hs0, c1)\n  diff.hs1.w(c0 = c1)\n  diff.hs2.w(c0 = c1)\n  diff.hs0.w(c0 = c1)\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n  diff.hs2.c(c0)\n  diff.hs0.c(c1)\n  diff.hs1.c(c1)\n  diff.hs2.c(c1)\n}","parent":["3eqtr4g","unieqd","abbidv","albidv","imbi1d","imbi2d","sseq1d","fveq1","df-setrecs","diff.hs1.w","diff.hs2.w","diff.hs0.w","diff.hs1.s","diff.hs2.s","diff.hs0.c","diff.hs1.c","diff.hs2.c"],"children":[]},{"name":"nfsetrecs","content":"Bound-variable hypothesis builder for ` setrecs ` . (Contributed by Emmett Weisz, 21-Oct-2021.)","origin":"thm nfsetrecs(setvar s0, class c0) {\n  |- wnfc(s0, csetrecs(c0))\n  -| wnfc(s0, c0)\n} = {\n  nfcxfr(s0, csetrecs(c0), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))\n  df-setrecs(hs1, hs2, hs0, c0)\n  nfuni(s0, cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  nfab(s0, hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))\n  nfal(s0, hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))\n  nfim(s0, wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))\n  nfal(s0, hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2)))))\n  nfim(s0, wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))\n  nfv(s0, wss(cv(hs0), cv(hs1)))\n  nfim(s0, wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2)))\n  nfv(s0, wss(cv(hs0), cv(hs2)))\n  nfss(s0, cfv(c0, cv(hs0)), cv(hs2))\n  nffv(s0, c0, cv(hs0))\n  nfcv(s0, cv(hs0))\n  nfcv(s0, cv(hs2))\n  nfv(s0, wss(cv(hs1), cv(hs2)))\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n  diff.hs2.c(c0)\n  diff.wss.s(s0, cv(hs0), cv(hs1))\n  diff.wss.s(s0, cv(hs0), cv(hs2))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wss.s(s0, cv(hs1), cv(hs2))\n  diff.cv.s(s0, hs1)\n  diffss.ex(s0, hs1)\n  diff.hs1.s(s0)\n  diff.cv.s(s0, hs2)\n  diffss.ex(s0, hs2)\n  diff.hs2.s(s0)\n}","pretty":"thm nfsetrecs(setvar s0, class c0) {\n  ⊢ F/(s0, setrecs(c0))\n  ⊣ F/(s0, c0)\n} = {\n  nfcxfr(s0, setrecs(c0), ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  df-setrecs(hs1, hs2, hs0, c0)\n  nfuni(s0, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  nfab(s0, hs1, ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2)))\n  nfal(s0, hs2, (∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))\n  nfim(s0, ∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2))), hs1 ⊆ hs2)\n  nfal(s0, hs0, (hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))\n  nfim(s0, hs0 ⊆ hs1, (hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2))\n  nfv(s0, hs0 ⊆ hs1)\n  nfim(s0, hs0 ⊆ hs2, (c0 ` hs0)⊆ hs2)\n  nfv(s0, hs0 ⊆ hs2)\n  nfss(s0, (c0 ` hs0), hs2)\n  nffv(s0, c0, hs0)\n  nfcv(s0, hs0)\n  nfcv(s0, hs2)\n  nfv(s0, hs1 ⊆ hs2)\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c0)\n  diff.hs1.c(c0)\n  diff.hs2.c(c0)\n  diff.wss.s(s0, hs0, hs1)\n  diff.wss.s(s0, hs0, hs2)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.wss.s(s0, hs1, hs2)\n  diff.cv.s(s0, hs1)\n  diffss.ex(s0, hs1)\n  diff.hs1.s(s0)\n  diff.cv.s(s0, hs2)\n  diffss.ex(s0, hs2)\n  diff.hs2.s(s0)\n}","parent":["nfcxfr","df-setrecs","nfuni","nfab","nfal","nfim","nfv","nfss","nffv","nfcv","diff.hs1.s","diff.hs2.s","diff.hs0.c","diff.hs1.c","diff.hs2.c","diff.wss.s","diff.cv.s","diffss.ex","diff.hs0.s"],"children":[]},{"name":"setrec1lem1","content":"Lemma for ~ setrec1 . This is a utility theorem showing the equivalence of the statement ` X e. Y ` and its expanded form. The proof uses ~ elabg and equivalence theorems. Variable ` Y ` is the class of sets ` y ` that are recursively generated by the function ` F ` . In other words, ` y e. Y ` iff by starting with the empty set and repeatedly applying ` F ` to subsets ` w ` of our set, we will eventually generate all the elements of ` Y ` . In this theorem, ` X ` is any element of ` Y ` , and ` V ` is any class. (Contributed by Emmett Weisz, 16-Oct-2020.) (New usage is discouraged.)","origin":"thm setrec1lem1(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2, class c3, wff w0) {\n  |- wi(w0, wb(wcel(c0, c1), wal(s0, wi(wal(s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(c0, cv(s0))))))\n  -| wceq(c1, cab(s2, wal(s0, wi(wal(s1, wi(wss(cv(s1), cv(s2)), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(cv(s2), cv(s0))))))\n  -| wi(w0, wcel(c0, c3))\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsc(s0, c0)\n  -| diffsc(s1, c0)\n  -| diffsc(s2, c0)\n  -| diffsc(s2, c2)\n} = {\n  syl(w0, wb(wcel(c0, c1), wal(s0, wi(wal(s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(c0, cv(s0))))), wcel(c0, c3))\n  elab2g(s2, c0, c3, c1, wal(s0, wi(wal(s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(c0, cv(s0)))), wal(s0, wi(wal(s1, wi(wss(cv(s1), cv(s2)), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(cv(s2), cv(s0)))))\n  albidv(s0, wceq(cv(s2), c0), wi(wal(s1, wi(wss(cv(s1), cv(s2)), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(cv(s2), cv(s0))), wi(wal(s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(c0, cv(s0))))\n  imbi12d(wceq(cv(s2), c0), wal(s1, wi(wss(cv(s1), cv(s2)), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(cv(s2), cv(s0)), wal(s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(c0, cv(s0)))\n  albidv(s1, wceq(cv(s2), c0), wi(wss(cv(s1), cv(s2)), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0)))), wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0)))))\n  imbi1d(wceq(cv(s2), c0), wss(cv(s1), cv(s2)), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))), wss(cv(s1), c0))\n  sseq2(cv(s2), c0, cv(s1))\n  sseq1(cv(s2), c0, cv(s0))\n  diff.wal.s(s2, s0, wi(wal(s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(c0, cv(s0))))\n  diff.wi.s(s2, wal(s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))), wss(c0, cv(s0)))\n  diff.wal.s(s2, s1, wi(wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0)))))\n  diff.wi.s(s2, wss(cv(s1), c0), wi(wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0))))\n  diff.wss.s(s2, cv(s1), c0)\n  diff.wi.s(s2, wss(cv(s1), cv(s0)), wss(cfv(c2, cv(s1)), cv(s0)))\n  diff.wss.s(s2, cv(s1), cv(s0))\n  diff.wss.s(s2, cfv(c2, cv(s1)), cv(s0))\n  diff.cfv.s(s2, c2, cv(s1))\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n  diff.wss.s(s2, c0, cv(s0))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.wceq.s(s0, cv(s2), c0)\n  diff.cv.s(s0, s2)\n  diff.wceq.s(s1, cv(s2), c0)\n  diff.cv.s(s1, s2)\n}","pretty":"thm setrec1lem1(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2, class c3, wff w0) {\n  ⊢ (w0 →(c0 ∈ c1 ↔ ∀(s0,(∀(s1,(s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ c0 ⊆ s0))))\n  ⊣ c1 = { s2 | ∀(s0,(∀(s1,(s1 ⊆ s2 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ s2 ⊆ s0))}\n  ⊣ (w0 → c0 ∈ c3)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s0, c0)\n  ⊣ d(s1, c0)\n  ⊣ d(s2, c0)\n  ⊣ d(s2, c2)\n} = {\n  syl(w0, (c0 ∈ c1 ↔ ∀(s0,(∀(s1,(s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ c0 ⊆ s0))), c0 ∈ c3)\n  elab2g(s2, c0, c3, c1, ∀(s0,(∀(s1,(s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ c0 ⊆ s0)), ∀(s0,(∀(s1,(s1 ⊆ s2 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ s2 ⊆ s0)))\n  albidv(s0, s2 = c0, (∀(s1,(s1 ⊆ s2 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ s2 ⊆ s0), (∀(s1,(s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ c0 ⊆ s0))\n  imbi12d(s2 = c0, ∀(s1,(s1 ⊆ s2 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0))), s2 ⊆ s0, ∀(s1,(s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0))), c0 ⊆ s0)\n  albidv(s1, s2 = c0, (s1 ⊆ s2 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)), (s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))\n  imbi1d(s2 = c0, s1 ⊆ s2, (s1 ⊆ s0 →(c2 ` s1)⊆ s0), s1 ⊆ c0)\n  sseq2(s2, c0, s1)\n  sseq1(s2, c0, s0)\n  diff.wal.s(s2, s0, (∀(s1,(s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))→ c0 ⊆ s0))\n  diff.wi.s(s2, ∀(s1,(s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0))), c0 ⊆ s0)\n  diff.wal.s(s2, s1, (s1 ⊆ c0 →(s1 ⊆ s0 →(c2 ` s1)⊆ s0)))\n  diff.wi.s(s2, s1 ⊆ c0, (s1 ⊆ s0 →(c2 ` s1)⊆ s0))\n  diff.wss.s(s2, s1, c0)\n  diff.wi.s(s2, s1 ⊆ s0, (c2 ` s1)⊆ s0)\n  diff.wss.s(s2, s1, s0)\n  diff.wss.s(s2, (c2 ` s1), s0)\n  diff.cfv.s(s2, c2, s1)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n  diff.wss.s(s2, c0, s0)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.wceq.s(s0, s2, c0)\n  diff.cv.s(s0, s2)\n  diff.wceq.s(s1, s2, c0)\n  diff.cv.s(s1, s2)\n}","parent":["syl","elab2g","albidv","imbi12d","imbi1d","sseq2","sseq1","diff.wal.s","diff.wi.s","diff.wss.s","diff.cfv.s","diff.cv.s","diffss.ex","diff.wceq.s"],"children":["setrec1lem2","setrec1lem4","setrec2fun"]},{"name":"setrec1lem2","content":"Lemma for ~ setrec1 . If a family of sets are all recursively generated by ` F ` , so is their union. In this theorem, ` X ` is a family of sets which are all elements of ` Y ` , and ` V ` is any class. Use ~ dfss3 , equivalence and equality theorems, and unissb at the end. Sandwich with applications of setrec1lem1. (Contributed by Emmett Weisz, 24-Jan-2021.) (New usage is discouraged.)","origin":"thm setrec1lem2(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2, class c3, wff w0) {\n  |- wi(w0, wcel(cuni(c0), c1))\n  -| wceq(c1, cab(s0, wal(s1, wi(wal(s2, wi(wss(cv(s2), cv(s0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(s0), cv(s1))))))\n  -| wi(w0, wcel(c0, c3))\n  -| wi(w0, wss(c0, c1))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c2)\n  -| diffsc(s1, c0)\n  -| diffsc(s2, c0)\n} = {\n  mpbird(w0, wcel(cuni(c0), c1), wal(s1, wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cuni(c0), cv(s1)))))\n  sylibr(w0, wal(s1, wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cuni(c0), cv(s1)))), wal(s1, wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wral(hs0, c0, wss(cv(hs0), cv(s1))))))\n  syl(w0, wal(s1, wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wral(hs0, c0, wss(cv(hs0), cv(s1))))), wal(s1, wral(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))))\n  sylib(w0, wal(s1, wral(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))), wral(hs0, c0, wal(s1, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))))\n  mpbid(w0, wral(hs0, c0, wal(s1, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))), wral(hs0, c0, wcel(cv(hs0), c1)))\n  sylib(w0, wral(hs0, c0, wcel(cv(hs0), c1)), wss(c0, c1))\n  dfss3(hs0, c0, c1)\n  ralbidv(hs0, c0, w0, wcel(cv(hs0), c1), wal(s1, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1)))))\n  setrec1lem1(s1, s2, s0, cv(hs0), c1, c2, universe, w0)\n  a1i(w0, wcel(cv(hs0), universe))\n  vex(hs0)\n  ralcom4(hs0, s1, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))\n  alimi(s1, wral(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1)))), wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wral(hs0, c0, wss(cv(hs0), cv(s1)))))\n  ralrimd(hs0, c0, wral(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1)))), wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1)))\n  nfra1(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))\n  nfv(hs0, wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))))\n  com23(wral(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1)))), wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wcel(cv(hs0), c0), wss(cv(hs0), cv(s1)))\n  sylcom(wral(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1)))), wcel(cv(hs0), c0), wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))), wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))\n  rsp(hs0, c0, wi(wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1))))\n  imim1d(wcel(cv(hs0), c0), wal(s2, wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cv(hs0), cv(s1)), wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))))\n  alimdv(s2, wcel(cv(hs0), c0), wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1)))), wi(wss(cv(s2), cv(hs0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1)))))\n  imim1d(wcel(cv(hs0), c0), wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))), wss(cv(s2), cv(hs0)))\n  syl5com(wcel(cv(hs0), c0), wss(cv(s2), cv(hs0)), wss(cv(s2), cuni(c0)), wss(cv(hs0), cuni(c0)))\n  elssuni(cv(hs0), c0)\n  sstr2(cv(s2), cv(hs0), cuni(c0))\n  albii(s1, wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cuni(c0), cv(s1))), wi(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wral(hs0, c0, wss(cv(hs0), cv(s1)))))\n  imbi2i(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))), wss(cuni(c0), cv(s1)), wral(hs0, c0, wss(cv(hs0), cv(s1))))\n  unissb(hs0, c0, cv(s1))\n  setrec1lem1(s1, s2, s0, cuni(c0), c1, c2, universe, w0)\n  syl(w0, wcel(cuni(c0), universe), wcel(c0, c3))\n  uniexg(c0, c3)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs0.w(w0)\n  diffss.ex(s1, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n  diff.hs0.w(wal(s2, wi(wss(cv(s2), cuni(c0)), wi(wss(cv(s2), cv(s1)), wss(cfv(c2, cv(s2)), cv(s1))))))\n  diff.wcel.s(s2, cv(hs0), c0)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.hs0.c(cv(s1))\n  diff.cuni.s(s1, c0)\n  diff.cuni.s(s2, c0)\n  diff.cuni.s(s0, c0)\n}","pretty":"thm setrec1lem2(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2, class c3, wff w0) {\n  ⊢ (w0 → ⋃ c0 ∈ c1)\n  ⊣ c1 = { s0 | ∀(s1,(∀(s2,(s2 ⊆ s0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ s0 ⊆ s1))}\n  ⊣ (w0 → c0 ∈ c3)\n  ⊣ (w0 → c0 ⊆ c1)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c2)\n  ⊣ d(s1, c0)\n  ⊣ d(s2, c0)\n} = {\n  mpbird(w0, ⋃ c0 ∈ c1, ∀(s1,(∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ ⋃ c0 ⊆ s1)))\n  sylibr(w0, ∀(s1,(∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ ⋃ c0 ⊆ s1)), ∀(s1,(∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ ∀(hs0 ∈ c0, hs0 ⊆ s1))))\n  syl(w0, ∀(s1,(∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ ∀(hs0 ∈ c0, hs0 ⊆ s1))), ∀(s1, ∀(hs0 ∈ c0,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))))\n  sylib(w0, ∀(s1, ∀(hs0 ∈ c0,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))), ∀(hs0 ∈ c0, ∀(s1,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))))\n  mpbid(w0, ∀(hs0 ∈ c0, ∀(s1,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))), ∀(hs0 ∈ c0, hs0 ∈ c1))\n  sylib(w0, ∀(hs0 ∈ c0, hs0 ∈ c1), c0 ⊆ c1)\n  dfss3(hs0, c0, c1)\n  ralbidv(hs0, c0, w0, hs0 ∈ c1, ∀(s1,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1)))\n  setrec1lem1(s1, s2, s0, hs0, c1, c2, universe, w0)\n  a1i(w0, hs0 ∈ 𝕌)\n  vex(hs0)\n  ralcom4(hs0, s1, c0, (∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))\n  alimi(s1, ∀(hs0 ∈ c0,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1)), (∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ ∀(hs0 ∈ c0, hs0 ⊆ s1)))\n  ralrimd(hs0, c0, ∀(hs0 ∈ c0,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1)), ∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1))), hs0 ⊆ s1)\n  nfra1(hs0, c0, (∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))\n  nfv(hs0, ∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1))))\n  com23(∀(hs0 ∈ c0,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1)), ∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1))), hs0 ∈ c0, hs0 ⊆ s1)\n  sylcom(∀(hs0 ∈ c0,(∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1)), hs0 ∈ c0, (∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1), (∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))\n  rsp(hs0, c0, (∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ hs0 ⊆ s1))\n  imim1d(hs0 ∈ c0, ∀(s2,(s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1))), hs0 ⊆ s1, ∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1))))\n  alimdv(s2, hs0 ∈ c0, (s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)), (s2 ⊆ hs0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))\n  imim1d(hs0 ∈ c0, s2 ⊆ ⋃ c0, (s2 ⊆ s1 →(c2 ` s2)⊆ s1), s2 ⊆ hs0)\n  syl5com(hs0 ∈ c0, s2 ⊆ hs0, s2 ⊆ ⋃ c0, hs0 ⊆ ⋃ c0)\n  elssuni(hs0, c0)\n  sstr2(s2, hs0, ⋃ c0)\n  albii(s1, (∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ ⋃ c0 ⊆ s1), (∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1)))→ ∀(hs0 ∈ c0, hs0 ⊆ s1)))\n  imbi2i(∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1))), ⋃ c0 ⊆ s1, ∀(hs0 ∈ c0, hs0 ⊆ s1))\n  unissb(hs0, c0, s1)\n  setrec1lem1(s1, s2, s0, ⋃ c0, c1, c2, universe, w0)\n  syl(w0, ⋃ c0 ∈ 𝕌, c0 ∈ c3)\n  uniexg(c0, c3)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs0.w(w0)\n  diffss.ex(s1, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n  diff.hs0.w(∀(s2,(s2 ⊆ ⋃ c0 →(s2 ⊆ s1 →(c2 ` s2)⊆ s1))))\n  diff.wcel.s(s2, hs0, c0)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.hs0.c(s1)\n  diff.cuni.s(s1, c0)\n  diff.cuni.s(s2, c0)\n  diff.cuni.s(s0, c0)\n}","parent":["mpbird","sylibr","syl","sylib","mpbid","dfss3","ralbidv","setrec1lem1","a1i","vex","ralcom4","alimi","ralrimd","nfra1","nfv","com23","sylcom","rsp","imim1d","alimdv","syl5com","elssuni","sstr2","albii","imbi2i","unissb","uniexg","diff.hs0.c","diff.hs0.w","diffss.ex","diff.cv.s","diff.hs0.s","diff.wcel.s","diff.cuni.s"],"children":["setrec1lem3"]},{"name":"setrec1lem3","content":"Lemma for ~ setrec1 . If each element ` a ` of ` A ` is covered by a set ` x ` recursively generated by ` F ` , then there is a single such set covering all of ` A ` . The set is constructed explicitly using ~ setrec1lem2 . It turns out that ` x = A ` also works, i.e., given the hypotheses it is possible to prove that ` A e. Y ` . I don't know if proving this fact directly using ~ setrec1lem1 would be any easier than the current proof using ~ setrec1lem2 , and it would only slightly simplify the proof of ~ setrec1 . Other than the use of ~ bnd2d , this is a purely technical theorem for rearranging notation from that of ~ setrec1lem2 to that of ~ setrec1 . (Contributed by Emmett Weisz, 20-Jan-2021.) (New usage is discouraged.)","origin":"thm setrec1lem3(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4, class c0, class c1, class c2, wff w0) {\n  |- wi(w0, wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1))))\n  -| wceq(c1, cab(s1, wal(s2, wi(wal(s3, wi(wss(cv(s3), cv(s1)), wi(wss(cv(s3), cv(s2)), wss(cfv(c2, cv(s3)), cv(s2))))), wss(cv(s1), cv(s2))))))\n  -| wi(w0, wcel(c0, universe))\n  -| wi(w0, wral(s4, c0, wex(s0, wa(wcel(cv(s4), cv(s0)), wcel(cv(s0), c1)))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s4)\n  -| diffss(s1, s2)\n  -| diffss(s1, s3)\n  -| diffss(s2, s3)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n  -| diffsc(s1, c2)\n  -| diffsc(s4, c0)\n  -| diffsc(s4, c1)\n} = {\n  a1ii(wi(w0, wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1)))), diffss(s0, s1))\n  a1ii(wi(w0, wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1)))), diffss(s2, s3))\n  a1ii(wi(w0, wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1)))), diffsc(s0, c2))\n  syl(w0, wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1))), wex(hs0, wa(wss(cv(hs0), c1), wss(c0, cuni(cv(hs0))))))\n  sylib(w0, wex(hs0, wa(wss(cv(hs0), c1), wss(c0, cuni(cv(hs0))))), wex(hs0, wa(wss(cv(hs0), c1), wral(s4, c0, wrex(s0, cv(hs0), wcel(cv(s4), cv(s0)))))))\n  bnd2d(hs0, s4, s0, c1, c0, w0, wcel(cv(s4), cv(s0)))\n  sylibr(w0, wral(s4, c0, wrex(s0, c1, wcel(cv(s4), cv(s0)))), wral(s4, c0, wex(s0, wa(wcel(cv(s0), c1), wcel(cv(s4), cv(s0))))))\n  sylib(w0, wral(s4, c0, wex(s0, wa(wcel(cv(s0), c1), wcel(cv(s4), cv(s0))))), wral(s4, c0, wex(s0, wa(wcel(cv(s4), cv(s0)), wcel(cv(s0), c1)))))\n  ralbii(s4, c0, wex(s0, wa(wcel(cv(s4), cv(s0)), wcel(cv(s0), c1))), wex(s0, wa(wcel(cv(s0), c1), wcel(cv(s4), cv(s0)))))\n  exancom(s0, wcel(cv(s4), cv(s0)), wcel(cv(s0), c1))\n  ralbii(s4, c0, wrex(s0, c1, wcel(cv(s4), cv(s0))), wex(s0, wa(wcel(cv(s0), c1), wcel(cv(s4), cv(s0)))))\n  df-rex(s0, c1, wcel(cv(s4), cv(s0)))\n  exbii(hs0, wa(wss(cv(hs0), c1), wral(s4, c0, wrex(s0, cv(hs0), wcel(cv(s4), cv(s0))))), wa(wss(cv(hs0), c1), wss(c0, cuni(cv(hs0)))))\n  anbi2i(wss(cv(hs0), c1), wral(s4, c0, wrex(s0, cv(hs0), wcel(cv(s4), cv(s0)))), wss(c0, cuni(cv(hs0))))\n  bitr4i(wral(s4, c0, wrex(s0, cv(hs0), wcel(cv(s4), cv(s0)))), wss(c0, cuni(cv(hs0))), wral(s4, c0, wcel(cv(s4), cuni(cv(hs0)))))\n  ralbii(s4, c0, wrex(s0, cv(hs0), wcel(cv(s4), cv(s0))), wcel(cv(s4), cuni(cv(hs0))))\n  3bitr4i(wrex(s0, cv(hs0), wcel(cv(s4), cv(s0))), wcel(cv(s4), cuni(cv(hs0))), wex(s0, wa(wcel(cv(s0), cv(hs0)), wcel(cv(s4), cv(s0)))), wex(s0, wa(wcel(cv(s4), cv(s0)), wcel(cv(s0), cv(hs0)))))\n  exancom(s0, wcel(cv(s0), cv(hs0)), wcel(cv(s4), cv(s0)))\n  df-rex(s0, cv(hs0), wcel(cv(s4), cv(s0)))\n  eluni(s0, cv(s4), cv(hs0))\n  dfss3(s4, c0, cuni(cv(hs0)))\n  exlimiv(hs0, wa(wss(cv(hs0), c1), wss(c0, cuni(cv(hs0)))), wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1))))\n  syl(wa(wss(cv(hs0), c1), wss(c0, cuni(cv(hs0)))), wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1))), wa(wss(c0, cuni(cv(hs0))), wcel(cuni(cv(hs0)), c1)))\n  ancomd(wa(wss(cv(hs0), c1), wss(c0, cuni(cv(hs0)))), wss(c0, cuni(cv(hs0))), wcel(cuni(cv(hs0)), c1))\n  anim1i(wss(cv(hs0), c1), wss(c0, cuni(cv(hs0))), wcel(cuni(cv(hs0)), c1))\n  setrec1lem2(s1, s2, s3, cv(hs0), c1, c2, universe, wss(cv(hs0), c1))\n  a1i(wss(cv(hs0), c1), wcel(cv(hs0), universe))\n  id(wss(cv(hs0), c1))\n  spcev(s0, cuni(cv(hs0)), wa(wss(c0, cuni(cv(hs0))), wcel(cuni(cv(hs0)), c1)), wa(wss(c0, cv(s0)), wcel(cv(s0), c1)))\n  uniex(cv(hs0))\n  vex(hs0)\n  anbi12d(wceq(cv(s0), cuni(cv(hs0))), wss(c0, cv(s0)), wcel(cv(s0), c1), wss(c0, cuni(cv(hs0))), wcel(cuni(cv(hs0)), c1))\n  sseq2(cv(s0), cuni(cv(hs0)), c0)\n  eleq1(cv(s0), cuni(cv(hs0)), c1)\n  diffss.ex(s4, s0)\n  diff.hs0.c(c1)\n  diff.hs0.c(c0)\n  diff.hs0.w(wcel(cv(s4), cv(s0)))\n  diff.cv.s(s0, s4)\n  diff.cuni.s(s4, cv(hs0))\n  diff.cv.s(s4, hs0)\n  diffss.ex(s4, hs0)\n  diff.hs0.s(s4)\n  diff.hs0.w(wex(s0, wa(wss(c0, cv(s0)), wcel(cv(s0), c1))))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s3, hs0)\n  diffss.ex(s3, hs0)\n  diff.hs0.s(s3)\n  diff.wa.s(s0, wss(c0, cuni(cv(hs0))), wcel(cuni(cv(hs0)), c1))\n  diff.wss.s(s0, c0, cuni(cv(hs0)))\n  diff.wcel.s(s0, cuni(cv(hs0)), c1)\n  diff.cuni.s(s0, cv(hs0))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","pretty":"thm setrec1lem3(setvar s0, setvar s1, setvar s2, setvar s3, setvar s4, class c0, class c1, class c2, wff w0) {\n  ⊢ (w0 → ∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1)))\n  ⊣ c1 = { s1 | ∀(s2,(∀(s3,(s3 ⊆ s1 →(s3 ⊆ s2 →(c2 ` s3)⊆ s2)))→ s1 ⊆ s2))}\n  ⊣ (w0 → c0 ∈ 𝕌)\n  ⊣ (w0 → ∀(s4 ∈ c0, ∃(s0,(s4 ∈ s0 ∧ s0 ∈ c1))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s4)\n  ⊣ d(s1, s2)\n  ⊣ d(s1, s3)\n  ⊣ d(s2, s3)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c2)\n  ⊣ d(s1, c2)\n  ⊣ d(s4, c0)\n  ⊣ d(s4, c1)\n} = {\n  a1ii((w0 → ∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1))), d(s0, s1))\n  a1ii((w0 → ∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1))), d(s2, s3))\n  a1ii((w0 → ∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1))), d(s0, c2))\n  syl(w0, ∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1)), ∃(hs0,(hs0 ⊆ c1 ∧ c0 ⊆ ⋃ hs0)))\n  sylib(w0, ∃(hs0,(hs0 ⊆ c1 ∧ c0 ⊆ ⋃ hs0)), ∃(hs0,(hs0 ⊆ c1 ∧ ∀(s4 ∈ c0, ∃(s0 ∈ hs0, s4 ∈ s0)))))\n  bnd2d(hs0, s4, s0, c1, c0, w0, s4 ∈ s0)\n  sylibr(w0, ∀(s4 ∈ c0, ∃(s0 ∈ c1, s4 ∈ s0)), ∀(s4 ∈ c0, ∃(s0,(s0 ∈ c1 ∧ s4 ∈ s0))))\n  sylib(w0, ∀(s4 ∈ c0, ∃(s0,(s0 ∈ c1 ∧ s4 ∈ s0))), ∀(s4 ∈ c0, ∃(s0,(s4 ∈ s0 ∧ s0 ∈ c1))))\n  ralbii(s4, c0, ∃(s0,(s4 ∈ s0 ∧ s0 ∈ c1)), ∃(s0,(s0 ∈ c1 ∧ s4 ∈ s0)))\n  exancom(s0, s4 ∈ s0, s0 ∈ c1)\n  ralbii(s4, c0, ∃(s0 ∈ c1, s4 ∈ s0), ∃(s0,(s0 ∈ c1 ∧ s4 ∈ s0)))\n  df-rex(s0, c1, s4 ∈ s0)\n  exbii(hs0, (hs0 ⊆ c1 ∧ ∀(s4 ∈ c0, ∃(s0 ∈ hs0, s4 ∈ s0))), (hs0 ⊆ c1 ∧ c0 ⊆ ⋃ hs0))\n  anbi2i(hs0 ⊆ c1, ∀(s4 ∈ c0, ∃(s0 ∈ hs0, s4 ∈ s0)), c0 ⊆ ⋃ hs0)\n  bitr4i(∀(s4 ∈ c0, ∃(s0 ∈ hs0, s4 ∈ s0)), c0 ⊆ ⋃ hs0, ∀(s4 ∈ c0, s4 ∈ ⋃ hs0))\n  ralbii(s4, c0, ∃(s0 ∈ hs0, s4 ∈ s0), s4 ∈ ⋃ hs0)\n  3bitr4i(∃(s0 ∈ hs0, s4 ∈ s0), s4 ∈ ⋃ hs0, ∃(s0,(s0 ∈ hs0 ∧ s4 ∈ s0)), ∃(s0,(s4 ∈ s0 ∧ s0 ∈ hs0)))\n  exancom(s0, s0 ∈ hs0, s4 ∈ s0)\n  df-rex(s0, hs0, s4 ∈ s0)\n  eluni(s0, s4, hs0)\n  dfss3(s4, c0, ⋃ hs0)\n  exlimiv(hs0, (hs0 ⊆ c1 ∧ c0 ⊆ ⋃ hs0), ∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1)))\n  syl((hs0 ⊆ c1 ∧ c0 ⊆ ⋃ hs0), ∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1)), (c0 ⊆ ⋃ hs0 ∧ ⋃ hs0 ∈ c1))\n  ancomd((hs0 ⊆ c1 ∧ c0 ⊆ ⋃ hs0), c0 ⊆ ⋃ hs0, ⋃ hs0 ∈ c1)\n  anim1i(hs0 ⊆ c1, c0 ⊆ ⋃ hs0, ⋃ hs0 ∈ c1)\n  setrec1lem2(s1, s2, s3, hs0, c1, c2, universe, hs0 ⊆ c1)\n  a1i(hs0 ⊆ c1, hs0 ∈ 𝕌)\n  id(hs0 ⊆ c1)\n  spcev(s0, ⋃ hs0, (c0 ⊆ ⋃ hs0 ∧ ⋃ hs0 ∈ c1), (c0 ⊆ s0 ∧ s0 ∈ c1))\n  uniex(hs0)\n  vex(hs0)\n  anbi12d(s0 = ⋃ hs0, c0 ⊆ s0, s0 ∈ c1, c0 ⊆ ⋃ hs0, ⋃ hs0 ∈ c1)\n  sseq2(s0, ⋃ hs0, c0)\n  eleq1(s0, ⋃ hs0, c1)\n  diffss.ex(s4, s0)\n  diff.hs0.c(c1)\n  diff.hs0.c(c0)\n  diff.hs0.w(s4 ∈ s0)\n  diff.cv.s(s0, s4)\n  diff.cuni.s(s4, hs0)\n  diff.cv.s(s4, hs0)\n  diffss.ex(s4, hs0)\n  diff.hs0.s(s4)\n  diff.hs0.w(∃(s0,(c0 ⊆ s0 ∧ s0 ∈ c1)))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.cv.s(s2, hs0)\n  diffss.ex(s2, hs0)\n  diff.hs0.s(s2)\n  diff.cv.s(s3, hs0)\n  diffss.ex(s3, hs0)\n  diff.hs0.s(s3)\n  diff.wa.s(s0, c0 ⊆ ⋃ hs0, ⋃ hs0 ∈ c1)\n  diff.wss.s(s0, c0, ⋃ hs0)\n  diff.wcel.s(s0, ⋃ hs0, c1)\n  diff.cuni.s(s0, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n}","parent":["a1ii","syl","sylib","bnd2d","sylibr","ralbii","exancom","df-rex","exbii","anbi2i","bitr4i","3bitr4i","eluni","dfss3","exlimiv","ancomd","anim1i","setrec1lem2","a1i","id","spcev","uniex","vex","anbi12d","sseq2","eleq1","diffss.ex","diff.hs0.c","diff.hs0.w","diff.cv.s","diff.cuni.s","diff.hs0.s","diff.wa.s","diff.wss.s","diff.wcel.s"],"children":["setrec1"]},{"name":"setrec1lem4","content":"Lemma for ~ setrec1 . If ` X ` is recursively generated by ` F ` , then so is ` X u. ( F `` A ) ` . In the proof of ~ setrec1 , the following is substituted for this theorem's ` ph ` : ` ( ph /\\ ( A C_ x /\\ x e. { y | A. z ( A. w ` ` ( w C_ y -> ( w C_ z -> ( F `` w ) C_ z ) ) -> y C_ z ) } ) ) ` Therefore, we cannot declare ` z ` to be a distinct variable from ` ph ` , since we need it to appear as a bound variable in ` ph ` . This theorem can be proven without the hypothesis ` F/ z ph ` , but the proof would be harder to read because theorems in deduction form would be interrupted by theorems like ~ eximi , making the antecedent of each line something more complicated than ` ph ` . The proof of ~ setrec1lem2 could similarly be made easier to read by adding the hypothesis ` F/ z ph ` , but I had already finished the proof and decided to leave it as is. (Contributed by Emmett Weisz, 26-Nov-2020.) (New usage is discouraged.)","origin":"thm setrec1lem4(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2, class c3, wff w0) {\n  |- wi(w0, wcel(cun(c0, cfv(c1, c2)), c3))\n  -| wnf(s0, w0)\n  -| wceq(c3, cab(s1, wal(s0, wi(wal(s2, wi(wss(cv(s2), cv(s1)), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(cv(s1), cv(s0))))))\n  -| wi(w0, wcel(c2, universe))\n  -| wi(w0, wss(c2, c0))\n  -| wi(w0, wcel(c0, c3))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n  -| diffsc(s1, c0)\n  -| diffsc(s1, c1)\n  -| diffsc(s1, c2)\n  -| diffsc(s2, c0)\n  -| diffsc(s2, c1)\n  -| diffsc(s2, c2)\n} = {\n  mpbird(w0, wcel(cun(c0, cfv(c1, c2)), c3), wal(s0, wi(wal(s2, wi(wss(cv(s2), cun(c0, cfv(c1, c2))), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(cun(c0, cfv(c1, c2)), cv(s0)))))\n  alrimi(s0, w0, wi(wal(s2, wi(wss(cv(s2), cun(c0, cfv(c1, c2))), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(cun(c0, cfv(c1, c2)), cv(s0))))\n  syl6ib(w0, wal(s2, wi(wss(cv(s2), cun(c0, cfv(c1, c2))), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(cun(c0, cfv(c1, c2)), cv(s0)), wa(wss(c0, cv(s0)), wss(cfv(c1, c2), cv(s0))))\n  syl5(w0, wal(s2, wi(wss(cv(s2), cun(c0, cfv(c1, c2))), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wa(wss(c0, cv(s0)), wss(cfv(c1, c2), cv(s0))), wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))))\n  alimi(s2, wi(wss(cv(s2), cun(c0, cfv(c1, c2))), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0)))), wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0)))))\n  imim1i(wss(cv(s2), cun(c0, cfv(c1, c2))), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))), wss(cv(s2), c0))\n  syl6ss(cv(s2), cun(c0, cfv(c1, c2)), c0, wss(cv(s2), c0))\n  id(wss(cv(s2), c0))\n  ssun1(c0, cfv(c1, c2))\n  jcad(w0, wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(c0, cv(s0)), wss(cfv(c1, c2), cv(s0)))\n  mpdd(w0, wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(cfv(c1, c2), cv(s0)), wss(c2, cv(s0)))\n  syld(w0, wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(c2, cv(s0)), wss(c0, cv(s0)))\n  syl(w0, wi(wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(c0, cv(s0))), wal(s0, wi(wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(c0, cv(s0)))))\n  mpbid(w0, wal(s0, wi(wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(c0, cv(s0)))), wcel(c0, c3))\n  setrec1lem1(s0, s2, s1, c0, c3, c1, c3, w0)\n  sp(s0, wi(wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wss(c0, cv(s0))))\n  syl(w0, wi(wss(c0, cv(s0)), wss(c2, cv(s0))), wss(c2, c0))\n  sstr2(c2, c0, cv(s0))\n  mpid(w0, wal(s2, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))))), wi(wss(c2, cv(s0)), wss(cfv(c1, c2), cv(s0))), wss(c2, c0))\n  spcdvw(s2, c2, universe, w0, wi(wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0)))), wi(wss(c2, c0), wi(wss(c2, cv(s0)), wss(cfv(c1, c2), cv(s0)))))\n  imbi12d(wceq(cv(s2), c2), wss(cv(s2), c0), wi(wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0))), wss(c2, c0), wi(wss(c2, cv(s0)), wss(cfv(c1, c2), cv(s0))))\n  sseq1(cv(s2), c2, c0)\n  imbi12d(wceq(cv(s2), c2), wss(cv(s2), cv(s0)), wss(cfv(c1, cv(s2)), cv(s0)), wss(c2, cv(s0)), wss(cfv(c1, c2), cv(s0)))\n  sseq1(cv(s2), c2, cv(s0))\n  sseq1d(cfv(c1, cv(s2)), cv(s0), cfv(c1, c2), wceq(cv(s2), c2))\n  fveq2(cv(s2), c2, c1)\n  unss(c0, cv(s0), cfv(c1, c2))\n  setrec1lem1(s0, s2, s1, cun(c0, cfv(c1, c2)), c3, c1, universe, w0)\n  sylancl(w0, wcel(cun(c0, cfv(c1, c2)), universe), wcel(c0, c3), wcel(cfv(c1, c2), universe))\n  fvex(c1, c2)\n  unexg(c0, c3, cfv(c1, c2), universe)\n  diffss.ex(s2, s1)\n  diff.wi.s(s2, wss(c2, c0), wi(wss(c2, cv(s0)), wss(cfv(c1, c2), cv(s0))))\n  diff.wss.s(s2, c2, c0)\n  diff.wi.s(s2, wss(c2, cv(s0)), wss(cfv(c1, c2), cv(s0)))\n  diff.wss.s(s2, c2, cv(s0))\n  diff.wss.s(s2, cfv(c1, c2), cv(s0))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cun.s(s0, c0, cfv(c1, c2))\n  diff.cfv.s(s0, c1, c2)\n  diff.cun.s(s2, c0, cfv(c1, c2))\n  diff.cfv.s(s2, c1, c2)\n  diff.cun.s(s1, c0, cfv(c1, c2))\n  diff.cfv.s(s1, c1, c2)\n}","pretty":"thm setrec1lem4(setvar s0, setvar s1, setvar s2, class c0, class c1, class c2, class c3, wff w0) {\n  ⊢ (w0 →(c0 ⋃(c1 ` c2))∈ c3)\n  ⊣ F/(s0, w0)\n  ⊣ c3 = { s1 | ∀(s0,(∀(s2,(s2 ⊆ s1 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))→ s1 ⊆ s0))}\n  ⊣ (w0 → c2 ∈ 𝕌)\n  ⊣ (w0 → c2 ⊆ c0)\n  ⊣ (w0 → c0 ∈ c3)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c2)\n  ⊣ d(s1, c0)\n  ⊣ d(s1, c1)\n  ⊣ d(s1, c2)\n  ⊣ d(s2, c0)\n  ⊣ d(s2, c1)\n  ⊣ d(s2, c2)\n} = {\n  mpbird(w0, (c0 ⋃(c1 ` c2))∈ c3, ∀(s0,(∀(s2,(s2 ⊆(c0 ⋃(c1 ` c2))→(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))→(c0 ⋃(c1 ` c2))⊆ s0)))\n  alrimi(s0, w0, (∀(s2,(s2 ⊆(c0 ⋃(c1 ` c2))→(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))→(c0 ⋃(c1 ` c2))⊆ s0))\n  syl6ib(w0, ∀(s2,(s2 ⊆(c0 ⋃(c1 ` c2))→(s2 ⊆ s0 →(c1 ` s2)⊆ s0))), (c0 ⋃(c1 ` c2))⊆ s0, (c0 ⊆ s0 ∧(c1 ` c2)⊆ s0))\n  syl5(w0, ∀(s2,(s2 ⊆(c0 ⋃(c1 ` c2))→(s2 ⊆ s0 →(c1 ` s2)⊆ s0))), (c0 ⊆ s0 ∧(c1 ` c2)⊆ s0), ∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0))))\n  alimi(s2, (s2 ⊆(c0 ⋃(c1 ` c2))→(s2 ⊆ s0 →(c1 ` s2)⊆ s0)), (s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))\n  imim1i(s2 ⊆(c0 ⋃(c1 ` c2)), (s2 ⊆ s0 →(c1 ` s2)⊆ s0), s2 ⊆ c0)\n  syl6ss(s2, (c0 ⋃(c1 ` c2)), c0, s2 ⊆ c0)\n  id(s2 ⊆ c0)\n  ssun1(c0, (c1 ` c2))\n  jcad(w0, ∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0))), c0 ⊆ s0, (c1 ` c2)⊆ s0)\n  mpdd(w0, ∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0))), (c1 ` c2)⊆ s0, c2 ⊆ s0)\n  syld(w0, ∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0))), c2 ⊆ s0, c0 ⊆ s0)\n  syl(w0, (∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))→ c0 ⊆ s0), ∀(s0,(∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))→ c0 ⊆ s0)))\n  mpbid(w0, ∀(s0,(∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))→ c0 ⊆ s0)), c0 ∈ c3)\n  setrec1lem1(s0, s2, s1, c0, c3, c1, c3, w0)\n  sp(s0, (∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0)))→ c0 ⊆ s0))\n  syl(w0, (c0 ⊆ s0 → c2 ⊆ s0), c2 ⊆ c0)\n  sstr2(c2, c0, s0)\n  mpid(w0, ∀(s2,(s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0))), (c2 ⊆ s0 →(c1 ` c2)⊆ s0), c2 ⊆ c0)\n  spcdvw(s2, c2, universe, w0, (s2 ⊆ c0 →(s2 ⊆ s0 →(c1 ` s2)⊆ s0)), (c2 ⊆ c0 →(c2 ⊆ s0 →(c1 ` c2)⊆ s0)))\n  imbi12d(s2 = c2, s2 ⊆ c0, (s2 ⊆ s0 →(c1 ` s2)⊆ s0), c2 ⊆ c0, (c2 ⊆ s0 →(c1 ` c2)⊆ s0))\n  sseq1(s2, c2, c0)\n  imbi12d(s2 = c2, s2 ⊆ s0, (c1 ` s2)⊆ s0, c2 ⊆ s0, (c1 ` c2)⊆ s0)\n  sseq1(s2, c2, s0)\n  sseq1d((c1 ` s2), s0, (c1 ` c2), s2 = c2)\n  fveq2(s2, c2, c1)\n  unss(c0, s0, (c1 ` c2))\n  setrec1lem1(s0, s2, s1, (c0 ⋃(c1 ` c2)), c3, c1, universe, w0)\n  sylancl(w0, (c0 ⋃(c1 ` c2))∈ 𝕌, c0 ∈ c3, (c1 ` c2)∈ 𝕌)\n  fvex(c1, c2)\n  unexg(c0, c3, (c1 ` c2), universe)\n  diffss.ex(s2, s1)\n  diff.wi.s(s2, c2 ⊆ c0, (c2 ⊆ s0 →(c1 ` c2)⊆ s0))\n  diff.wss.s(s2, c2, c0)\n  diff.wi.s(s2, c2 ⊆ s0, (c1 ` c2)⊆ s0)\n  diff.wss.s(s2, c2, s0)\n  diff.wss.s(s2, (c1 ` c2), s0)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cun.s(s0, c0, (c1 ` c2))\n  diff.cfv.s(s0, c1, c2)\n  diff.cun.s(s2, c0, (c1 ` c2))\n  diff.cfv.s(s2, c1, c2)\n  diff.cun.s(s1, c0, (c1 ` c2))\n  diff.cfv.s(s1, c1, c2)\n}","parent":["mpbird","alrimi","syl6ib","syl5","alimi","imim1i","syl6ss","id","ssun1","jcad","mpdd","syld","syl","mpbid","setrec1lem1","sp","sstr2","mpid","spcdvw","imbi12d","sseq1","sseq1d","fveq2","unss","sylancl","fvex","unexg","diffss.ex","diff.wi.s","diff.wss.s","diff.cv.s","diff.cun.s","diff.cfv.s"],"children":["setrec1"]},{"name":"setrec1","content":"This is the first of two fundamental theorems about set recursion from which all other facts will be derived. It states that the class ` setrecs ( F ) ` is closed under ` F ` . This effectively sets the actual value of ` setrecs ( F ) ` as a lower bound for ` setrecs ( F ) ` , as it implies that any set generated by successive applications of ` F ` is a member of ` B ` . This theorem \"gets off the ground\" because we can start by letting ` A = (/) ` , and the hypotheses of the theorem will hold trivially. Variable ` B ` represents an abbreviation of ` setrecs ( F ) ` or another name of ` setrecs ( F ) ` (for an example of the latter, see theorem setrecon). Proof summary: Assume that ` A C_ B ` , meaning that all elements of ` A ` are in some set recursively generated by ` F ` . Then by ~ setrec1lem3 , ` A ` is a subset of some set recursively generated by ` F ` . (It turns out that ` A ` itself is recursively generated by ` F ` , but we don't need this fact. See the comment to ~ setrec1lem3 .) Therefore, by ~ setrec1lem4 , ` ( F `` A ) ` is a subset of some set recursively generated by ` F ` . Thus, by ~ ssuni , it is a subset of the union of all sets recursively generated by ` F ` . See ~ df-setrecs for a detailed description of how the ` setrecs ` definition works. (Contributed by Emmett Weisz, 9-Oct-2020.)","origin":"thm setrec1(class c0, class c1, class c2, wff w0) {\n  |- wi(w0, wss(cfv(c0, c1), c2))\n  -| wceq(c2, csetrecs(c0))\n  -| wi(w0, wcel(c1, universe))\n  -| wi(w0, wss(c1, c2))\n} = {\n  syl6sseqr(cfv(c0, c1), c2, cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), w0)\n  exlimddv(hs3, w0, wss(cfv(c0, c1), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))), wa(wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))))\n  setrec1lem3(hs3, hs1, hs2, hs0, hs4, c1, cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), c0, w0)\n  ralrimiva(hs4, c1, w0, wex(hs3, wa(wcel(cv(hs4), cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))))\n  sylib(wa(w0, wcel(cv(hs4), c1)), wex(hs3, wa(wcel(cv(hs4), cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))), wcel(cv(hs4), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))))\n  syl6eleq(cv(hs4), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), c2, wa(w0, wcel(cv(hs4), c1)))\n  imp(w0, wcel(cv(hs4), c1), wcel(cv(hs4), c2))\n  sseld(cv(hs4), c1, c2, w0)\n  eluni(hs3, cv(hs4), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  syl(wa(w0, wa(wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))), wss(cfv(c0, c1), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))), wa(wss(cfv(c0, c1), cun(cv(hs3), cfv(c0, c1))), wcel(cun(cv(hs3), cfv(c0, c1)), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))))\n  jctil(wa(w0, wa(wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))), wss(cfv(c0, c1), cun(cv(hs3), cfv(c0, c1))), wcel(cun(cv(hs3), cfv(c0, c1)), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))\n  setrec1lem4(hs2, hs1, hs0, cv(hs3), c0, c1, cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), wa(w0, wa(wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))))\n  nfan(hs2, w0, wa(wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))))\n  nfv(hs2, w0)\n  nfan(hs2, wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))\n  nfv(hs2, wss(c1, cv(hs3)))\n  nfel2(hs2, cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  nfaba1(hs2, hs1, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))\n  eqid(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  adantr(w0, wa(wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))), wcel(c1, universe))\n  simprl(w0, wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))\n  simprr(w0, wss(c1, cv(hs3)), wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))))\n  ssun2(cfv(c0, c1), cv(hs3))\n  ssuni(cfv(c0, c1), cun(cv(hs3), cfv(c0, c1)), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  eqtri(c2, cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), csetrecs(c0))\n  df-setrecs(hs1, hs2, hs0, c0)\n  diff.hs3.w(w0)\n  diff.hs3.w(wss(cfv(c0, c1), cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))))\n  diff.hs3.s(hs1)\n  diff.hs3.s(hs4)\n  diff.hs1.s(hs2)\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs3.c(c1)\n  diff.hs3.c(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  diff.hs3.c(c0)\n  diff.hs1.c(c0)\n  diff.hs4.c(c1)\n  diff.hs4.c(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c0, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  diff.hs4.w(w0)\n  diff.hs0.c(c0)\n  diff.hs2.c(c0)\n  diff.hs3.c(cv(hs4))\n  diff.hs2.s(hs1)\n  diff.hs2.c(cv(hs3))\n  diff.hs2.c(c1)\n  diff.hs1.c(cv(hs3))\n  diff.hs1.c(c1)\n  diff.hs0.c(cv(hs3))\n  diff.hs0.c(c1)\n  diff.hs2.w(w0)\n  diff.hs2.w(wss(c1, cv(hs3)))\n}","pretty":"thm setrec1(class c0, class c1, class c2, wff w0) {\n  ⊢ (w0 →(c0 ` c1)⊆ c2)\n  ⊣ c2 = setrecs(c0)\n  ⊣ (w0 → c1 ∈ 𝕌)\n  ⊣ (w0 → c1 ⊆ c2)\n} = {\n  syl6sseqr((c0 ` c1), c2, ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, w0)\n  exlimddv(hs3, w0, (c0 ` c1)⊆ ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, (c1 ⊆ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}))\n  setrec1lem3(hs3, hs1, hs2, hs0, hs4, c1, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, c0, w0)\n  ralrimiva(hs4, c1, w0, ∃(hs3,(hs4 ∈ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})))\n  sylib((w0 ∧ hs4 ∈ c1), ∃(hs3,(hs4 ∈ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})), hs4 ∈ ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  syl6eleq(hs4, ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, c2, (w0 ∧ hs4 ∈ c1))\n  imp(w0, hs4 ∈ c1, hs4 ∈ c2)\n  sseld(hs4, c1, c2, w0)\n  eluni(hs3, hs4, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  syl((w0 ∧(c1 ⊆ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})), (c0 ` c1)⊆ ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, ((c0 ` c1)⊆(hs3 ⋃(c0 ` c1))∧(hs3 ⋃(c0 ` c1))∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}))\n  jctil((w0 ∧(c1 ⊆ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})), (c0 ` c1)⊆(hs3 ⋃(c0 ` c1)), (hs3 ⋃(c0 ` c1))∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  setrec1lem4(hs2, hs1, hs0, hs3, c0, c1, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, (w0 ∧(c1 ⊆ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})))\n  nfan(hs2, w0, (c1 ⊆ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}))\n  nfv(hs2, w0)\n  nfan(hs2, c1 ⊆ hs3, hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  nfv(hs2, c1 ⊆ hs3)\n  nfel2(hs2, hs3, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  nfaba1(hs2, hs1, (∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))\n  eqid({ hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  adantr(w0, (c1 ⊆ hs3 ∧ hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}), c1 ∈ 𝕌)\n  simprl(w0, c1 ⊆ hs3, hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  simprr(w0, c1 ⊆ hs3, hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  ssun2((c0 ` c1), hs3)\n  ssuni((c0 ` c1), (hs3 ⋃(c0 ` c1)), { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  eqtri(c2, ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, setrecs(c0))\n  df-setrecs(hs1, hs2, hs0, c0)\n  diff.hs3.w(w0)\n  diff.hs3.w((c0 ` c1)⊆ ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  diff.hs3.s(hs1)\n  diff.hs3.s(hs4)\n  diff.hs1.s(hs2)\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs3.c(c1)\n  diff.hs3.c({ hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  diff.hs3.c(c0)\n  diff.hs1.c(c0)\n  diff.hs4.c(c1)\n  diff.hs4.c({ hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c0 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  diff.hs4.w(w0)\n  diff.hs0.c(c0)\n  diff.hs2.c(c0)\n  diff.hs3.c(hs4)\n  diff.hs2.s(hs1)\n  diff.hs2.c(hs3)\n  diff.hs2.c(c1)\n  diff.hs1.c(hs3)\n  diff.hs1.c(c1)\n  diff.hs0.c(hs3)\n  diff.hs0.c(c1)\n  diff.hs2.w(w0)\n  diff.hs2.w(c1 ⊆ hs3)\n}","parent":["syl6sseqr","exlimddv","setrec1lem3","ralrimiva","sylib","syl6eleq","imp","sseld","eluni","syl","jctil","setrec1lem4","nfan","nfv","nfel2","nfaba1","eqid","adantr","simprl","simprr","ssun2","ssuni","eqtri","df-setrecs","diff.hs3.w","diff.hs3.s","diff.hs1.s","diff.hs2.s","diff.hs3.c","diff.hs1.c","diff.hs4.c","diff.hs4.w","diff.hs0.c","diff.hs2.c","diff.hs2.w"],"children":["elsetrecslem","elsetrecs","setrecsss","setrecsres","vsetrec","onsetrec"]},{"name":"setrec2fun","content":"This is the second of two fundamental theorems about set recursion from which all other facts will be derived. It states that the class ` setrecs ( F ) ` is a subclass of all classes ` C ` that are closed under ` F ` . Taken together, theorems ~ setrec1 and ~ setrec2v say that ` setrecs ( F ) ` is the minimal class closed under ` F ` . We express this by saying that if ` F ` respects the ` C_ ` relation and ` C ` is closed under ` F ` , then ` B C_ C ` . By substituting strategically constructed classes for ` C ` , we can easily prove many useful properties. Although this theorem cannot show equality between ` B ` and ` C ` , if we intend to prove equality between ` B ` and some particular class (such as ` On ` ), we first apply this theorem, then the relevant induction theorem (such as ~ tfi ) to the other class. (Contributed by Emmett Weisz, 15-Feb-2021.) (New usage is discouraged.)","origin":"thm setrec2fun(setvar s0, class c0, class c1, class c2, wff w0) {\n  |- wi(w0, wss(c0, c1))\n  -| wnfc(s0, c2)\n  -| wceq(c0, csetrecs(c2))\n  -| wfun(c2)\n  -| wi(w0, wal(s0, wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1))))\n  -| diffsc(s0, c1)\n} = {\n  syl5eqss(c0, c1, cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), w0)\n  eqtri(c0, cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), csetrecs(c2))\n  df-setrecs(hs1, hs2, hs0, c2)\n  sylibr(w0, wss(cuni(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), c1), wral(hs3, cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), wss(cv(hs3), c1)))\n  ralrimiv(hs3, cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), w0, wss(cv(hs3), c1))\n  sylbid(w0, wcel(cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2)))))), wss(cv(hs3), c1), wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs3), cv(hs2)))))\n  setrec1lem1(hs2, hs0, hs1, cv(hs3), cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), c2, universe, w0)\n  eqid(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  a1i(w0, wcel(cv(hs3), universe))\n  ex(w0, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs3), cv(hs2)))), wss(cv(hs3), c1))\n  syl6ss(cv(hs3), c1, cin(c1, cuni(cima(c2, cpw(cv(hs3))))), wa(w0, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs3), cv(hs2))))))\n  mpan9(w0, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs3), cv(hs2)))), wss(cv(hs3), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))))\n  alrimiv(hs0, w0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))))\n  3exp(w0, wss(cv(hs0), cv(hs3)), wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))\n  ssind(cfv(c2, cv(hs0)), c1, cuni(cima(c2, cpw(cv(hs3)))), w3a(w0, wss(cv(hs0), cv(hs3)), wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))\n  3adant2(w0, wss(cv(hs0), cv(hs3)), wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), c1))\n  imp(w0, wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), c1))\n  syl5(w0, wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), c1), wss(cv(hs0), c1))\n  syl6ss(cv(hs0), c1, cin(c1, cuni(cima(c2, cpw(cv(hs3))))), wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))\n  id(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))\n  syl(w0, wi(wss(cv(hs0), c1), wss(cfv(c2, cv(hs0)), c1)), wal(s0, wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1))))\n  spim(s0, hs0, wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1)), wi(wss(cv(hs0), c1), wss(cfv(c2, cv(hs0)), c1)))\n  nfim(s0, wss(cv(hs0), c1), wss(cfv(c2, cv(hs0)), c1))\n  nfv(s0, wss(cv(hs0), c1))\n  nfss(s0, cfv(c2, cv(hs0)), c1)\n  nffv(s0, c2, cv(hs0))\n  nfcv(s0, cv(hs0))\n  nfcv(s0, c1)\n  biimpd(wceq(cv(s0), cv(hs0)), wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1)), wi(wss(cv(hs0), c1), wss(cfv(c2, cv(hs0)), c1)))\n  imbi12d(wceq(cv(s0), cv(hs0)), wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1), wss(cv(hs0), c1), wss(cfv(c2, cv(hs0)), c1))\n  sseq1(cv(s0), cv(hs0), c1)\n  sseq1d(cfv(c2, cv(s0)), c1, cfv(c2, cv(hs0)), wceq(cv(s0), cv(hs0)))\n  fveq2(cv(s0), cv(hs0), c2)\n  3ad2ant2(w0, wss(cv(hs0), cv(hs3)), wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cuni(cima(c2, cpw(cv(hs3))))))\n  pm2.61d2(wss(cv(hs0), cv(hs3)), wss(cfv(c2, cv(hs0)), cuni(cima(c2, cpw(cv(hs3))))), wceq(cfv(c2, cv(hs0)), emptycls))\n  syl6(wss(cv(hs0), cv(hs3)), wn(wceq(cfv(c2, cv(hs0)), emptycls)), wss(cfv(c2, cv(hs0)), cuni(cima(c2, cpw(cv(hs3))))), wcel(cfv(c2, cv(hs0)), cima(c2, cpw(cv(hs3)))))\n  sylbir(wss(cv(hs0), cv(hs3)), wi(wn(wceq(cfv(c2, cv(hs0)), emptycls)), wcel(cfv(c2, cv(hs0)), cima(c2, cpw(cv(hs3))))), wcel(cv(hs0), cpw(cv(hs3))))\n  selpw(hs0, cv(hs3))\n  ex(wcel(cv(hs0), cpw(cv(hs3))), wn(wceq(cfv(c2, cv(hs0)), emptycls)), wcel(cfv(c2, cv(hs0)), cima(c2, cpw(cv(hs3)))))\n  eliman0(cv(hs0), cpw(cv(hs3)), c2)\n  elssuni(cfv(c2, cv(hs0)), cima(c2, cpw(cv(hs3))))\n  syl6eqss(cfv(c2, cv(hs0)), cuni(cima(c2, cpw(cv(hs3)))), emptycls, wceq(cfv(c2, cv(hs0)), emptycls))\n  id(wceq(cfv(c2, cv(hs0)), emptycls))\n  0ss(cuni(cima(c2, cpw(cv(hs3)))))\n  spcv(hs2, cin(c1, cuni(cima(c2, cpw(cv(hs3))))), wi(wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs3), cv(hs2))), wi(wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))), wss(cv(hs3), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))\n  inex2(c1, cuni(cima(c2, cpw(cv(hs3)))))\n  uniex(cima(c2, cpw(cv(hs3))))\n  ax-mp(wcel(cima(c2, cpw(cv(hs3))), universe), wfun(c2))\n  funimaex(c2, cpw(cv(hs3)))\n  pwex(cv(hs3))\n  vex(hs3)\n  imbi12d(wceq(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs3), cv(hs2)), wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))), wss(cv(hs3), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))\n  albidv(hs0, wceq(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2)))), wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))))\n  imbi2d(wceq(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))), wi(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))\n  imbi12d(wceq(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2)), wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))\n  sseq2(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3))))), cv(hs0))\n  sseq2(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3))))), cfv(c2, cv(hs0)))\n  sseq2(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3))))), cv(hs3))\n  inss1(c1, cuni(cima(c2, cpw(cv(hs3)))))\n  unissb(hs3, cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))), c1)\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c2)\n  diff.hs1.c(c2)\n  diff.hs2.c(c2)\n  diff.hs3.w(w0)\n  diff.hs2.s(hs1)\n  diff.hs0.s(hs1)\n  diff.hs2.c(cv(hs3))\n  diff.hs0.c(cv(hs3))\n  diff.hs1.c(cv(hs3))\n  diff.hs0.w(w0)\n  diff.wss.s(s0, cv(hs0), c1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs2.c(cin(c1, cuni(cima(c2, cpw(cv(hs3))))))\n  diff.hs2.w(wi(wal(hs0, wi(wss(cv(hs0), cv(hs3)), wi(wss(cv(hs0), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))), wss(cfv(c2, cv(hs0)), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))), wss(cv(hs3), cin(c1, cuni(cima(c2, cpw(cv(hs3))))))))\n  diff.hs0.w(wceq(cv(hs2), cin(c1, cuni(cima(c2, cpw(cv(hs3)))))))\n  diff.hs3.c(cab(hs1, wal(hs2, wi(wal(hs0, wi(wss(cv(hs0), cv(hs1)), wi(wss(cv(hs0), cv(hs2)), wss(cfv(c2, cv(hs0)), cv(hs2))))), wss(cv(hs1), cv(hs2))))))\n  diff.hs3.c(c1)\n}","pretty":"thm setrec2fun(setvar s0, class c0, class c1, class c2, wff w0) {\n  ⊢ (w0 → c0 ⊆ c1)\n  ⊣ F/(s0, c2)\n  ⊣ c0 = setrecs(c2)\n  ⊣ Fun(c2)\n  ⊣ (w0 → ∀(s0,(s0 ⊆ c1 →(c2 ` s0)⊆ c1)))\n  ⊣ d(s0, c1)\n} = {\n  syl5eqss(c0, c1, ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, w0)\n  eqtri(c0, ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, setrecs(c2))\n  df-setrecs(hs1, hs2, hs0, c2)\n  sylibr(w0, ⋃ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))} ⊆ c1, ∀(hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, hs3 ⊆ c1))\n  ralrimiv(hs3, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, w0, hs3 ⊆ c1)\n  sylbid(w0, hs3 ∈ { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, hs3 ⊆ c1, ∀(hs2,(∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs3 ⊆ hs2)))\n  setrec1lem1(hs2, hs0, hs1, hs3, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, c2, universe, w0)\n  eqid({ hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  a1i(w0, hs3 ∈ 𝕌)\n  ex(w0, ∀(hs2,(∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs3 ⊆ hs2)), hs3 ⊆ c1)\n  syl6ss(hs3, c1, (c1 ⋂ ⋃(c2 \" P(hs3))), (w0 ∧ ∀(hs2,(∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs3 ⊆ hs2))))\n  mpan9(w0, ∀(hs2,(∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs3 ⊆ hs2)), hs3 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))), ∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))→(c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3)))))))\n  alrimiv(hs0, w0, (hs0 ⊆ hs3 →(hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))→(c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3))))))\n  3exp(w0, hs0 ⊆ hs3, hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))), (c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3))))\n  ssind((c2 ` hs0), c1, ⋃(c2 \" P(hs3)), (w0 ∧ hs0 ⊆ hs3 ∧ hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))))\n  3adant2(w0, hs0 ⊆ hs3, hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))), (c2 ` hs0)⊆ c1)\n  imp(w0, hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))), (c2 ` hs0)⊆ c1)\n  syl5(w0, hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))), (c2 ` hs0)⊆ c1, hs0 ⊆ c1)\n  syl6ss(hs0, c1, (c1 ⋂ ⋃(c2 \" P(hs3))), hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))))\n  id(hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))))\n  syl(w0, (hs0 ⊆ c1 →(c2 ` hs0)⊆ c1), ∀(s0,(s0 ⊆ c1 →(c2 ` s0)⊆ c1)))\n  spim(s0, hs0, (s0 ⊆ c1 →(c2 ` s0)⊆ c1), (hs0 ⊆ c1 →(c2 ` hs0)⊆ c1))\n  nfim(s0, hs0 ⊆ c1, (c2 ` hs0)⊆ c1)\n  nfv(s0, hs0 ⊆ c1)\n  nfss(s0, (c2 ` hs0), c1)\n  nffv(s0, c2, hs0)\n  nfcv(s0, hs0)\n  nfcv(s0, c1)\n  biimpd(s0 = hs0, (s0 ⊆ c1 →(c2 ` s0)⊆ c1), (hs0 ⊆ c1 →(c2 ` hs0)⊆ c1))\n  imbi12d(s0 = hs0, s0 ⊆ c1, (c2 ` s0)⊆ c1, hs0 ⊆ c1, (c2 ` hs0)⊆ c1)\n  sseq1(s0, hs0, c1)\n  sseq1d((c2 ` s0), c1, (c2 ` hs0), s0 = hs0)\n  fveq2(s0, hs0, c2)\n  3ad2ant2(w0, hs0 ⊆ hs3, hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))), (c2 ` hs0)⊆ ⋃(c2 \" P(hs3)))\n  pm2.61d2(hs0 ⊆ hs3, (c2 ` hs0)⊆ ⋃(c2 \" P(hs3)), (c2 ` hs0)= ∅)\n  syl6(hs0 ⊆ hs3, ¬(c2 ` hs0)= ∅, (c2 ` hs0)⊆ ⋃(c2 \" P(hs3)), (c2 ` hs0)∈(c2 \" P(hs3)))\n  sylbir(hs0 ⊆ hs3, (¬(c2 ` hs0)= ∅ →(c2 ` hs0)∈(c2 \" P(hs3))), hs0 ∈ P(hs3))\n  selpw(hs0, hs3)\n  ex(hs0 ∈ P(hs3), ¬(c2 ` hs0)= ∅, (c2 ` hs0)∈(c2 \" P(hs3)))\n  eliman0(hs0, P(hs3), c2)\n  elssuni((c2 ` hs0), (c2 \" P(hs3)))\n  syl6eqss((c2 ` hs0), ⋃(c2 \" P(hs3)), emptycls, (c2 ` hs0)= ∅)\n  id((c2 ` hs0)= ∅)\n  0ss(⋃(c2 \" P(hs3)))\n  spcv(hs2, (c1 ⋂ ⋃(c2 \" P(hs3))), (∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs3 ⊆ hs2), (∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))→(c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3))))))→ hs3 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))))\n  inex2(c1, ⋃(c2 \" P(hs3)))\n  uniex((c2 \" P(hs3)))\n  ax-mp((c2 \" P(hs3))∈ 𝕌, Fun(c2))\n  funimaex(c2, P(hs3))\n  pwex(hs3)\n  vex(hs3)\n  imbi12d(hs2 =(c1 ⋂ ⋃(c2 \" P(hs3))), ∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2))), hs3 ⊆ hs2, ∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))→(c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3)))))), hs3 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))))\n  albidv(hs0, hs2 =(c1 ⋂ ⋃(c2 \" P(hs3))), (hs0 ⊆ hs3 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)), (hs0 ⊆ hs3 →(hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))→(c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3))))))\n  imbi2d(hs2 =(c1 ⋂ ⋃(c2 \" P(hs3))), hs0 ⊆ hs3, (hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2), (hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))→(c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3)))))\n  imbi12d(hs2 =(c1 ⋂ ⋃(c2 \" P(hs3))), hs0 ⊆ hs2, (c2 ` hs0)⊆ hs2, hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3))), (c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3))))\n  sseq2(hs2, (c1 ⋂ ⋃(c2 \" P(hs3))), hs0)\n  sseq2(hs2, (c1 ⋂ ⋃(c2 \" P(hs3))), (c2 ` hs0))\n  sseq2(hs2, (c1 ⋂ ⋃(c2 \" P(hs3))), hs3)\n  inss1(c1, ⋃(c2 \" P(hs3)))\n  unissb(hs3, { hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))}, c1)\n  diff.hs1.s(hs0)\n  diff.hs2.s(hs0)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c2)\n  diff.hs1.c(c2)\n  diff.hs2.c(c2)\n  diff.hs3.w(w0)\n  diff.hs2.s(hs1)\n  diff.hs0.s(hs1)\n  diff.hs2.c(hs3)\n  diff.hs0.c(hs3)\n  diff.hs1.c(hs3)\n  diff.hs0.w(w0)\n  diff.wss.s(s0, hs0, c1)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs2.c((c1 ⋂ ⋃(c2 \" P(hs3))))\n  diff.hs2.w((∀(hs0,(hs0 ⊆ hs3 →(hs0 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))→(c2 ` hs0)⊆(c1 ⋂ ⋃(c2 \" P(hs3))))))→ hs3 ⊆(c1 ⋂ ⋃(c2 \" P(hs3)))))\n  diff.hs0.w(hs2 =(c1 ⋂ ⋃(c2 \" P(hs3))))\n  diff.hs3.c({ hs1 | ∀(hs2,(∀(hs0,(hs0 ⊆ hs1 →(hs0 ⊆ hs2 →(c2 ` hs0)⊆ hs2)))→ hs1 ⊆ hs2))})\n  diff.hs3.c(c1)\n}","parent":["syl5eqss","eqtri","df-setrecs","sylibr","ralrimiv","sylbid","setrec1lem1","eqid","a1i","ex","syl6ss","mpan9","alrimiv","3exp","ssind","3adant2","imp","syl5","id","syl","spim","nfim","nfv","nfss","nffv","nfcv","biimpd","imbi12d","sseq1","sseq1d","fveq2","3ad2ant2","pm2.61d2","syl6","sylbir","selpw","eliman0","elssuni","syl6eqss","0ss","spcv","inex2","uniex","ax-mp","funimaex","pwex","vex","albidv","imbi2d","sseq2","inss1","unissb","diff.hs1.s","diff.hs2.s","diff.hs0.c","diff.hs1.c","diff.hs2.c","diff.hs3.w","diff.hs0.s","diff.hs0.w","diff.wss.s","diff.cv.s","diffss.ex","diff.hs2.w","diff.hs3.c"],"children":["setrec2"]},{"name":"setrec2lem1","content":"Lemma for ~ setrec2 . The functional part of ` F ` has the same values as ` F ` . (Contributed by Emmett Weisz, 4-Mar-2021.) (New usage is discouraged.)","origin":"thm setrec2lem1(setvar s0, setvar s1, setvar s2, class c0) {\n  |- wceq(cfv(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s2)), cfv(c0, cv(s2)))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsc(s0, c0)\n  -| diffsc(s1, c0)\n} = {\n  pm2.61i(wceq(cfv(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s2)), cfv(c0, cv(s2))), wcel(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))))\n  fvres(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))), c0)\n  eqtr4d(cfv(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s2)), cfv(c0, cv(s2)), emptycls, wn(wcel(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))))\n  syl(wn(wcel(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))), wceq(cfv(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s2)), emptycls), wn(wcel(cv(s2), cdm(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))))))\n  con3i(wcel(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), wcel(cv(s2), cdm(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))))))\n  sseli(cv(s2), cdm(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))\n  eqsstri(cdm(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))), cin(cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))), cdm(c0)))\n  dmres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))\n  inss1(cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))), cdm(c0))\n  ndmfv(cv(s2), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))))\n  syl(wn(wcel(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))), wceq(cfv(c0, cv(s2)), emptycls), wn(weu(s1, wbr(cv(s2), c0, cv(s1)))))\n  biimpi(wn(wcel(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))), wn(weu(s1, wbr(cv(s2), c0, cv(s1)))))\n  notbii(wcel(cv(s2), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), weu(s1, wbr(cv(s2), c0, cv(s1))))\n  elab(s0, cv(s2), weu(s1, wbr(cv(s0), c0, cv(s1))), weu(s1, wbr(cv(s2), c0, cv(s1))))\n  vex(s2)\n  eubidv(s1, wceq(cv(s0), cv(s2)), wbr(cv(s0), c0, cv(s1)), wbr(cv(s2), c0, cv(s1)))\n  breq1(cv(s0), cv(s2), c0, cv(s1))\n  tz6.12-2(s1, cv(s2), c0)\n  diff.weu.s(s0, s1, wbr(cv(s2), c0, cv(s1)))\n  diff.wbr.s(s0, cv(s2), c0, cv(s1))\n  diff.cv.s(s0, s2)\n  diff.cv.s(s0, s1)\n  diff.wceq.s(s1, cv(s0), cv(s2))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s1, s2)\n}","pretty":"thm setrec2lem1(setvar s0, setvar s1, setvar s2, class c0) {\n  ⊢ ((c0 |` { s0 | ∃!(s1, s0[c0]s1)})` s2)=(c0 ` s2)\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s0, c0)\n  ⊣ d(s1, c0)\n} = {\n  pm2.61i(((c0 |` { s0 | ∃!(s1, s0[c0]s1)})` s2)=(c0 ` s2), s2 ∈ { s0 | ∃!(s1, s0[c0]s1)})\n  fvres(s2, { s0 | ∃!(s1, s0[c0]s1)}, c0)\n  eqtr4d(((c0 |` { s0 | ∃!(s1, s0[c0]s1)})` s2), (c0 ` s2), emptycls, ¬ s2 ∈ { s0 | ∃!(s1, s0[c0]s1)})\n  syl(¬ s2 ∈ { s0 | ∃!(s1, s0[c0]s1)}, ((c0 |` { s0 | ∃!(s1, s0[c0]s1)})` s2)= ∅, ¬ s2 ∈ dom((c0 |` { s0 | ∃!(s1, s0[c0]s1)})))\n  con3i(s2 ∈ { s0 | ∃!(s1, s0[c0]s1)}, s2 ∈ dom((c0 |` { s0 | ∃!(s1, s0[c0]s1)})))\n  sseli(s2, dom((c0 |` { s0 | ∃!(s1, s0[c0]s1)})), { s0 | ∃!(s1, s0[c0]s1)})\n  eqsstri(dom((c0 |` { s0 | ∃!(s1, s0[c0]s1)})), { s0 | ∃!(s1, s0[c0]s1)}, ({ s0 | ∃!(s1, s0[c0]s1)} ⋂ dom(c0)))\n  dmres(c0, { s0 | ∃!(s1, s0[c0]s1)})\n  inss1({ s0 | ∃!(s1, s0[c0]s1)}, dom(c0))\n  ndmfv(s2, (c0 |` { s0 | ∃!(s1, s0[c0]s1)}))\n  syl(¬ s2 ∈ { s0 | ∃!(s1, s0[c0]s1)}, (c0 ` s2)= ∅, ¬ ∃!(s1, s2[c0]s1))\n  biimpi(¬ s2 ∈ { s0 | ∃!(s1, s0[c0]s1)}, ¬ ∃!(s1, s2[c0]s1))\n  notbii(s2 ∈ { s0 | ∃!(s1, s0[c0]s1)}, ∃!(s1, s2[c0]s1))\n  elab(s0, s2, ∃!(s1, s0[c0]s1), ∃!(s1, s2[c0]s1))\n  vex(s2)\n  eubidv(s1, s0 = s2, s0[c0]s1, s2[c0]s1)\n  breq1(s0, s2, c0, s1)\n  tz6.12-2(s1, s2, c0)\n  diff.weu.s(s0, s1, s2[c0]s1)\n  diff.wbr.s(s0, s2, c0, s1)\n  diff.cv.s(s0, s2)\n  diff.cv.s(s0, s1)\n  diff.wceq.s(s1, s0, s2)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s1, s2)\n}","parent":["pm2.61i","fvres","eqtr4d","syl","con3i","sseli","eqsstri","dmres","inss1","ndmfv","biimpi","notbii","elab","vex","eubidv","breq1","tz6.12-2","diff.weu.s","diff.wbr.s","diff.cv.s","diff.wceq.s","diffss.ex"],"children":["setrec2"]},{"name":"setrec2lem2","content":"Lemma for ~ setrec2 . The functional part of ` F ` is a function. (Contributed by Emmett Weisz, 6-Mar-2021.) (New usage is discouraged.)","origin":"thm setrec2lem2(setvar s0, setvar s1, class c0) {\n  |- wfun(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))))\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsc(s1, c0)\n} = {\n  mpbir2an(wfun(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))), wrel(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))), wal(s0, wex(hs0, wal(s1, wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cv(hs0)))))))\n  relres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))\n  ax-gen(s0, wex(hs0, wal(s1, wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cv(hs0))))))\n  mpg(s1, wex(hs0, wal(s1, wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cv(hs0))))), wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cfv(c0, cv(s0)))))\n  spcev(hs0, cfv(c0, cv(s0)), wal(s1, wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cfv(c0, cv(s0))))), wal(s1, wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cv(hs0)))))\n  fvex(c0, cv(s0))\n  albidv(s1, wceq(cv(hs0), cfv(c0, cv(s0))), wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cv(hs0))), wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cfv(c0, cv(s0)))))\n  imbi2d(wceq(cv(hs0), cfv(c0, cv(s0))), wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cv(hs0)), wceq(cv(s1), cfv(c0, cv(s0))))\n  eqeq2(cv(hs0), cfv(c0, cv(s0)), cv(s1))\n  sylbi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cfv(c0, cv(s0))), wa(wcel(cv(s0), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), wbr(cv(s0), c0, cv(s1))))\n  brresi(cv(s0), c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))), cv(s1))\n  vex(s1)\n  eqcomd(cv(s1), cfv(c0, cv(s0)), wa(wcel(cv(s0), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), wbr(cv(s0), c0, cv(s1))))\n  sylanb(wcel(cv(s0), cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), wbr(cv(s0), c0, cv(s1)), wceq(cfv(c0, cv(s0)), cv(s1)), weu(s1, wbr(cv(s0), c0, cv(s1))))\n  abid(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))\n  ancoms(weu(s1, wbr(cv(s0), c0, cv(s1))), wbr(cv(s0), c0, cv(s1)), wceq(cfv(c0, cv(s0)), cv(s1)))\n  tz6.12-1(s1, cv(s0), c0)\n  dffun3f(s0, hs0, s1, cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))))\n  nfres(s0, c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))\n  nfcv(s0, c0)\n  nfab1(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))\n  nfres(s1, c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1)))))\n  nfcv(s1, c0)\n  nfab(s1, s0, weu(s1, wbr(cv(s0), c0, cv(s1))))\n  nfeu1(s1, wbr(cv(s0), c0, cv(s1)))\n  nfcv(hs0, cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))))\n  diff.hs0.c(cfv(c0, cv(s0)))\n  diff.hs0.w(wal(s1, wi(wbr(cv(s0), cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))), cv(s1)), wceq(cv(s1), cfv(c0, cv(s0))))))\n  diff.wceq.s(s1, cv(hs0), cfv(c0, cv(s0)))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.cfv.s(s1, c0, cv(s0))\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n  diff.hs0.c(cres(c0, cab(s0, weu(s1, wbr(cv(s0), c0, cv(s1))))))\n}","pretty":"thm setrec2lem2(setvar s0, setvar s1, class c0) {\n  ⊢ Fun((c0 |` { s0 | ∃!(s1, s0[c0]s1)}))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s1, c0)\n} = {\n  mpbir2an(Fun((c0 |` { s0 | ∃!(s1, s0[c0]s1)})), Rel((c0 |` { s0 | ∃!(s1, s0[c0]s1)})), ∀(s0, ∃(hs0, ∀(s1,(s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 = hs0)))))\n  relres(c0, { s0 | ∃!(s1, s0[c0]s1)})\n  ax-gen(s0, ∃(hs0, ∀(s1,(s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 = hs0))))\n  mpg(s1, ∃(hs0, ∀(s1,(s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 = hs0))), (s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 =(c0 ` s0)))\n  spcev(hs0, (c0 ` s0), ∀(s1,(s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 =(c0 ` s0))), ∀(s1,(s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 = hs0)))\n  fvex(c0, s0)\n  albidv(s1, hs0 =(c0 ` s0), (s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 = hs0), (s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 =(c0 ` s0)))\n  imbi2d(hs0 =(c0 ` s0), s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1, s1 = hs0, s1 =(c0 ` s0))\n  eqeq2(hs0, (c0 ` s0), s1)\n  sylbi(s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1, s1 =(c0 ` s0), (s0 ∈ { s0 | ∃!(s1, s0[c0]s1)} ∧ s0[c0]s1))\n  brresi(s0, c0, { s0 | ∃!(s1, s0[c0]s1)}, s1)\n  vex(s1)\n  eqcomd(s1, (c0 ` s0), (s0 ∈ { s0 | ∃!(s1, s0[c0]s1)} ∧ s0[c0]s1))\n  sylanb(s0 ∈ { s0 | ∃!(s1, s0[c0]s1)}, s0[c0]s1, (c0 ` s0)= s1, ∃!(s1, s0[c0]s1))\n  abid(s0, ∃!(s1, s0[c0]s1))\n  ancoms(∃!(s1, s0[c0]s1), s0[c0]s1, (c0 ` s0)= s1)\n  tz6.12-1(s1, s0, c0)\n  dffun3f(s0, hs0, s1, (c0 |` { s0 | ∃!(s1, s0[c0]s1)}))\n  nfres(s0, c0, { s0 | ∃!(s1, s0[c0]s1)})\n  nfcv(s0, c0)\n  nfab1(s0, ∃!(s1, s0[c0]s1))\n  nfres(s1, c0, { s0 | ∃!(s1, s0[c0]s1)})\n  nfcv(s1, c0)\n  nfab(s1, s0, ∃!(s1, s0[c0]s1))\n  nfeu1(s1, s0[c0]s1)\n  nfcv(hs0, (c0 |` { s0 | ∃!(s1, s0[c0]s1)}))\n  diff.hs0.c((c0 ` s0))\n  diff.hs0.w(∀(s1,(s0[(c0 |` { s0 | ∃!(s1, s0[c0]s1)})]s1 → s1 =(c0 ` s0))))\n  diff.wceq.s(s1, hs0, (c0 ` s0))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.cfv.s(s1, c0, s0)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.s(s1)\n  diff.hs0.c((c0 |` { s0 | ∃!(s1, s0[c0]s1)}))\n}","parent":["mpbir2an","relres","ax-gen","mpg","spcev","fvex","albidv","imbi2d","eqeq2","sylbi","brresi","vex","eqcomd","sylanb","abid","ancoms","tz6.12-1","dffun3f","nfres","nfcv","nfab1","nfab","nfeu1","diff.hs0.c","diff.hs0.w","diff.wceq.s","diff.cv.s","diffss.ex","diff.cfv.s","diff.hs0.s"],"children":["setrec2"]},{"name":"setrec2","content":"This is the second of two fundamental theorems about set recursion from which all other facts will be derived. It states that the class ` setrecs ( F ) ` is a subclass of all classes ` C ` that are closed under ` F ` . Taken together, theorems ~ setrec1 and ~ setrec2v uniquely determine ` setrecs ( F ) ` to be the minimal class closed under ` F ` . We express this by saying that if ` F ` respects the ` C_ ` relation and ` C ` is closed under ` F ` , then ` B C_ C ` . By substituting strategically constructed classes for ` C ` , we can easily prove many useful properties. Although this theorem cannot show equality between ` B ` and ` C ` , if we intend to prove equality between ` B ` and some particular class (such as ` On ` ), we first apply this theorem, then the relevant induction theorem (such as ~ tfi ) to the other class. (Contributed by Emmett Weisz, 2-Sep-2021.)","origin":"thm setrec2(setvar s0, class c0, class c1, class c2, wff w0) {\n  |- wi(w0, wss(c0, c1))\n  -| wnfc(s0, c2)\n  -| wceq(c0, csetrecs(c2))\n  -| wi(w0, wal(s0, wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1))))\n  -| diffsc(s0, c1)\n} = {\n  setrec2fun(s0, c0, c1, cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), w0)\n  nfres(s0, c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1)))))\n  nfab(s0, hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))\n  nfeu(s0, hs1, wbr(cv(hs0), c2, cv(hs1)))\n  nfbr(s0, cv(hs0), c2, cv(hs1))\n  nfcv(s0, cv(hs0))\n  nfcv(s0, cv(hs1))\n  eqtri(c0, csetrecs(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1)))))), csetrecs(c2))\n  3eqtr4ri(csetrecs(c2), csetrecs(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1)))))), cuni(cab(hs3, wal(hs4, wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4)))))), cuni(cab(hs3, wal(hs4, wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4)))))))\n  unieqi(cab(hs3, wal(hs4, wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4))))), cab(hs3, wal(hs4, wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4))))))\n  abbii(hs3, wal(hs4, wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4)))), wal(hs4, wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4)))))\n  albii(hs4, wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4))), wi(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4))))\n  imbi1i(wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4))))), wss(cv(hs3), cv(hs4)), wal(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4))))))\n  albii(hs2, wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4)))), wi(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4)))))\n  imbi2i(wss(cv(hs2), cv(hs3)), wi(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4))), wi(wss(cv(hs2), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4))))\n  imbi2i(wss(cv(hs2), cv(hs4)), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4)), wss(cfv(c2, cv(hs2)), cv(hs4)))\n  sseq1i(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(hs2)), cv(hs4), cfv(c2, cv(hs2)))\n  setrec2lem1(hs0, hs1, hs2, c2)\n  df-setrecs(hs3, hs4, hs2, cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))))\n  df-setrecs(hs3, hs4, hs2, c2)\n  setrec2lem2(hs0, hs1, c2)\n  sylibr(w0, wal(s0, wi(wss(cv(s0), c1), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(s0)), c1))), wal(s0, wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1))))\n  albii(s0, wi(wss(cv(s0), c1), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(s0)), c1)), wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1)))\n  imbi2i(wss(cv(s0), c1), wss(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(s0)), c1), wss(cfv(c2, cv(s0)), c1))\n  sseq1i(cfv(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))), cv(s0)), c1, cfv(c2, cv(s0)))\n  setrec2lem1(hs0, hs1, s0, c2)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.cv.s(s0, hs1)\n  diffss.ex(s0, hs1)\n  diff.hs0.s(hs1)\n  diff.hs0.s(hs2)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c2)\n  diff.hs1.c(c2)\n  diff.hs3.s(hs2)\n  diff.hs4.s(hs2)\n  diff.hs3.s(hs4)\n  diff.hs2.c(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))))\n  diff.hs3.c(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))))\n  diff.hs4.c(cres(c2, cab(hs0, weu(hs1, wbr(cv(hs0), c2, cv(hs1))))))\n  diff.hs2.c(c2)\n  diff.hs3.c(c2)\n  diff.hs4.c(c2)\n  diff.hs0.s(s0)\n  diff.hs1.s(s0)\n}","pretty":"thm setrec2(setvar s0, class c0, class c1, class c2, wff w0) {\n  ⊢ (w0 → c0 ⊆ c1)\n  ⊣ F/(s0, c2)\n  ⊣ c0 = setrecs(c2)\n  ⊣ (w0 → ∀(s0,(s0 ⊆ c1 →(c2 ` s0)⊆ c1)))\n  ⊣ d(s0, c1)\n} = {\n  setrec2fun(s0, c0, c1, (c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)}), w0)\n  nfres(s0, c2, { hs0 | ∃!(hs1, hs0[c2]hs1)})\n  nfab(s0, hs0, ∃!(hs1, hs0[c2]hs1))\n  nfeu(s0, hs1, hs0[c2]hs1)\n  nfbr(s0, hs0, c2, hs1)\n  nfcv(s0, hs0)\n  nfcv(s0, hs1)\n  eqtri(c0, setrecs((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})), setrecs(c2))\n  3eqtr4ri(setrecs(c2), setrecs((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})), ⋃ { hs3 | ∀(hs4,(∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4)))→ hs3 ⊆ hs4))}, ⋃ { hs3 | ∀(hs4,(∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →(c2 ` hs2)⊆ hs4)))→ hs3 ⊆ hs4))})\n  unieqi({ hs3 | ∀(hs4,(∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4)))→ hs3 ⊆ hs4))}, { hs3 | ∀(hs4,(∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →(c2 ` hs2)⊆ hs4)))→ hs3 ⊆ hs4))})\n  abbii(hs3, ∀(hs4,(∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4)))→ hs3 ⊆ hs4)), ∀(hs4,(∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →(c2 ` hs2)⊆ hs4)))→ hs3 ⊆ hs4)))\n  albii(hs4, (∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4)))→ hs3 ⊆ hs4), (∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →(c2 ` hs2)⊆ hs4)))→ hs3 ⊆ hs4))\n  imbi1i(∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4))), hs3 ⊆ hs4, ∀(hs2,(hs2 ⊆ hs3 →(hs2 ⊆ hs4 →(c2 ` hs2)⊆ hs4))))\n  albii(hs2, (hs2 ⊆ hs3 →(hs2 ⊆ hs4 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4)), (hs2 ⊆ hs3 →(hs2 ⊆ hs4 →(c2 ` hs2)⊆ hs4)))\n  imbi2i(hs2 ⊆ hs3, (hs2 ⊆ hs4 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4), (hs2 ⊆ hs4 →(c2 ` hs2)⊆ hs4))\n  imbi2i(hs2 ⊆ hs4, ((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2)⊆ hs4, (c2 ` hs2)⊆ hs4)\n  sseq1i(((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` hs2), hs4, (c2 ` hs2))\n  setrec2lem1(hs0, hs1, hs2, c2)\n  df-setrecs(hs3, hs4, hs2, (c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)}))\n  df-setrecs(hs3, hs4, hs2, c2)\n  setrec2lem2(hs0, hs1, c2)\n  sylibr(w0, ∀(s0,(s0 ⊆ c1 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` s0)⊆ c1)), ∀(s0,(s0 ⊆ c1 →(c2 ` s0)⊆ c1)))\n  albii(s0, (s0 ⊆ c1 →((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` s0)⊆ c1), (s0 ⊆ c1 →(c2 ` s0)⊆ c1))\n  imbi2i(s0 ⊆ c1, ((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` s0)⊆ c1, (c2 ` s0)⊆ c1)\n  sseq1i(((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)})` s0), c1, (c2 ` s0))\n  setrec2lem1(hs0, hs1, s0, c2)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.cv.s(s0, hs1)\n  diffss.ex(s0, hs1)\n  diff.hs0.s(hs1)\n  diff.hs0.s(hs2)\n  diff.hs1.s(hs2)\n  diff.hs0.c(c2)\n  diff.hs1.c(c2)\n  diff.hs3.s(hs2)\n  diff.hs4.s(hs2)\n  diff.hs3.s(hs4)\n  diff.hs2.c((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)}))\n  diff.hs3.c((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)}))\n  diff.hs4.c((c2 |` { hs0 | ∃!(hs1, hs0[c2]hs1)}))\n  diff.hs2.c(c2)\n  diff.hs3.c(c2)\n  diff.hs4.c(c2)\n  diff.hs0.s(s0)\n  diff.hs1.s(s0)\n}","parent":["setrec2fun","nfres","nfab","nfeu","nfbr","nfcv","eqtri","3eqtr4ri","unieqi","abbii","albii","imbi1i","imbi2i","sseq1i","setrec2lem1","df-setrecs","setrec2lem2","sylibr","diff.cv.s","diffss.ex","diff.hs0.s","diff.hs1.s","diff.hs0.c","diff.hs1.c","diff.hs3.s","diff.hs4.s","diff.hs2.c","diff.hs3.c","diff.hs4.c"],"children":["setrec2v"]},{"name":"setrec2v","content":"Version of ~ setrec2 with a disjoint variable condition instead of a non-freeness hypothesis. (Contributed by Emmett Weisz, 6-Mar-2021.)","origin":"thm setrec2v(setvar s0, class c0, class c1, class c2, wff w0) {\n  |- wi(w0, wss(c0, c1))\n  -| wceq(c0, csetrecs(c2))\n  -| wi(w0, wal(s0, wi(wss(cv(s0), c1), wss(cfv(c2, cv(s0)), c1))))\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n} = {\n  setrec2(s0, c0, c1, c2, w0)\n  nfcv(s0, c2)\n}","pretty":"thm setrec2v(setvar s0, class c0, class c1, class c2, wff w0) {\n  ⊢ (w0 → c0 ⊆ c1)\n  ⊣ c0 = setrecs(c2)\n  ⊣ (w0 → ∀(s0,(s0 ⊆ c1 →(c2 ` s0)⊆ c1)))\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c2)\n} = {\n  setrec2(s0, c0, c1, c2, w0)\n  nfcv(s0, c2)\n}","parent":["setrec2","nfcv"],"children":["setis","elsetrecslem","setrecsss","setrecsres","0setrec","onsetrec"]},{"name":"setis","content":"Version of ~ setrec2 expressed as an induction schema. This theorem is a generalization of ~ tfis3 . (Contributed by Emmett Weisz, 27-Feb-2022.)","origin":"thm setis(setvar s0, setvar s1, class c0, class c1, class c2, wff w0, wff w1, wff w2) {\n  |- wi(w0, wi(wcel(c0, c1), w1))\n  -| wceq(c1, csetrecs(c2))\n  -| wi(wceq(cv(s0), c0), wb(w2, w1))\n  -| wi(w0, wal(s1, wi(wral(s0, cv(s1), w2), wral(s0, cfv(c2, cv(s1)), w2))))\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c2)\n  -| diffsc(s1, c2)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w2)\n} = {\n  mpbidi(w0, wcel(c0, c1), w1, wcel(c0, cab(s0, w2)))\n  sseld(c0, c1, cab(s0, w2), w0)\n  setrec2v(s1, c1, cab(s0, w2), c2, w0)\n  sylibr(w0, wal(s1, wi(wss(cv(s1), cab(s0, w2)), wss(cfv(c2, cv(s1)), cab(s0, w2)))), wal(s1, wi(wral(s0, cv(s1), w2), wral(s0, cfv(c2, cv(s1)), w2))))\n  albii(s1, wi(wss(cv(s1), cab(s0, w2)), wss(cfv(c2, cv(s1)), cab(s0, w2))), wi(wral(s0, cv(s1), w2), wral(s0, cfv(c2, cv(s1)), w2)))\n  imbi12i(wss(cv(s1), cab(s0, w2)), wss(cfv(c2, cv(s1)), cab(s0, w2)), wral(s0, cv(s1), w2), wral(s0, cfv(c2, cv(s1)), w2))\n  ssabral(s0, cv(s1), w2)\n  ssabral(s0, cfv(c2, cv(s1)), w2)\n  elabg(s0, c0, c1, w2, w1)\n  diff.cab.s(s1, s0, w2)\n  diffss.ex(s1, s0)\n  diff.cfv.s(s0, c2, cv(s1))\n  diff.cv.s(s0, s1)\n}","pretty":"thm setis(setvar s0, setvar s1, class c0, class c1, class c2, wff w0, wff w1, wff w2) {\n  ⊢ (w0 →(c0 ∈ c1 → w1))\n  ⊣ c1 = setrecs(c2)\n  ⊣ (s0 = c0 →(w2 ↔ w1))\n  ⊣ (w0 → ∀(s1,(∀(s0 ∈ s1, w2)→ ∀(s0 ∈(c2 ` s1), w2))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c2)\n  ⊣ d(s1, c2)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w2)\n} = {\n  mpbidi(w0, c0 ∈ c1, w1, c0 ∈ { s0 | w2 })\n  sseld(c0, c1, { s0 | w2 }, w0)\n  setrec2v(s1, c1, { s0 | w2 }, c2, w0)\n  sylibr(w0, ∀(s1,(s1 ⊆ { s0 | w2 } →(c2 ` s1)⊆ { s0 | w2 })), ∀(s1,(∀(s0 ∈ s1, w2)→ ∀(s0 ∈(c2 ` s1), w2))))\n  albii(s1, (s1 ⊆ { s0 | w2 } →(c2 ` s1)⊆ { s0 | w2 }), (∀(s0 ∈ s1, w2)→ ∀(s0 ∈(c2 ` s1), w2)))\n  imbi12i(s1 ⊆ { s0 | w2 }, (c2 ` s1)⊆ { s0 | w2 }, ∀(s0 ∈ s1, w2), ∀(s0 ∈(c2 ` s1), w2))\n  ssabral(s0, s1, w2)\n  ssabral(s0, (c2 ` s1), w2)\n  elabg(s0, c0, c1, w2, w1)\n  diff.cab.s(s1, s0, w2)\n  diffss.ex(s1, s0)\n  diff.cfv.s(s0, c2, s1)\n  diff.cv.s(s0, s1)\n}","parent":["mpbidi","sseld","setrec2v","sylibr","albii","imbi12i","ssabral","elabg","diff.cab.s","diffss.ex","diff.cfv.s","diff.cv.s"],"children":[]}]}