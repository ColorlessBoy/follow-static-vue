{"index":60,"title":"Logical redundancy of ax-10 , ax-11 , ax-12 , ax-13","content":"The original axiom schemes of Tarski's predicate calculus are ~ ax-4 , ~ ax-5 , ~ ax6v , ~ ax-7 , ~ ax-8 , and ~ ax-9 , together with rule ~ ax-gen . See ~ mmset.html#compare . They are given as axiom schemes B4 through B8 in [KalishMontague] p. 81. These are shown to be logically complete by Theorem 1 of [KalishMontague] p. 85. The axiom system of set.mm includes the auxiliary axiom schemes ~ ax-10 , ~ ax-11 , ~ ax-12 , and ~ ax-13 , which are not part of Tarski's axiom schemes. Each object-language instance of them is provable from Tarski's axioms, so they are logically redundant. However, they are conjectured not to be provable directly _as schemes_ from Tarski's axiom schemes using only Metamath's direct substitution rule. They are used to make our system \"metalogically complete\", i.e., able to prove directly all possible schemes with wff and setvar variables, bundled or not, whose object-language instances are valid. ( ~ ax-12 has been proved to be required; see ~ http://us.metamath.org/award2003.html#9a . Metalogical independence of the other three are open problems.) (There are additional predicate calculus axiom schemes included in set.mm such as ~ ax-c5 , but they can all be proved as theorems from the above.) Terminology: Two setvar (individual) metavariables are \"bundled\" in an axiom or theorem scheme when there is no distinct variable constraint ($d) imposed on them. (The term \"bundled\" is due to Raph Levien.) For example, the ` x ` and ` y ` in ~ ax-6 are bundled, but they are not in ~ ax6v . We also say that a scheme is bundled when it has at least one pair of bundled setvar variables. If distinct variable conditions are added to all setvar variable pairs in a bundled scheme, we call that the \"principal\" instance of the bundled scheme. For example, ~ ax6v is the principal instance of ~ ax-6 . Whenever a common variable is substituted for two or more bundled variables in an axiom or theorem scheme, we call the substitution instance \"degenerate\". For example, the instance ` -. A. x -. x = x ` of ~ ax-6 is degenerate. An advantage of bundling is ease of use since there are fewer distinct variable restrictions ($d) to be concerned with, and theorems are more general. There may be some economy in being able to prove facts about principal and degenerate instances simultaneously. A disadvantage is that bundling may present difficulties in translations to other proof languages, which typically lack the concept (in part because their variables often represent the variables of the object language rather than metavariables ranging over them). Because Tarski's axiom schemes are logically complete, they can be used to prove any object-language instance of ~ ax-10 , ~ ax-11 , ~ ax-12 , and ~ ax-13 . \"Translating\" this to Metamath, it means that Tarski's axioms can prove any substitution instance of ~ ax-10 , ~ ax-11 , ~ ax-12 , or ~ ax-13 in which (1) there are no wff metavariables and (2) all setvar variables are mutually distinct i.e. are not bundled. In effect this is mimicking the object language by pretending that each setvar variable is an object-language variable. (There may also be specific instances with wff metavariables and/or bundling that are directly provable from Tarski's axiom schemes, but it isn't guaranteed. Whether all of them are possible is part of the still open metalogical independence problem for our additional axiom schemes.) It can be useful to see how this can be done, both to show that our additional schemes are valid metatheorems of Tarski's system and to be able to translate object-language instances of our proofs into proofs that would work with a system using only Tarski's original schemes. In addition, it may (or may not) provide insight into the conjectured metalogical independence of our additional schemes. The theorem schemes ~ ax10w , ~ ax11w , ~ ax12w , and ~ ax13w are derived using only Tarski's axiom schemes, showing that Tarski's schemes can be used to derive all substitution instances of ~ ax-10 , ~ ax-11 , ~ ax-12 , and ~ ax-13 meeting Conditions (1) and (2). (The \"w\" suffix stands for \"weak version\".) Each hypothesis of ~ ax10w , ~ ax11w , and ~ ax12w is of the form ` ( x = y -> ( ph <-> ps ) ) ` where ` ps ` is an auxiliary or \"dummy\" wff metavariable in which ` x ` doesn't occur. We can show by induction on formula length that the hypotheses can be eliminated in all cases meeting Conditions (1) and (2). The example ~ ax12wdemo illustrates the techniques (equality theorems and bound variable renaming) used to achieve this. We also show the degenerate instances for axioms with bundled variables in ~ ax11dgen , ~ ax12dgen , ~ ax13dgen1 , ~ ax13dgen2 , ~ ax13dgen3 , and ~ ax13dgen4 . (Their proofs are trivial, but we include them to be thorough.) Combining the principal and degenerate cases _outside_ of Metamath, we show that the bundled schemes ~ ax-10 , ~ ax-11 , ~ ax-12 , and ~ ax-13 are schemes of Tarski's system, meaning that all object-language instances they generate are theorems of Tarski's system. It is interesting that Tarski used the bundled scheme ~ ax-6 in an older system, so it seems the main purpose of his later ~ ax6v was just to show that the weaker unbundled form is sufficient rather than an aesthetic objection to bundled free and bound variables. Since we adopt the bundled ~ ax-6 as our official axiom, we show that the degenerate instance holds in ~ ax6dgen . (Recall that in set.mm, the only statement referencing ~ ax-6 is ~ ax6v .) The case of ~ sp is curious: originally an axiom scheme of Tarski's system, it was proved logically redundant by Lemma 9 of [KalishMontague] p. 86. However, the proof is by induction on formula length, and the scheme form ` A. x ph -> ph ` apparently cannot be proved directly from Tarski's other axiom schemes. The best we can do seems to be ~ spw , again requiring substitution instances of ` ph ` that meet Conditions (1) and (2) above. Note that our direct proof ~ sp requires ~ ax-12 , which is not part of Tarski's system.","blocks":[{"name":"ax6dgen","content":"Tarski's system uses the weaker ~ ax6v instead of the bundled ~ ax-6 , so here we show that the degenerate case of ~ ax-6 can be derived. Even though ~ ax-6 is in the list of axioms used, recall that in set.mm, the only statement referencing ~ ax-6 is ~ ax6v . We later rederive from ~ ax6v the bundled form as ~ ax6 with the help of the auxiliary axiom schemes. (Contributed by NM, 23-Apr-2017.)","origin":"thm ax6dgen(setvar s0) {\n  |- wn(wal(s0, wn(wceq(cv(s0), cv(s0)))))\n} = {\n  mt2(wal(s0, wn(wceq(cv(s0), cv(s0)))), wceq(cv(s0), cv(s0)))\n  spfalw(s0, wn(wceq(cv(s0), cv(s0))))\n  notnoti(wceq(cv(s0), cv(s0)))\n  equid(s0)\n}","pretty":"thm ax6dgen(setvar s0) {\n  ⊢ ¬ ∀(s0, ¬ s0 = s0)\n} = {\n  mt2(∀(s0, ¬ s0 = s0), s0 = s0)\n  spfalw(s0, ¬ s0 = s0)\n  notnoti(s0 = s0)\n  equid(s0)\n}","parent":["mt2","spfalw","notnoti","equid"],"children":[]},{"name":"ax10w","content":"Weak version of ~ ax-10 from which we can prove any ~ ax-10 instance not involving wff variables or bundling. Uses only Tarski's FOL axiom schemes. It is an alias of ~ hbn1w introduced for labeling consistency. (Contributed by NM, 9-Apr-2017.) Use ~ hbn1w instead. (New usage is discouraged.)","origin":"thm ax10w(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wn(wal(s0, w0)), wal(s0, wn(wal(s0, w0))))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w0)\n} = {\n  hbn1w(s0, s1, w0, w1)\n}","pretty":"thm ax10w(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (¬ ∀(s0, w0)→ ∀(s0, ¬ ∀(s0, w0)))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w0)\n} = {\n  hbn1w(s0, s1, w0, w1)\n}","parent":["hbn1w"],"children":[]},{"name":"ax11w","content":"Weak version of ~ ax-11 from which we can prove any ~ ax-11 instance not involving wff variables or bundling. Uses only Tarski's FOL axiom schemes. Unlike ~ ax-11 , this theorem requires that ` x ` and ` y ` be distinct i.e. are not bundled. It is an alias of ~ alcomiw introduced for labeling consistency. (Contributed by NM, 10-Apr-2017.) Use ~ alcomiw instead. (New usage is discouraged.)","origin":"thm ax11w(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  |- wi(wal(s0, wal(s1, w0)), wal(s1, wal(s0, w0)))\n  -| wi(wceq(cv(s1), cv(s2)), wb(w0, w1))\n  -| diffss(s0, s1)\n  -| diffss(s1, s2)\n  -| diffsw(s1, w1)\n  -| diffsw(s2, w0)\n} = {\n  alcomiw(s0, s1, s2, w0, w1)\n}","pretty":"thm ax11w(setvar s0, setvar s1, setvar s2, wff w0, wff w1) {\n  ⊢ (∀(s0, ∀(s1, w0))→ ∀(s1, ∀(s0, w0)))\n  ⊣ (s1 = s2 →(w0 ↔ w1))\n  ⊣ d(s0, s1)\n  ⊣ d(s1, s2)\n  ⊣ d(s1, w1)\n  ⊣ d(s2, w0)\n} = {\n  alcomiw(s0, s1, s2, w0, w1)\n}","parent":["alcomiw"],"children":[]},{"name":"ax11dgen","content":"Degenerate instance of ~ ax-11 where bundled variables ` x ` and ` y ` have a common substitution. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 13-Apr-2017.)","origin":"thm ax11dgen(setvar s0, wff w0) {\n  |- wi(wal(s0, wal(s0, w0)), wal(s0, wal(s0, w0)))\n} = {\n  id(wal(s0, wal(s0, w0)))\n}","pretty":"thm ax11dgen(setvar s0, wff w0) {\n  ⊢ (∀(s0, ∀(s0, w0))→ ∀(s0, ∀(s0, w0)))\n} = {\n  id(∀(s0, ∀(s0, w0)))\n}","parent":["id"],"children":[]},{"name":"ax12wlem","content":"Lemma for weak version of ~ ax-12 . Uses only Tarski's FOL axiom schemes. In some cases, this lemma may lead to shorter proofs than ~ ax12w . (Contributed by NM, 10-Apr-2017.)","origin":"thm ax12wlem(setvar s0, setvar s1, wff w0, wff w1) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(w0, wal(s0, wi(wceq(cv(s0), cv(s1)), w0))))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| diffsw(s0, w1)\n} = {\n  ax12i(s0, s1, w0, w1)\n  ax-5(s0, w1)\n}","pretty":"thm ax12wlem(setvar s0, setvar s1, wff w0, wff w1) {\n  ⊢ (s0 = s1 →(w0 → ∀(s0,(s0 = s1 → w0))))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ d(s0, w1)\n} = {\n  ax12i(s0, s1, w0, w1)\n  ax-5(s0, w1)\n}","parent":["ax12i","ax-5"],"children":["ax12w"]},{"name":"ax12w","content":"Weak version of ~ ax-12 from which we can prove any ~ ax-12 instance not involving wff variables or bundling. Uses only Tarski's FOL axiom schemes. An instance of the first hypothesis will normally require that ` x ` and ` y ` be distinct (unless ` x ` does not occur in ` ph ` ). For an example of how the hypotheses can be eliminated when we substitute an expression without wff variables for ` ph ` , see ~ ax12wdemo . (Contributed by NM, 10-Apr-2017.)","origin":"thm ax12w(setvar s0, setvar s1, setvar s2, wff w0, wff w1, wff w2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wal(s1, w0), wal(s0, wi(wceq(cv(s0), cv(s1)), w0))))\n  -| wi(wceq(cv(s0), cv(s1)), wb(w0, w1))\n  -| wi(wceq(cv(s1), cv(s2)), wb(w0, w2))\n  -| diffss(s1, s2)\n  -| diffsw(s0, w1)\n  -| diffsw(s1, w2)\n  -| diffsw(s2, w0)\n} = {\n  syl5(wceq(cv(s0), cv(s1)), wal(s1, w0), wal(s0, wi(wceq(cv(s0), cv(s1)), w0)), w0)\n  spw(s1, s2, w0, w2)\n  ax12wlem(s0, s1, w0, w1)\n}","pretty":"thm ax12w(setvar s0, setvar s1, setvar s2, wff w0, wff w1, wff w2) {\n  ⊢ (s0 = s1 →(∀(s1, w0)→ ∀(s0,(s0 = s1 → w0))))\n  ⊣ (s0 = s1 →(w0 ↔ w1))\n  ⊣ (s1 = s2 →(w0 ↔ w2))\n  ⊣ d(s1, s2)\n  ⊣ d(s0, w1)\n  ⊣ d(s1, w2)\n  ⊣ d(s2, w0)\n} = {\n  syl5(s0 = s1, ∀(s1, w0), ∀(s0,(s0 = s1 → w0)), w0)\n  spw(s1, s2, w0, w2)\n  ax12wlem(s0, s1, w0, w1)\n}","parent":["syl5","spw","ax12wlem"],"children":["ax12wdemo"]},{"name":"ax12dgen","content":"Degenerate instance of ~ ax-12 where bundled variables ` x ` and ` y ` have a common substitution. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 13-Apr-2017.)","origin":"thm ax12dgen(setvar s0, wff w0) {\n  |- wi(wceq(cv(s0), cv(s0)), wi(wal(s0, w0), wal(s0, wi(wceq(cv(s0), cv(s0)), w0))))\n} = {\n  a1i(wceq(cv(s0), cv(s0)), wi(wal(s0, w0), wal(s0, wi(wceq(cv(s0), cv(s0)), w0))))\n  ala1(s0, w0, wceq(cv(s0), cv(s0)))\n}","pretty":"thm ax12dgen(setvar s0, wff w0) {\n  ⊢ (s0 = s0 →(∀(s0, w0)→ ∀(s0,(s0 = s0 → w0))))\n} = {\n  a1i(s0 = s0, (∀(s0, w0)→ ∀(s0,(s0 = s0 → w0))))\n  ala1(s0, w0, s0 = s0)\n}","parent":["a1i","ala1"],"children":[]},{"name":"ax12wdemo","content":"Example of an application of ~ ax12w that results in an instance of ~ ax-12 for a contrived formula with mixed free and bound variables, ` ( x e. y /\\ A. x z e. x /\\ A. y A. z y e. x ) ` , in place of ` ph ` . The proof illustrates bound variable renaming with ~ cbvalvw to obtain fresh variables to avoid distinct variable clashes. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 14-Apr-2017.)","origin":"thm ax12wdemo(setvar s0, setvar s1, setvar s2) {\n  |- wi(wceq(cv(s0), cv(s1)), wi(wal(s1, w3a(wcel(cv(s0), cv(s1)), wal(s0, wcel(cv(s2), cv(s0))), wal(s1, wal(s2, wcel(cv(s1), cv(s0)))))), wal(s0, wi(wceq(cv(s0), cv(s1)), w3a(wcel(cv(s0), cv(s1)), wal(s0, wcel(cv(s2), cv(s0))), wal(s1, wal(s2, wcel(cv(s1), cv(s0)))))))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n} = {\n  ax12w(s0, s1, hs1, w3a(wcel(cv(s0), cv(s1)), wal(s0, wcel(cv(s2), cv(s0))), wal(s1, wal(s2, wcel(cv(s1), cv(s0))))), w3a(wcel(cv(s1), cv(s1)), wal(hs0, wcel(cv(s2), cv(hs0))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s1))))), w3a(wcel(cv(s0), cv(hs1)), wal(s0, wcel(cv(s2), cv(s0))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s0))))))\n  3anbi123d(wceq(cv(s0), cv(s1)), wcel(cv(s0), cv(s1)), wal(s0, wcel(cv(s2), cv(s0))), wal(s1, wal(s2, wcel(cv(s1), cv(s0)))), wcel(cv(s1), cv(s1)), wal(hs0, wcel(cv(s2), cv(hs0))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s1)))))\n  elequ1(s0, s1, s1)\n  a1i(wceq(cv(s0), cv(s1)), wb(wal(s0, wcel(cv(s2), cv(s0))), wal(hs0, wcel(cv(s2), cv(hs0)))))\n  cbvalvw(s0, hs0, wcel(cv(s2), cv(s0)), wcel(cv(s2), cv(hs0)))\n  elequ2(s0, hs0, s2)\n  syl5bb(wceq(cv(s0), cv(s1)), wal(s1, wal(s2, wcel(cv(s1), cv(s0)))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s1)))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s0)))))\n  albidv(hs1, wceq(cv(s0), cv(s1)), wal(s2, wcel(cv(hs1), cv(s0))), wal(s2, wcel(cv(hs1), cv(s1))))\n  albidv(s2, wceq(cv(s0), cv(s1)), wcel(cv(hs1), cv(s0)), wcel(cv(hs1), cv(s1)))\n  elequ2(s0, s1, hs1)\n  3anbi13d(wceq(cv(s1), cv(hs1)), wcel(cv(s0), cv(s1)), wal(s0, wcel(cv(s2), cv(s0))), wal(s1, wal(s2, wcel(cv(s1), cv(s0)))), wcel(cv(s0), cv(hs1)), wal(hs1, wal(s2, wcel(cv(hs1), cv(s0)))))\n  elequ2(s1, hs1, s0)\n  a1i(wceq(cv(s1), cv(hs1)), wb(wal(s1, wal(s2, wcel(cv(s1), cv(s0)))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s0))))))\n  cbvalvw(s1, hs1, wal(s2, wcel(cv(s1), cv(s0))), wal(s2, wcel(cv(hs1), cv(s0))))\n  albidv(s2, wceq(cv(s1), cv(hs1)), wcel(cv(s1), cv(s0)), wcel(cv(hs1), cv(s0)))\n  elequ1(s1, hs1, s0)\n  diff.w3a.s(s0, wcel(cv(s1), cv(s1)), wal(hs0, wcel(cv(s2), cv(hs0))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s1)))))\n  diff.wcel.s(s0, cv(s1), cv(s1))\n  diff.wal.s(s0, hs0, wcel(cv(s2), cv(hs0)))\n  diff.wal.s(s0, hs1, wal(s2, wcel(cv(hs1), cv(s1))))\n  diff.wal.s(s0, s2, wcel(cv(hs1), cv(s1)))\n  diff.wcel.s(s0, cv(hs1), cv(s1))\n  diff.cv.s(s0, hs1)\n  diffss.ex(s0, hs1)\n  diff.hs1.s(s0)\n  diff.cv.s(s0, s1)\n  diff.w3a.s(s1, wcel(cv(s0), cv(hs1)), wal(s0, wcel(cv(s2), cv(s0))), wal(hs1, wal(s2, wcel(cv(hs1), cv(s0)))))\n  diff.wcel.s(s1, cv(s0), cv(hs1))\n  diff.wal.s(s1, s0, wcel(cv(s2), cv(s0)))\n  diff.wcel.s(s1, cv(s2), cv(s0))\n  diff.cv.s(s1, s2)\n  diff.wal.s(s1, hs1, wal(s2, wcel(cv(hs1), cv(s0))))\n  diff.hs1.w(w3a(wcel(cv(s0), cv(s1)), wal(s0, wcel(cv(s2), cv(s0))), wal(s1, wal(s2, wcel(cv(s1), cv(s0))))))\n  diff.wcel.s(s0, cv(s2), cv(hs0))\n  diff.cv.s(s0, s2)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(wcel(cv(s2), cv(s0)))\n  diff.wal.s(s1, s2, wcel(cv(hs1), cv(s0)))\n  diff.wcel.s(s1, cv(hs1), cv(s0))\n  diff.cv.s(s1, hs1)\n  diffss.ex(s1, hs1)\n  diff.hs1.s(s1)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.hs1.w(wal(s2, wcel(cv(s1), cv(s0))))\n  diff.wceq.s(s2, cv(s1), cv(hs1))\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n  diff.hs1.w(wceq(cv(s0), cv(s1)))\n  diff.wceq.s(s2, cv(s0), cv(s1))\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","pretty":"thm ax12wdemo(setvar s0, setvar s1, setvar s2) {\n  ⊢ (s0 = s1 →(∀(s1,(s0 ∈ s1 ∧ ∀(s0, s2 ∈ s0)∧ ∀(s1, ∀(s2, s1 ∈ s0))))→ ∀(s0,(s0 = s1 →(s0 ∈ s1 ∧ ∀(s0, s2 ∈ s0)∧ ∀(s1, ∀(s2, s1 ∈ s0)))))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n} = {\n  ax12w(s0, s1, hs1, (s0 ∈ s1 ∧ ∀(s0, s2 ∈ s0)∧ ∀(s1, ∀(s2, s1 ∈ s0))), (s1 ∈ s1 ∧ ∀(hs0, s2 ∈ hs0)∧ ∀(hs1, ∀(s2, hs1 ∈ s1))), (s0 ∈ hs1 ∧ ∀(s0, s2 ∈ s0)∧ ∀(hs1, ∀(s2, hs1 ∈ s0))))\n  3anbi123d(s0 = s1, s0 ∈ s1, ∀(s0, s2 ∈ s0), ∀(s1, ∀(s2, s1 ∈ s0)), s1 ∈ s1, ∀(hs0, s2 ∈ hs0), ∀(hs1, ∀(s2, hs1 ∈ s1)))\n  elequ1(s0, s1, s1)\n  a1i(s0 = s1, (∀(s0, s2 ∈ s0)↔ ∀(hs0, s2 ∈ hs0)))\n  cbvalvw(s0, hs0, s2 ∈ s0, s2 ∈ hs0)\n  elequ2(s0, hs0, s2)\n  syl5bb(s0 = s1, ∀(s1, ∀(s2, s1 ∈ s0)), ∀(hs1, ∀(s2, hs1 ∈ s1)), ∀(hs1, ∀(s2, hs1 ∈ s0)))\n  albidv(hs1, s0 = s1, ∀(s2, hs1 ∈ s0), ∀(s2, hs1 ∈ s1))\n  albidv(s2, s0 = s1, hs1 ∈ s0, hs1 ∈ s1)\n  elequ2(s0, s1, hs1)\n  3anbi13d(s1 = hs1, s0 ∈ s1, ∀(s0, s2 ∈ s0), ∀(s1, ∀(s2, s1 ∈ s0)), s0 ∈ hs1, ∀(hs1, ∀(s2, hs1 ∈ s0)))\n  elequ2(s1, hs1, s0)\n  a1i(s1 = hs1, (∀(s1, ∀(s2, s1 ∈ s0))↔ ∀(hs1, ∀(s2, hs1 ∈ s0))))\n  cbvalvw(s1, hs1, ∀(s2, s1 ∈ s0), ∀(s2, hs1 ∈ s0))\n  albidv(s2, s1 = hs1, s1 ∈ s0, hs1 ∈ s0)\n  elequ1(s1, hs1, s0)\n  diff.w3a.s(s0, s1 ∈ s1, ∀(hs0, s2 ∈ hs0), ∀(hs1, ∀(s2, hs1 ∈ s1)))\n  diff.wcel.s(s0, s1, s1)\n  diff.wal.s(s0, hs0, s2 ∈ hs0)\n  diff.wal.s(s0, hs1, ∀(s2, hs1 ∈ s1))\n  diff.wal.s(s0, s2, hs1 ∈ s1)\n  diff.wcel.s(s0, hs1, s1)\n  diff.cv.s(s0, hs1)\n  diffss.ex(s0, hs1)\n  diff.hs1.s(s0)\n  diff.cv.s(s0, s1)\n  diff.w3a.s(s1, s0 ∈ hs1, ∀(s0, s2 ∈ s0), ∀(hs1, ∀(s2, hs1 ∈ s0)))\n  diff.wcel.s(s1, s0, hs1)\n  diff.wal.s(s1, s0, s2 ∈ s0)\n  diff.wcel.s(s1, s2, s0)\n  diff.cv.s(s1, s2)\n  diff.wal.s(s1, hs1, ∀(s2, hs1 ∈ s0))\n  diff.hs1.w((s0 ∈ s1 ∧ ∀(s0, s2 ∈ s0)∧ ∀(s1, ∀(s2, s1 ∈ s0))))\n  diff.wcel.s(s0, s2, hs0)\n  diff.cv.s(s0, s2)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.hs0.w(s2 ∈ s0)\n  diff.wal.s(s1, s2, hs1 ∈ s0)\n  diff.wcel.s(s1, hs1, s0)\n  diff.cv.s(s1, hs1)\n  diffss.ex(s1, hs1)\n  diff.hs1.s(s1)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.hs1.w(∀(s2, s1 ∈ s0))\n  diff.wceq.s(s2, s1, hs1)\n  diff.cv.s(s2, hs1)\n  diffss.ex(s2, hs1)\n  diff.hs1.s(s2)\n  diff.hs1.w(s0 = s1)\n  diff.wceq.s(s2, s0, s1)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n  diff.cv.s(s2, s1)\n  diffss.ex(s2, s1)\n}","parent":["ax12w","3anbi123d","elequ1","a1i","cbvalvw","elequ2","syl5bb","albidv","3anbi13d","diff.w3a.s","diff.wcel.s","diff.wal.s","diff.cv.s","diffss.ex","diff.hs1.s","diff.hs1.w","diff.hs0.s","diff.hs0.w","diff.wceq.s"],"children":[]},{"name":"ax13w","content":"Weak version (principal instance) of ~ ax-13 . (Because ` y ` and ` z ` don't need to be distinct, this actually bundles the principal instance and the degenerate instance ` ( -. x = y -> ( y = y -> A. x y = y ) ) ` .) Uses only Tarski's FOL axiom schemes. The proof is trivial but is included to complete the set ~ ax10w , ~ ax11w , and ~ ax12w . (Contributed by NM, 10-Apr-2017.)","origin":"thm ax13w(setvar s0, setvar s1, setvar s2) {\n  |- wi(wn(wceq(cv(s0), cv(s1))), wi(wceq(cv(s1), cv(s2)), wal(s0, wceq(cv(s1), cv(s2)))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n} = {\n  ax5d(s0, wn(wceq(cv(s0), cv(s1))), wceq(cv(s1), cv(s2)))\n  diff.wceq.s(s0, cv(s1), cv(s2))\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, s2)\n}","pretty":"thm ax13w(setvar s0, setvar s1, setvar s2) {\n  ⊢ (¬ s0 = s1 →(s1 = s2 → ∀(s0, s1 = s2)))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n} = {\n  ax5d(s0, ¬ s0 = s1, s1 = s2)\n  diff.wceq.s(s0, s1, s2)\n  diff.cv.s(s0, s1)\n  diff.cv.s(s0, s2)\n}","parent":["ax5d","diff.wceq.s","diff.cv.s"],"children":[]},{"name":"ax13dgen1","content":"Degenerate instance of ~ ax-13 where bundled variables ` x ` and ` y ` have a common substitution. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 13-Apr-2017.)","origin":"thm ax13dgen1(setvar s0, setvar s1) {\n  |- wi(wn(wceq(cv(s0), cv(s0))), wi(wceq(cv(s0), cv(s1)), wal(s0, wceq(cv(s0), cv(s1)))))\n} = {\n  pm2.24i(wceq(cv(s0), cv(s0)), wi(wceq(cv(s0), cv(s1)), wal(s0, wceq(cv(s0), cv(s1)))))\n  equid(s0)\n}","pretty":"thm ax13dgen1(setvar s0, setvar s1) {\n  ⊢ (¬ s0 = s0 →(s0 = s1 → ∀(s0, s0 = s1)))\n} = {\n  pm2.24i(s0 = s0, (s0 = s1 → ∀(s0, s0 = s1)))\n  equid(s0)\n}","parent":["pm2.24i","equid"],"children":[]},{"name":"ax13dgen2","content":"Degenerate instance of ~ ax-13 where bundled variables ` x ` and ` z ` have a common substitution. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 13-Apr-2017.)","origin":"thm ax13dgen2(setvar s0, setvar s1) {\n  |- wi(wn(wceq(cv(s0), cv(s1))), wi(wceq(cv(s1), cv(s0)), wal(s0, wceq(cv(s1), cv(s0)))))\n} = {\n  syl5(wn(wceq(cv(s0), cv(s1))), wceq(cv(s1), cv(s0)), wal(s0, wceq(cv(s1), cv(s0))), wceq(cv(s0), cv(s1)))\n  equcomi(s1, s0)\n  pm2.21(wceq(cv(s0), cv(s1)), wal(s0, wceq(cv(s1), cv(s0))))\n}","pretty":"thm ax13dgen2(setvar s0, setvar s1) {\n  ⊢ (¬ s0 = s1 →(s1 = s0 → ∀(s0, s1 = s0)))\n} = {\n  syl5(¬ s0 = s1, s1 = s0, ∀(s0, s1 = s0), s0 = s1)\n  equcomi(s1, s0)\n  pm2.21(s0 = s1, ∀(s0, s1 = s0))\n}","parent":["syl5","equcomi","pm2.21"],"children":[]},{"name":"ax13dgen3","content":"Degenerate instance of ~ ax-13 where bundled variables ` y ` and ` z ` have a common substitution. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 13-Apr-2017.)","origin":"thm ax13dgen3(setvar s0, setvar s1) {\n  |- wi(wn(wceq(cv(s0), cv(s1))), wi(wceq(cv(s1), cv(s1)), wal(s0, wceq(cv(s1), cv(s1)))))\n} = {\n  2a1i(wn(wceq(cv(s0), cv(s1))), wceq(cv(s1), cv(s1)), wal(s0, wceq(cv(s1), cv(s1))))\n  ax-gen(s0, wceq(cv(s1), cv(s1)))\n  equid(s1)\n}","pretty":"thm ax13dgen3(setvar s0, setvar s1) {\n  ⊢ (¬ s0 = s1 →(s1 = s1 → ∀(s0, s1 = s1)))\n} = {\n  2a1i(¬ s0 = s1, s1 = s1, ∀(s0, s1 = s1))\n  ax-gen(s0, s1 = s1)\n  equid(s1)\n}","parent":["2a1i","ax-gen","equid"],"children":[]},{"name":"ax13dgen4","content":"Degenerate instance of ~ ax-13 where bundled variables ` x ` , ` y ` , and ` z ` have a common substitution. Therefore, also a degenerate instance of ~ ax13dgen1 , ~ ax13dgen2 , and ~ ax13dgen3 . Also an instance of the intuitionistic tautology ~ pm2.21 . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 13-Apr-2017.) Reduce axiom usage. (Revised by Wolf Lammen, 10-Oct-2021.)","origin":"thm ax13dgen4(setvar s0) {\n  |- wi(wn(wceq(cv(s0), cv(s0))), wi(wceq(cv(s0), cv(s0)), wal(s0, wceq(cv(s0), cv(s0)))))\n} = {\n  pm2.21(wceq(cv(s0), cv(s0)), wal(s0, wceq(cv(s0), cv(s0))))\n}","pretty":"thm ax13dgen4(setvar s0) {\n  ⊢ (¬ s0 = s0 →(s0 = s0 → ∀(s0, s0 = s0)))\n} = {\n  pm2.21(s0 = s0, ∀(s0, s0 = s0))\n}","parent":["pm2.21"],"children":[]}]}