{"index":1504,"title":"Auxiliary theorems","content":"","blocks":[{"name":"ovn0dmfun","content":"If a class operation value for two operands is not the empty set, then the operands are contained in the domain of the class, and the class restricted to the operands is a function, analogous to ~ fvfundmfvn0 . (Contributed by AV, 27-Jan-2020.)","origin":"thm ovn0dmfun(class c0, class c1, class c2) {\n  |- wi(wne(co(c0, c1, c2), emptycls), wa(wcel(cop(c0, c2), cdm(c1)), wfun(cres(c1, csn(cop(c0, c2))))))\n} = {\n  sylbi(wne(co(c0, c1, c2), emptycls), wa(wcel(cop(c0, c2), cdm(c1)), wfun(cres(c1, csn(cop(c0, c2))))), wne(cfv(c1, cop(c0, c2)), emptycls))\n  neeq1i(co(c0, c1, c2), emptycls, cfv(c1, cop(c0, c2)))\n  df-ov(c0, c1, c2)\n  fvfundmfvn0(c1, cop(c0, c2))\n}","pretty":"thm ovn0dmfun(class c0, class c1, class c2) {\n  ⊢ ((c0[c1]c2)≠ ∅ →(< c0, c2 > ∈ dom(c1)∧ Fun((c1 |` { < c0, c2 > }))))\n} = {\n  sylbi((c0[c1]c2)≠ ∅, (< c0, c2 > ∈ dom(c1)∧ Fun((c1 |` { < c0, c2 > }))), (c1 ` < c0, c2 >)≠ ∅)\n  neeq1i((c0[c1]c2), emptycls, (c1 ` < c0, c2 >))\n  df-ov(c0, c1, c2)\n  fvfundmfvn0(c1, < c0, c2 >)\n}","parent":["sylbi","neeq1i","df-ov","fvfundmfvn0"],"children":[]},{"name":"xpsnopab","content":"A Cartesian product with a singleton expressed as ordered-pair class abstraction. (Contributed by AV, 27-Jan-2020.)","origin":"thm xpsnopab(setvar s0, setvar s1, class c0, class c1) {\n  |- wceq(cxp(csn(c0), c1), copab(s0, s1, wa(wceq(cv(s0), c0), wcel(cv(s1), c1))))\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s1, c0)\n  -| diffsc(s1, c1)\n} = {\n  eqtri(cxp(csn(c0), c1), copab(s0, s1, wa(wceq(cv(s0), c0), wcel(cv(s1), c1))), copab(s0, s1, wa(wcel(cv(s0), csn(c0)), wcel(cv(s1), c1))))\n  df-xp(s0, s1, csn(c0), c1)\n  opabbii(s0, s1, wa(wcel(cv(s0), csn(c0)), wcel(cv(s1), c1)), wa(wceq(cv(s0), c0), wcel(cv(s1), c1)))\n  anbi1i(wcel(cv(s0), csn(c0)), wcel(cv(s1), c1), wceq(cv(s0), c0))\n  velsn(s0, c0)\n  diff.csn.s(s0, c0)\n  diff.csn.s(s1, c0)\n}","pretty":"thm xpsnopab(setvar s0, setvar s1, class c0, class c1) {\n  ⊢ ({ c0 } × c1)= { < s0, s1 > |(s0 = c0 ∧ s1 ∈ c1)}\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s1, c0)\n  ⊣ d(s1, c1)\n} = {\n  eqtri(({ c0 } × c1), { < s0, s1 > |(s0 = c0 ∧ s1 ∈ c1)}, { < s0, s1 > |(s0 ∈ { c0 } ∧ s1 ∈ c1)})\n  df-xp(s0, s1, { c0 }, c1)\n  opabbii(s0, s1, (s0 ∈ { c0 } ∧ s1 ∈ c1), (s0 = c0 ∧ s1 ∈ c1))\n  anbi1i(s0 ∈ { c0 }, s1 ∈ c1, s0 = c0)\n  velsn(s0, c0)\n  diff.csn.s(s0, c0)\n  diff.csn.s(s1, c0)\n}","parent":["eqtri","df-xp","opabbii","anbi1i","velsn","diff.csn.s"],"children":["xpiun"]},{"name":"xpiun","content":"A Cartesian product expressed as indexed union of ordered-pair class abstractions. (Contributed by AV, 27-Jan-2020.)","origin":"thm xpiun(setvar s0, setvar s1, setvar s2, class c0, class c1) {\n  |- wceq(cxp(c0, c1), ciun(s0, c0, copab(s1, s2, wa(wceq(cv(s1), cv(s0)), wcel(cv(s2), c1)))))\n  -| diffss(s0, s1)\n  -| diffss(s0, s2)\n  -| diffss(s1, s2)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s1, c1)\n  -| diffsc(s2, c1)\n} = {\n  eqtr2i(cxp(c0, c1), ciun(s0, c0, copab(s1, s2, wa(wceq(cv(s1), cv(s0)), wcel(cv(s2), c1)))), ciun(s0, c0, cxp(csn(cv(s0)), c1)))\n  iuneq2i(s0, c0, copab(s1, s2, wa(wceq(cv(s1), cv(s0)), wcel(cv(s2), c1))), cxp(csn(cv(s0)), c1))\n  a1i(wcel(cv(s0), c0), wceq(copab(s1, s2, wa(wceq(cv(s1), cv(s0)), wcel(cv(s2), c1))), cxp(csn(cv(s0)), c1)))\n  eqcomi(copab(s1, s2, wa(wceq(cv(s1), cv(s0)), wcel(cv(s2), c1))), cxp(csn(cv(s0)), c1))\n  xpsnopab(s1, s2, cv(s0), c1)\n  iunxpconst(s0, c0, c1)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n}","pretty":"thm xpiun(setvar s0, setvar s1, setvar s2, class c0, class c1) {\n  ⊢ (c0 × c1)= ⋃(s0 ∈ c0, { < s1, s2 > |(s1 = s0 ∧ s2 ∈ c1)})\n  ⊣ d(s0, s1)\n  ⊣ d(s0, s2)\n  ⊣ d(s1, s2)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s1, c1)\n  ⊣ d(s2, c1)\n} = {\n  eqtr2i((c0 × c1), ⋃(s0 ∈ c0, { < s1, s2 > |(s1 = s0 ∧ s2 ∈ c1)}), ⋃(s0 ∈ c0,({ s0 } × c1)))\n  iuneq2i(s0, c0, { < s1, s2 > |(s1 = s0 ∧ s2 ∈ c1)}, ({ s0 } × c1))\n  a1i(s0 ∈ c0, { < s1, s2 > |(s1 = s0 ∧ s2 ∈ c1)} =({ s0 } × c1))\n  eqcomi({ < s1, s2 > |(s1 = s0 ∧ s2 ∈ c1)}, ({ s0 } × c1))\n  xpsnopab(s1, s2, s0, c1)\n  iunxpconst(s0, c0, c1)\n  diff.cv.s(s1, s0)\n  diffss.ex(s1, s0)\n  diff.cv.s(s2, s0)\n  diffss.ex(s2, s0)\n}","parent":["eqtr2i","iuneq2i","a1i","eqcomi","xpsnopab","iunxpconst","diff.cv.s","diffss.ex"],"children":[]},{"name":"ovn0ssdmfun","content":"If a class' operation value for two operands is not the empty set, the operands are contained in the domain of the class, and the class restricted to the operands is a function, analogous to ~ fvfundmfvn0 . (Contributed by AV, 27-Jan-2020.)","origin":"thm ovn0ssdmfun(setvar s0, setvar s1, class c0, class c1, class c2) {\n  |- wi(wral(s0, c0, wral(s1, c1, wne(co(cv(s0), c2, cv(s1)), emptycls))), wa(wss(cxp(c0, c1), cdm(c2)), wfun(cres(c2, cxp(c0, c1)))))\n  -| diffss(s0, s1)\n  -| diffsc(s0, c0)\n  -| diffsc(s0, c1)\n  -| diffsc(s0, c2)\n  -| diffsc(s1, c0)\n  -| diffsc(s1, c1)\n  -| diffsc(s1, c2)\n} = {\n  sylbir(wral(s0, c0, wral(s1, c1, wne(co(cv(s0), c2, cv(s1)), emptycls))), wa(wss(cxp(c0, c1), cdm(c2)), wfun(cres(c2, cxp(c0, c1)))), wral(hs0, cxp(c0, c1), wne(cfv(c2, cv(hs0)), emptycls)))\n  ralxp(hs0, s0, s1, c0, c1, wne(cfv(c2, cv(hs0)), emptycls), wne(co(cv(s0), c2, cv(s1)), emptycls))\n  neeq1d(cfv(c2, cv(hs0)), emptycls, co(cv(s0), c2, cv(s1)), wceq(cv(hs0), cop(cv(s0), cv(s1))))\n  syl6eqr(cfv(c2, cv(hs0)), co(cv(s0), c2, cv(s1)), cfv(c2, cop(cv(s0), cv(s1))), wceq(cv(hs0), cop(cv(s0), cv(s1))))\n  fveq2(cv(hs0), cop(cv(s0), cv(s1)), c2)\n  df-ov(cv(s0), c2, cv(s1))\n  fvn0ssdmfun(hs0, cxp(c0, c1), c2)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs0.w(wne(co(cv(s0), c2, cv(s1)), emptycls))\n  diff.wne.s(s0, cfv(c2, cv(hs0)), emptycls)\n  diff.cfv.s(s0, c2, cv(hs0))\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.emptycls.s(s0)\n  diff.wne.s(s1, cfv(c2, cv(hs0)), emptycls)\n  diff.cfv.s(s1, c2, cv(hs0))\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.emptycls.s(s1)\n  diff.hs0.c(cxp(c0, c1))\n  diff.hs0.c(c2)\n}","pretty":"thm ovn0ssdmfun(setvar s0, setvar s1, class c0, class c1, class c2) {\n  ⊢ (∀(s0 ∈ c0, ∀(s1 ∈ c1,(s0[c2]s1)≠ ∅))→((c0 × c1)⊆ dom(c2)∧ Fun((c2 |`(c0 × c1)))))\n  ⊣ d(s0, s1)\n  ⊣ d(s0, c0)\n  ⊣ d(s0, c1)\n  ⊣ d(s0, c2)\n  ⊣ d(s1, c0)\n  ⊣ d(s1, c1)\n  ⊣ d(s1, c2)\n} = {\n  sylbir(∀(s0 ∈ c0, ∀(s1 ∈ c1,(s0[c2]s1)≠ ∅)), ((c0 × c1)⊆ dom(c2)∧ Fun((c2 |`(c0 × c1)))), ∀(hs0 ∈(c0 × c1),(c2 ` hs0)≠ ∅))\n  ralxp(hs0, s0, s1, c0, c1, (c2 ` hs0)≠ ∅, (s0[c2]s1)≠ ∅)\n  neeq1d((c2 ` hs0), emptycls, (s0[c2]s1), hs0 = < s0, s1 >)\n  syl6eqr((c2 ` hs0), (s0[c2]s1), (c2 ` < s0, s1 >), hs0 = < s0, s1 >)\n  fveq2(hs0, < s0, s1 >, c2)\n  df-ov(s0, c2, s1)\n  fvn0ssdmfun(hs0, (c0 × c1), c2)\n  diff.hs0.c(c0)\n  diff.hs0.c(c1)\n  diff.hs0.w((s0[c2]s1)≠ ∅)\n  diff.wne.s(s0, (c2 ` hs0), emptycls)\n  diff.cfv.s(s0, c2, hs0)\n  diff.cv.s(s0, hs0)\n  diffss.ex(s0, hs0)\n  diff.hs0.s(s0)\n  diff.emptycls.s(s0)\n  diff.wne.s(s1, (c2 ` hs0), emptycls)\n  diff.cfv.s(s1, c2, hs0)\n  diff.cv.s(s1, hs0)\n  diffss.ex(s1, hs0)\n  diff.hs0.s(s1)\n  diff.emptycls.s(s1)\n  diff.hs0.c((c0 × c1))\n  diff.hs0.c(c2)\n}","parent":["sylbir","ralxp","neeq1d","syl6eqr","fveq2","df-ov","fvn0ssdmfun","diff.hs0.c","diff.hs0.w","diff.wne.s","diff.cfv.s","diff.cv.s","diffss.ex","diff.hs0.s","diff.emptycls.s"],"children":[]},{"name":"fnxpdmdm","content":"The domain of the domain of a function over a Cartesian square. (Contributed by AV, 13-Jan-2020.)","origin":"thm fnxpdmdm(class c0, class c1) {\n  |- wi(wfn(c0, cxp(c1, c1)), wceq(cdm(cdm(c0)), c1))\n} = {\n  syl(wfn(c0, cxp(c1, c1)), wceq(cdm(cdm(c0)), c1), wceq(cdm(c0), cxp(c1, c1)))\n  fndm(c0, cxp(c1, c1))\n  syl6eq(cdm(cdm(c0)), c1, cdm(cxp(c1, c1)), wceq(cdm(c0), cxp(c1, c1)))\n  dmeq(cdm(c0), cxp(c1, c1))\n  dmxpid(c1)\n}","pretty":"thm fnxpdmdm(class c0, class c1) {\n  ⊢ (c0[Fn](c1 × c1)→ dom(dom(c0))= c1)\n} = {\n  syl(c0[Fn](c1 × c1), dom(dom(c0))= c1, dom(c0)=(c1 × c1))\n  fndm(c0, (c1 × c1))\n  syl6eq(dom(dom(c0)), c1, dom((c1 × c1)), dom(c0)=(c1 × c1))\n  dmeq(dom(c0), (c1 × c1))\n  dmxpid(c1)\n}","parent":["syl","fndm","syl6eq","dmeq","dmxpid"],"children":[]},{"name":"cnfldsrngbas","content":"The base set of a subring of the field of complex numbers. (Contributed by AV, 31-Jan-2020.)","origin":"thm cnfldsrngbas(class c0, class c1) {\n  |- wi(wss(c0, cc), wceq(c0, cfv(cbs, c1)))\n  -| wceq(c1, co(ccnfld, cress, c0))\n} = {\n  ressbas2(c0, cc, c1, ccnfld)\n  cnfldbas()\n}","pretty":"thm cnfldsrngbas(class c0, class c1) {\n  ⊢ (c0 ⊆ ℂ → c0 =(Base ` c1))\n  ⊣ c1 =(CCfld[|`s]c0)\n} = {\n  ressbas2(c0, cc, c1, ccnfld)\n  cnfldbas()\n}","parent":["ressbas2","cnfldbas"],"children":["oddibas","nnsgrpmgm","nnsgrp","nnsgrpnmnd","2zrngbas"]},{"name":"cnfldsrngadd","content":"The group addition operation of a subring of the field of complex numbers. (Contributed by AV, 31-Jan-2020.)","origin":"thm cnfldsrngadd(class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wceq(caddc, cfv(cplusg, c2)))\n  -| wceq(c2, co(ccnfld, cress, c0))\n} = {\n  ressplusg(c0, c1, caddc, c2, ccnfld)\n  cnfldadd()\n}","pretty":"thm cnfldsrngadd(class c0, class c1, class c2) {\n  ⊢ (c0 ∈ c1 → + =(+ ` c2))\n  ⊣ c2 =(CCfld[|`s]c0)\n} = {\n  ressplusg(c0, c1, caddc, c2, ccnfld)\n  cnfldadd()\n}","parent":["ressplusg","cnfldadd"],"children":["oddiadd","nnsgrpmgm","nnsgrp","nnsgrpnmnd","2zrngadd"]},{"name":"cnfldsrngmul","content":"The ring multiplication operation of a subring of the field of complex numbers. (Contributed by AV, 31-Jan-2020.)","origin":"thm cnfldsrngmul(class c0, class c1, class c2) {\n  |- wi(wcel(c0, c1), wceq(cmul, cfv(cmulr, c2)))\n  -| wceq(c2, co(ccnfld, cress, c0))\n} = {\n  ressmulr(c0, c1, cmul, c2, ccnfld)\n  cnfldmul()\n}","pretty":"thm cnfldsrngmul(class c0, class c1, class c2) {\n  ⊢ (c0 ∈ c1 → × =(× ` c2))\n  ⊣ c2 =(CCfld[|`s]c0)\n} = {\n  ressmulr(c0, c1, cmul, c2, ccnfld)\n  cnfldmul()\n}","parent":["ressmulr","cnfldmul"],"children":["2zrngmul"]}]}